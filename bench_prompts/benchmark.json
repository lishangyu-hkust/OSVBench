[
    {
        "description": "\n[Functional Description]:\nThe `sys_map_page_desc` system call is designed to map a portion of the page descriptor table into a process's address space. This operation is crucial for processes that need to access or manage page descriptors directly, such as in advanced memory management tasks or when implementing custom paging mechanisms. By allowing a process to map page descriptors, the system call provides flexibility in how memory is managed and accessed within the operating system.\nThe system call begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing page descriptors. If the request number is too large, the system call returns an error, as it would attempt to map beyond the available descriptors. This check ensures that the mapping operation remains within the bounds of the page descriptor table, preventing access to invalid memory regions.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the page descriptor table in memory based on the number of pages requested. This calculation determines the specific memory region within the page descriptor table that will be mapped. Before proceeding with the mapping, the system call checks the specified permissions. If the permissions include write access, the operation is rejected. This restriction is crucial for maintaining the integrity of the page descriptor table, as allowing write access could lead to corruption or unauthorized modifications.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the page descriptors. It then performs a series of checks to ensure system consistency and security. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permissions do not include any unsafe bits by comparing them against the permission mask and ensures the page table entry is valid. If any of these checks fail, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the source page number, and verifies the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nFinally, the system updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nThe result of this operation is a mapped region in the process's address space that corresponds to a portion of the page descriptor table. This capability allows the process to access and manage page descriptors directly, enabling advanced memory management techniques and custom paging implementations. By integrating this functionality into the virtual memory system, the `sys_map_page_desc` system call enhances the flexibility and efficiency of memory management in the operating system.\nIn conclusion, the `sys_map_page_desc` system call provides a mechanism for mapping page descriptors into a process's address space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage page descriptors directly, which is particularly useful in advanced memory management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtual memory architecture.\n",
        "syscall": "sys_map_page_desc",
        "declaration": "int sys_map_page_desc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_page_desc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NPAGE * sizeof(struct page_desc)))\n        return -EINVAL;\n    pfn = (uintptr_t)page_desc_table / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_proc` system call provides a mechanism for mapping process descriptors into a process's page table. This operation is crucial for scenarios where processes need to share memory regions, such as in interprocess communication or shared memory applications. The system call ensures that the mapping is performed securely and adheres to the system's memory management policies.        \nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing processes. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system then calculates the physical frame number corresponding to the starting point of the process table based on the number of pages requested. This calculation determines the specific memory region within the process table that will be mapped.                Before proceeding with the mapping, the system call checks the specified permissions. If the permissions include write access, the operation is rejected. This restriction is crucial for maintaining the integrity of the process table, as allowing write access could lead to corruption or unauthorized modifications.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the processes.        \nIt then performs a series of checks to ensure system consistency and security. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system enforces strict validation of the permissions associated with the mapping. It checks that the requested permissions do not include any unsafe bits by comparing them against the permission mask and ensures the entry is valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the source page number, and verifies the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nThe result of this operation is a memory mapping that allows the target process to access the specified region of the process table. This capability is essential for enabling shared memory applications, where multiple processes need to access the same data concurrently. By providing a secure and efficient mechanism for memory mapping, the `sys_map_proc` system call enhances the flexibility and functionality of the system's memory management architecture.\nIn conclusion, the `sys_map_proc` system call provides a robust mechanism for mapping process memory into another process's address space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to share memory regions safely, supporting advanced memory management scenarios and enabling efficient interprocess communication.",
        "syscall": "sys_map_proc",
        "declaration": "int sys_map_proc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_proc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NPROC * sizeof(struct proc)))\n        return -EINVAL;\n    pfn = (uintptr_t)proc_table / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_dev` system call is designed to map a range of device memory into a process's address space, allowing the process to interact with hardware devices directly. This functionality is crucial in systems where processes need to access device registers or memory-mapped I/O regions, such as in device drivers or low-level system utilities.\nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing PCI devices. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the device table based on the number of pages requested. This calculation determines the specific memory region within the PCI device table that will be mapped.\nBefore proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the device memory, as allowing write permissions could lead to accidental or malicious corruption of the device's state. By enforcing read-only or execute-only permissions, the system maintains the stability and security of the device interaction.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the device. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_dev` system call provides a secure and efficient mechanism for mapping device memory into a process's address space through memory-mapped I/O. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage device memory directly, which is particularly useful in advanced device management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's device management architecture.\n",
        "syscall": "sys_map_dev",
        "declaration": "int sys_map_dev(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_dev(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NPCIDEV * sizeof(struct pci_dev)))\n        return -EINVAL;\n    pfn = (uintptr_t)devices / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_file` system call provides a mechanism for mapping a portion of the file table into a process's page table, allowing the process to access file metadata directly through its virtual memory space. This functionality is particularly useful in scenarios where processes need to interact with file descriptors or manage file-related operations efficiently. By mapping the file table into the process's address space, the system enables direct access to file information without additional system calls or context switches.\nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing files. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the file table in memory based on the number of pages requested. This calculation determines the specific memory region within the file table that will be mapped.\nBefore proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the file table, as allowing write permissions could lead to accidental or malicious modifications of file metadata.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the file table. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_file` system call provides a structured and secure mechanism for mapping the file table into a process's virtual memory space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage file metadata directly, which is particularly useful in advanced file management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's file management architecture.\n",
        "syscall": "sys_map_file",
        "declaration": "int sys_map_file(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_file(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NFILE * sizeof(struct file)))\n        return -EINVAL;\n    pfn = (uintptr_t)file_table / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pd` system call is responsible for allocating a new Page Directory (PD) entry within a process's hierarchical page table structure. This operation is crucial for managing virtual memory, allowing processes to expand their address space by adding new page directories. The system call ensures that the memory is correctly allocated and mapped, adhering to the specified permissions and maintaining the integrity of the page table hierarchy.\nThe operation begins by validating the target page designated for the page directory is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page directory entry. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. PDPT (Page Directory Pointer Table), to point to the newly allocated page directory page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nAfter successfully establishing the mapping, the system proceeds to allocate the PD (Page Directory) page. This involves marking the page as belonging to the process and designating it as a PD (Page Directory) type in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pd` system call provides a structured and secure mechanism for allocating and mapping PD pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pd",
        "declaration": "int sys_alloc_pd(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pd(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PDPT, PAGE_TYPE_X86_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* update the page table */\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pt` system call is designed to allocate a new Page Table (PT) entry within a process's page directory, facilitating the expansion or modification of the process's virtual memory space. This operation is crucial in virtual memory systems, where hierarchical page tables manage address mappings, allowing processes to dynamically allocate memory as needed.\nThe operation begins by validating the target page designated for the page table is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page table. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. page directory, to point to the newly allocated page table page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nOnce the mapping is successfully established, the system proceeds to allocate the PT (Page Table) page. This involves marking the page as belonging to the process and designating it as a PT (Page Table) type in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pt` system call provides a structured and secure mechanism for allocating and mapping PT pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pt",
        "declaration": "int sys_alloc_pt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PD, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nvoid (*hvm_invalidate_tlb)(pid_t pid);\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_frame` system call is designed to allocate a new memory frame and map it into a process's page table, facilitating dynamic memory management in virtual memory systems. This operation is crucial for processes that require additional memory resources, allowing them to expand their address space as needed. The system call ensures that the memory frame is correctly allocated and mapped with the specified permissions, maintaining the integrity and security of the system.\nThe operation begins by validating the target page designated for the frame is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new frame. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. page table, to point to the newly allocated frame. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also validates that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nOnce the mapping is successfully established, the system proceeds to allocate the memory frame. This involves marking the page as belonging to the process and designating it as a frame type in the page descriptor table. The memory associated with the frame is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_frame` system call provides a structured and secure mechanism for allocating and mapping memory frames in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_frame",
        "declaration": "int sys_alloc_frame(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_frame(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PT, PAGE_TYPE_FRAME);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_copy_frame` system call is designed to facilitate the copying of memory frames between processes, ensuring that data can be transferred securely and efficiently within the constraints of the system's memory management policies. This operation is particularly useful in scenarios where a process needs to share or duplicate data with another process, such as during inter-process communication or when setting up shared memory regions.\nThe system call begins by validating the source page is valid and of the frame type. It also validates that the source page belongs to the calling process. This ensures that the process has the right to access and copy the data from the specified frame. If the frame type or ownership is incorrect, the system call terminates with an error, preventing unauthorized access to memory.\nNext, the system call verifies the target process to ensure it is valid and exists within the system. This check prevents attempts to copy data to non-existent or invalid processes, which could lead to undefined behavior or system instability. The target page is also validated to ensure it is of the frame type and belongs to the target process. This ensures that the destination frame is correctly allocated and that the target process has the right to modify it.\nAdditionally, the system call enforces a permission check to ensure that the calling process is authorized to modify the target process's memory. This is restricted to either the current process itself or a child process in the embryo state. By enforcing this restriction, the system maintains process isolation and security, preventing arbitrary memory modifications across unrelated processes. Any violation of these conditions will result in the operation being terminated and an error being returned.\nOnce all validations are complete, the system call proceeds to copy the entire content of the source frame to the target frame, corresponding to the size of a memory page. The operation is performed atomically to ensure data consistency and integrity, preventing partial or corrupted transfers.\nThe result of the `sys_copy_frame` system call is a successful duplication of the memory frame from the source process to the target process, with all necessary permissions and validations enforced. This enables processes to share data efficiently while maintaining the security and stability of the system's memory management framework. By providing a controlled mechanism for frame copying, the system call supports advanced memory management scenarios, such as shared memory regions, data migration, and inter-process communication, enhancing the overall flexibility and functionality of the operating system.\n",
        "syscall": "sys_copy_frame",
        "declaration": "int sys_copy_frame(pn_t from, pid_t pid, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_copy_frame(pn_t from, pid_t pid, pn_t to)\n{\n    if (!is_page_type(from, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_page_type(to, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(to, pid))\n        return -EACCES;\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n\n    memcpy(get_page(to), get_page(from), PAGE_SIZE);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_protect_frame` system call is designed to modify the permissions of a specific frame in a process's page table, ensuring that the memory access rights are correctly configured according to the caller's requirements. This operation is crucial in managing memory protection in virtual memory systems, where controlling access to memory frames is essential for maintaining system security and stability.\nThe system call begins by validating the specified page is valid and of the page table type. It also validates the page belongs to the calling process. If these conditions are not met, the operation is terminated with an error to maintain memory integrity and security.\nNext, the system verifies the validity of the specified index within the page table. This check ensures that the index falls within acceptable limits, preventing out-of-bounds access that could lead to undefined behavior or security vulnerabilities.\nThe system verifies the type and ownership of the memory frame to ensure it is valid and belongs to the current process before modifying its permissions. It ensures that the frame is of the expected type and belongs to the current process. Any mismatch results in the operation being rejected with an error, safeguarding against unauthorized access or modification.\nThe system retrieves the page table entries and checks if the specified slot is valid and present. If the slot is empty, the operation is terminated with an error, as there is no existing mapping to modify.\nThe system further verifies that the existing page table entry corresponds to the specified frame by checking if the physical frame number derived from the page table entry matches the frame's expected physical address. If the check is not satisfied, the operation is terminated with an error, ensuring that the operation is being performed on the correct frame, preventing accidental modification of unrelated memory regions.\nThe system enforces strict validation of the new permissions to be applied to the frame. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of these conditions are not satisfied, the operation is terminated with an error, maintaining the security and stability of the memory system.\nFinally, the system updates the page table by configuring a page table entry to establish a mapping between a virtual memory address and a physical frame, while specifying the associated access permissions. This update is performed atomically to ensure consistency during the operation. After the modification, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This ensures that any stale or outdated address translations cached in the TLB are removed, forcing the processor to fetch updated mappings from the page tables and immediately reflect the new memory configuration.\nBy the end of the operation, the specified frame has its permissions updated according to the caller's request. This allows the process to control access to its memory frames, enabling features such as read-only or execute-only protection. The `sys_protect_frame` system call, therefore, is a critical component of memory management, allowing processes to dynamically adjust memory protection as needed. Its design ensures that memory is safely managed, preventing unauthorized access and maintaining the integrity of the system's memory architecture.\n",
        "syscall": "sys_protect_frame",
        "declaration": "int sys_protect_frame(pn_t pt, size_t index, pn_t frame, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_protect_frame(pn_t pt, size_t index, pn_t frame, pte_t perm)\n{\n    pte_t *entries;\n    pn_t pfn;\n\n    if (!is_page_type(pt, PAGE_TYPE_X86_PT))\n        return -EINVAL;\n    if (!is_page_pid(pt, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(frame, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(frame, current))\n        return -EACCES;\n\n    entries = get_page(pt);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    pfn = PTE_ADDR(entries[index]) >> PAGE_SHIFT;\n    if (pn_to_pfn(frame) != pfn)\n        return -EINVAL;\n\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    /* update the page table */\n    entries[index] = (pfn << PTE_PFN_SHIFT) | perm;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_pd` system call is designed to deallocate a Page Directory (PD) entry within a process's page table hierarchy, specifically targeting the release of a PD page and its reference in a Page Directory Pointer Table (PDPT). This operation is crucial for managing virtual memory dynamically, allowing processes to free up memory resources that are no longer needed, thus optimizing memory usage and maintaining system stability.\nThe system call begins by validating that the source page is valid and is of the correct type, a Page Directory Pointer Table type. It also validates that the source page belongs to the calling process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page directory pointer table. This check ensures that the operation targets a valid entry within the page directory pointer table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page is valid and is of the correct type, a Page Directory, and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page directory pointer table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page directory pointer table entry corresponds to the specified page directory by checking if the physical frame number derived from the page directory pointer table entry matches the page directory's expected physiscal address.  This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the page directory (PD) page. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page directory pointer table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PD from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PD is freed.\nBy the end of the operation, the specified PD page is fully deallocated, and its entry in the PDPT is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_pd` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pd",
        "declaration": "int sys_free_pd(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pd(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PDPT, PAGE_TYPE_X86_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_pt` system call is designed to deallocate a specific entry in a page table hierarchy by freeing a Page Table (PT) page and removing its reference from a higher-level Page Directory (PD). This operation is crucial for dynamic memory management in virtual memory systems, where hierarchical page tables manage address mappings. The system call ensures that the memory associated with a PT page is properly released and no longer accessible, while maintaining the integrity of the page table structure.\nThe system call begins by validating that the source page directory is valid and is of the correct type, a Page Directory type. It also validates that the source page directory belongs to the calling process. It ensures that the page directory corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page directory. This check ensures that the operation targets a valid entry within the directory, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page table is valid and is of the correct type, a Page Table. It ensures that the target page table corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page directory entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page directory entry corresponds to the specified page table by checking if the physical frame number derived from the page directory entry matches the page table's expected physiscal address. This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the page table (PT) page.  The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page directory entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PT from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PT is freed.\nBy the end of the operation, the specified PT page is fully deallocated, and its entry in the PD table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_pt` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pt",
        "declaration": "int sys_free_pt(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pt(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PD, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_frame` system call is designed to deallocate a specific frame of memory that is currently mapped in a process's page table. This operation is crucial for efficient memory management in operating systems, allowing processes to release memory resources that are no longer needed. By freeing up frames, the system can reclaim memory for other uses, preventing resource exhaustion and optimizing overall performance.\nThe system call begins by validating that the source page table entry is valid and is of the correct type, a Page Table type. It also validates that the source page table belongs to the calling process. It ensures that the page table corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page table. This check ensures that the operation targets a valid entry within the page table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target frame is valid and is of the correct type, a Frame. It ensures that the target frame corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page table entry corresponds to the specified frame by checking if the physical frame number derived from the page table entry matches the frame's expected physiscal address. This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the frame. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the frame from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the frame is freed.\nBy the end of the operation, the specified frame is fully deallocated, and its entry in the page table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_frame` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_frame",
        "declaration": "int sys_free_frame(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_frame(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PT, PAGE_TYPE_FRAME);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_page` system call is designed to reclaim memory pages that are no longer actively used by processes, specifically targeting pages owned by processes in a \"zombie\" state. This functionality is crucial for efficient memory management in operating systems, allowing the system to recover and reuse memory resources that are no longer needed by terminated processes.\nThe system call begins by validating the page identifier is valid and allocated. If the identifier is invalid or the page is already marked as free, the operation is terminated with an error, as there is no need to reclaim an already free or invalid page.\nOnce the memory page identifier is verified, the system checks the ownership of the page to ensure it belongs to a process that is in a zombie state and the validity of the owner process. A zombie process is one that has completed execution but still has an entry in the process table, typically waiting for its parent process to read its exit status. This restriction ensures that only pages from processes that are no longer active can be reclaimed, preventing accidental or unauthorized reclamation of pages still in use.\nThe system also checks if any devices are associated with the process that owns the page. If any devices are in use, the operation is rejected with an error. This restriction prevents the reclamation of pages that might still be required by active devices, ensuring system stability and preventing potential data loss or corruption.\nIf all conditions are met, the system proceeds to free the page. This involves resetting the owner process of the page, marking the page as a free type and updating the process's metadata to reflect the reduction in its memory usage. The freed page is then added back to the system's pool of available pages, making it available for allocation to other processes or system components.\nBy reclaiming pages from zombie processes, the `sys_reclaim_page` system call helps maintain optimal memory utilization in the system. It ensures that memory resources are not wasted on terminated processes, allowing the system to allocate memory more efficiently to active processes. This functionality is particularly important in environments with limited memory resources, where efficient memory management can significantly impact system performance and stability.\nIn summary, the `sys_reclaim_page` system call provides a mechanism for reclaiming memory pages from zombie processes, ensuring efficient memory utilization and preventing resource wastage. It validates inputs, checks process states, and safely reclaims pages, contributing to the overall robustness and efficiency of the operating system's memory management system.\n",
        "syscall": "sys_reclaim_page",
        "declaration": "int sys_reclaim_page(pn_t pn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_page(pn_t pn)\n{\n    struct page_desc *desc;\n\n    if (!is_pn_valid(pn))\n        return -EINVAL;\n    if (is_page_type(pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    desc = get_page_desc(pn);\n    /* can reclaim pages owned by a zombie */\n    if (!is_proc_state(desc->pid, PROC_ZOMBIE))\n        return -EACCES;\n    /* don't reclaim anything if any device is in use */\n    if (get_proc(desc->pid)->nr_devs)\n        return -EBUSY;\n\n    free_page(pn);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_set_runnable` system call is designed to transition a process from an initial state to a state where it is ready to be executed by the system scheduler. This operation is crucial for process management, allowing a parent process to prepare its child process for execution once it has been properly initialized and is ready to run.\nThe system call begins by verifying the validity of the specified process. This ensures that the operation targets a legitimate process within the system. If the identifier is invalid, the operation is halted, and an error is returned, as the transition cannot proceed without a valid target.\nOnce the process identifier is confirmed, the system then checks if the calling process is the parent of the target process. This restriction ensures that only the parent process, which is responsible for the creation and initial setup of the child process, can transition it to a runnable state. If the calling process is not the parent, the operation is rejected with an error, maintaining process hierarchy integrity.\nThe system also verifies that the target process is in its initial state, indicating that it is newly created and not yet ready for execution. This check ensures that only processes that have not yet been made runnable can be transitioned, preventing unintended state changes for processes that are already active or terminated. If the process is not in the initial state, the operation is terminated with an error.\nUpon successful validation, the system updates the process state to indicate that it is ready for execution. This state change signals to the system scheduler that the process can be considered for execution during scheduling decisions. The system then adds the process to the list of ready processes, ensuring that it is included in the pool of processes eligible for execution.\nIn conclusion, the `sys_set_runnable` system call is a vital mechanism for process management, enabling a controlled transition of processes from an initial state to a runnable state. By enforcing strict checks on process identifiers, parent-child relationships, and process states, the system ensures that only appropriate processes are transitioned, maintaining the integrity and stability of the process management system. This design allows for efficient and secure process scheduling, contributing to the overall robustness of the operating system.\n",
        "syscall": "sys_set_runnable",
        "declaration": "int sys_set_runnable(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_set_runnable(pid_t pid)\n{\n    struct proc *proc;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    /* only the parent process can make it ready */\n    if (proc->ppid != current)\n        return -EACCES;\n    /* can ready only an embryo process */\n    if (proc->state != PROC_EMBRYO)\n        return -EINVAL;\n\n    proc->state = PROC_RUNNABLE;\n    proc_ready_add(proc);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `switch_proc` system call is designed to facilitate the context switching between processes in a multitasking operating system. This operation is crucial for managing process execution, allowing the system to allocate CPU time to different processes based on their state and priority. By switching the currently running process to another that is ready to run, the system call ensures efficient CPU utilization and responsive system behavior.\nThe system call begins by verifying the validity of the target process identifier. If the identifier does not correspond to a valid process, the operation is halted with an error, as switching cannot proceed without a legitimate target. Following this, the system checks the state of the target process to ensure it is ready to run. If the process is not in a runnable state, the operation is terminated with an error, preventing the system from attempting to switch to a process that cannot execute.\nIf the target process is different from the currently executing process, the system prepares to switch contexts. It retrieves the descriptors for both the current and target processes, ensuring that the target process is indeed ready to run. The system then updates the state of the current process. If the current process is actively running, it is transitioned to a runnable state unless it has been marked for termination, in which case it is moved to a terminated state indicating that it has completed execution but has not yet been fully cleaned up and removed from the ready queue.\nThe target process is then set to a running state, and the system updates its internal record to reflect the new current process. This change in state ensures that the CPU will execute the target process upon resuming operations.\nThe system call concludes by preparing to invoke a mechanism that will execute the newly designated current process. This ensures that the system's execution context is correctly aligned with the updated process state, allowing the target process to run seamlessly.\nIn summary, the `switch_proc` system call is a critical component of process management, enabling the operating system to efficiently allocate CPU resources among multiple processes. By validating process states, managing transitions, and updating execution contexts, this system call ensures smooth and effective multitasking within the system.\n",
        "syscall": "switch_proc",
        "declaration": "int sys_switch(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint switch_proc(pid_t pid)\n{\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_RUNNABLE))\n        return -EINVAL;\n\n    if (current != pid) {\n        struct proc *old, *new;\n\n        old = get_proc(current);\n        new = get_proc(pid);\n        assert(new->state == PROC_RUNNABLE, \"new proc must be runnable\");\n\n        if (old->state == PROC_RUNNING) {\n            if (old->killed) {\n                old->state = PROC_ZOMBIE;\n                proc_ready_del(old);\n            } else {\n                old->state = PROC_RUNNABLE;\n            }\n        }\n        new->state = PROC_RUNNING;\n        current = pid;\n    }\n\n    /* will call run_current() upon return */\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_kill` system call is designed to terminate a process by marking it as killed, which will eventually lead to its transition to a zombie state. This system call is a fundamental part of process management, allowing the operating system or other processes to terminate processes that are no longer needed or are behaving incorrectly. The operation ensures that the process is marked for termination and will be cleaned up appropriately during the next scheduling cycle.\nThe system call begins by validating the identifier of the target process to ensure it corresponds to a valid and existing process. If the identifier is invalid, the operation is terminated with an error, as the termination cannot proceed without a valid target.\nOnce the identifier is verified, the system checks the current state of the process. The operation is only allowed if the process is in a state where it can be terminated, such as being active or in the process of starting. If the process is in a state where termination is not applicable, such as being unused or already terminated, the operation is rejected with an error. This ensures that resources are not wasted on processes that do not require termination.\nAfter confirming the process's eligibility for termination, the system marks the process for termination by setting a specific flag. This flag indicates that the process should be terminated at the next opportunity, such as during a context switch or timer event. This approach allows the system to handle termination in a controlled manner, ensuring that resources are released appropriately and that the process does not continue executing.\nIf the process is not currently executing, the system immediately transitions it to a terminated state and removes it from the list of active processes. This ensures that the process is no longer scheduled for execution and that its resources can be reclaimed by the system. By handling non-executing processes immediately, the system maintains efficiency and prevents unnecessary resource usage.\nIn conclusion, the `sys_kill` system call provides a mechanism for terminating processes in a controlled and efficient manner. It validates inputs, checks process states, and marks processes for termination, ensuring that resources are managed effectively and that processes can be stopped when necessary. This functionality is essential for maintaining system stability and managing process lifecycles in a multitasking environment.\n",
        "syscall": "sys_kill",
        "declaration": "int sys_kill(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_kill(pid_t pid)\n{\n    struct proc *proc;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* can kill an embryo/runnable/running, not unused or zombie */\n    if (is_proc_state(pid, PROC_UNUSED) || is_proc_state(pid, PROC_ZOMBIE))\n        return -EINVAL;\n\n    proc = get_proc(pid);\n    proc->killed = 1;\n\n    if (!is_proc_state(pid, PROC_RUNNING)) {\n        proc->state = PROC_ZOMBIE;\n        proc_ready_del(proc);\n    }\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reap` system call is designed to allow a parent process to clean up and reclaim resources from a terminated child process. This operation is crucial in process management, ensuring that system resources are efficiently recycled and preventing resource leaks.\nThe system call begins by verifying the validity of the provided process identifier. If the identifier does not correspond to a valid process, the operation is halted with an error, as it cannot proceed without a legitimate target.\nOnce the process identifier is confirmed, the system then checks if the calling process is the parent of the target process and the target process is in a terminated state. If any of the conditions are not met, the operation is rejected with an error, as only an active parent process is authorized to perform the cleanup.\nThe system then performs a series of checks to ensure that the target process has released all its resources. These checks include verifying that the process has no active devices, child processes, file descriptors, memory pages, DMA pages, I/O ports, interrupt vectors, or interrupt remapping entries. If any resources are still in use, the operation is halted with an error, preventing premature cleanup and ensuring system stability.\nOnce all conditions are satisfied, the system proceeds to free the resources associated with the target process. This involves updating the metadata of the process's parent process to reflect the decrease of its active child processes. Since the process is no longer active, its attributes are reset, including its pareent process, page table root, stack, hardware virtual machine, launch status, termination flag, I/O bitmap use flag, first I/O bitmap section, and second I/O bitmap section. The system marks the process as a unused state.\nIn conclusion, the `sys_reap` system call is a critical component of process management, enabling efficient resource reclamation and preventing resource leaks. By enforcing strict checks on process state and resource usage, the system ensures that cleanup operations are performed safely and effectively, contributing to the overall robustness and efficiency of the operating system.\n",
        "syscall": "sys_reap",
        "declaration": "int sys_reap(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reap(pid_t pid)\n{\n    struct proc *proc;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    /* only the parent process can reap */\n    if (proc->ppid != current)\n        return -EACCES;\n    /* must be a zombie */\n    if (proc->state != PROC_ZOMBIE)\n        return -EINVAL;\n    if (proc->nr_devs)\n        return -ETXTBSY;\n    if (proc->nr_children)\n        return -ETXTBSY;\n    if (proc->nr_fds)\n        return -ETXTBSY;\n    if (proc->nr_pages)\n        return -ETXTBSY;\n    if (proc->nr_dmapages)\n        return -ETXTBSY;\n    if (proc->nr_ports)\n        return -ETXTBSY;\n    if (proc->nr_vectors)\n        return -ETXTBSY;\n    if (proc->nr_intremaps)\n        return -ETXTBSY;\n\n    free_proc(pid);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic void free_proc(pid_t pid)\n{\n    struct proc *proc;\n\n    proc = get_proc(pid);\n    /* init cannot be freed, so ppid should be non-zero */\n    --get_proc(proc->ppid)->nr_children;\n\n    proc->state = PROC_UNUSED;\n    proc->ppid = 0;\n    proc->page_table_root = 0;\n    proc->stack = 0;\n    proc->hvm = 0;\n    proc->launched = 0;\n    proc->killed = 0;\n    proc->use_io_bitmap = 0;\n    proc->io_bitmap_a = 0;\n    proc->io_bitmap_b = 0;\n    proc->name[0] = 0;\n    proc->name[1] = 0;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reparent` system call is designed to reassign the parent process of a specified process to a predefined system process, typically the initial system process. This operation is crucial in process management, particularly when the original parent process has terminated, ensuring that orphaned processes are properly managed and do not remain without a parent.\nThe system call begins by validating the identifier of the specified process to ensure it corresponds to an existing and valid process. If the identifier is invalid, the operation is halted with an error, as the reassignment cannot proceed without a valid target.\nOnce the identifier is confirmed, the system checks the state of the current parent process to ensure it is in a terminated state. This check is crucial, as the reassignment is only necessary if the parent process is no longer active.\nAdditionally, the system verifies the state of the predefined initial system process to ensure it is capable of accepting new child processes. This step ensures that the system process is in a runnable or running state to assume the role of the parent, maintaining system stability and process hierarchy integrity.\nUpon successful validation, the system updates the parent process of the target process to the system predefined initial process. Accordingly, it updates the metadata of the initial process to reflect the increase of its child processces. It also updates the metadata of the original parent process of the target process to reflect the decrease of its child processes. This adjustment reflects the change in the process hierarchy and ensures accurate tracking of process relationships. By completing this process, the system ensures that the specified process is no longer orphaned and is properly integrated into the process hierarchy under the management of the predefined system process.\nIn conclusion, the `sys_reparent` system call is a vital mechanism for maintaining process hierarchy integrity and ensuring that orphaned processes are appropriately managed. By validating inputs, enforcing state checks, and updating process relationships securely and efficiently, the system call contributes to the overall robustness and reliability of the system's process management architecture.\n",
        "syscall": "sys_reparent",
        "declaration": "int sys_reparent(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reparent(pid_t pid)\n{\n    struct proc *proc;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    /* the parent process must be zombie */\n    if (!is_proc_state(proc->ppid, PROC_ZOMBIE))\n        return -EINVAL;\n    /* not sure if we need this */\n    if (!is_proc_state(INITPID, PROC_RUNNABLE) && !is_proc_state(INITPID, PROC_RUNNING))\n        return -EINVAL;\n\n    ++get_proc(INITPID)->nr_children;\n    --get_proc(proc->ppid)->nr_children;\n    proc->ppid = INITPID;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `recv_proc` system call facilitates inter-process communication by allowing a process to receive data from another process. This operation is crucial in systems where processes need to exchange information or synchronize their activities. The system call ensures that the receiving process is in a suitable state to accept data and that the memory and file descriptors involved are valid and properly configured.\nThe system call begins by verifying the identity of the target process to ensure it is valid and in a runnable state that allows it to receive data. If the process identifier is not valid or the process is not in the correct state, the operation is terminated with an error. This ensures that only active and ready processes can participate in data exchange.\nNext, the system validates the memory location where the data will be received. It checks that the memory is owned by the current process and is of the frame type to hold the incoming data. If these conditions are not met, the operation is rejected with an error. This validation step prevents unauthorized access to memory and ensures data integrity.\nThe system also examines the file descriptor associated with the operation. If a file descriptor is provided, it is checked for validity to ensure it is not already associated with an existing resource. If the file descriptor is associated with an existing resource, the operation is rejected with an error.\nOnce all validations are complete, the system prepares the current process as the receiving process for data transfer. It updates the process's internal state to reflect the incoming data, including the memory page and the file descriptor, and marks it as ready to receive. The receiver process is then transitioned to a waiting state, allowing the sending process to proceed with the data transfer. This state transition is crucial for synchronizing the activities of the involved processes.\nFinally, the system updates the scheduling information to reflect the new state of the processes. The receiving process is removed from the ready queue, and the sending process is marked as active and current. And then the current process is switched to the sending process. This ensures that the system's scheduler can efficiently manage process execution and resource allocation.\nIn summary, the `recv_proc` system call is a vital component for enabling inter-process communication. It performs rigorous checks to validate process states, memory locations, and file descriptors, ensuring secure and efficient data exchange. By managing process states and scheduling, the system call contributes to the overall stability and performance of the system's process management architecture.\n",
        "syscall": "recv_proc",
        "declaration": "int sys_recv(pid_t pid, pn_t pn, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint recv_proc(pid_t pid, pn_t pn, int fd)\n{\n    struct proc *server;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_RUNNABLE))\n        return -EINVAL;\n    if (!is_pn_valid(pn))\n        return -EINVAL;\n    if (!is_page_pid(pn, current))\n        return -EACCES;\n    if (!is_page_type(pn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (is_fd_valid(fd)) {\n        if (is_fn_valid(get_fd(current, fd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is runnable\");\n    server = get_proc(current);\n    server->ipc_from = 0;\n    server->ipc_page = pn;\n    server->ipc_size = 0;\n    server->ipc_fd = fd;\n\n    server->state = PROC_SLEEPING;\n    /* server: running -> sleeping */\n    proc_ready_del(server);\n    get_proc(pid)->state = PROC_RUNNING;\n    current = pid;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `call_proc` system call facilitates interprocess communication by allowing a process to send data to another process and then transfer control to the receiving process. This mechanism is essential for scenarios where a client process needs to invoke a service or function provided by a server process, enabling efficient and synchronized communication between processes.\nThe system call begins by verifying the validity of the target process and ensuring it is in the sleeping state, indicating readiness to receive data. If the target process is not valid or is actively running, the system call terminates with an error.\nNext, the system validates the validity of the input page and the output page. It also validates taht the input and output pages belong to the calling process. The type of the output page should be the correct frame page and the size of the data must not exceed the limits of a memory page. Any violations to these constriants will make the operation to terminate with an error.\nThe system then validates that the input file descriptor is either invalid or non-empty and the output file descriptor is either invalid or empty. The input file descriptor is set to be invalid to indicate no input file descriptor in this operation. If these conditions are not met, the operation is rejected with an error. These checks ensure that communication adheres to system constraints and prevents unauthorized access.\nThe system then sets up the communication. It sets the current process as the sender process and the target process as the receiver process. It then validates the receiver process wants to accept the other process' requests. If the condition is not met, the operation is rejected with an error. The sender process then prepares to send its request by specifying the data to be transferred and optional resources such as file descriptors. The receiver process prepares to receive this data by specifying the source process that the data is from and the specific control value. The system then securely transfers the page of data from the input page to the designated page of the receiver process and updates the transferred size for the receiver process. If the input file descriptor and the file descriptor of the receiver process are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nAfter the data and resources are transferred, the system transitions control between the two processes. The sender process is placed into a sleeping state, indicating that it is waiting for the receiver to complete its task. At the same time, the receiver process is transitioned to a running state, allowing it to process the request immediately. This context switch ensures that the receiver begins handling the request without delay while the sender remains blocked until the receiver completes its task. The state transition is carefully managed to maintain system stability and prevent race conditions or deadlocks.\nFinally, the system resets the IPC state of the current process and then switches the current process context to the specified process.\nBy the end of the operation, the receiver process is actively running and processing the request, while the sender process is waiting for the receiver to finish. This design enables efficient and synchronized communication between processes, allowing them to interact seamlessly while maintaining strict isolation and synchronization.\nIn summary, the `call_proc` system call enables interprocess communication by transferring data and control between processes. It validates inputs, securely transfers data, and manages process states to ensure efficient and synchronized communication. This functionality is critical for enabling processes to interact in a controlled and coordinated manner, making it a key component of interprocess communication in operating systems.\n",
        "syscall": "call_proc",
        "declaration": "int sys_call(pid_t pid, uint64_t val, pn_t inpn, size_t size, pn_t outpn, int outfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint call_proc(pid_t pid, uint64_t val, pn_t inpn, size_t size, pn_t outpn, int outfd)\n{\n    int r;\n\n    r = send_recv(pid, val, inpn, size, -1, outpn, outfd);\n    if (r)\n        return r;\n    /* accept any ipc */\n    get_proc(current)->ipc_from = pid;\n    current = pid;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPROC 64    /* maximum number of processes */\n\nstatic int send_recv(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn,\n                     int outfd)\n{\n    struct proc *sender, *receiver;\n\n    /* target process must be sleeping */\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    /* check in page */\n    if (!is_pn_valid(inpn))\n        return -EINVAL;\n    /* inpn doesn't have to be a frame */\n    if (!is_page_pid(inpn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    /* check in fd: either invalid or non-empty */\n    if (is_fd_valid(infd)) {\n        if (!is_fn_valid(get_fd(current, infd)))\n            return -EINVAL;\n    }\n    /* check out page */\n    if (!is_pn_valid(outpn))\n        return -EINVAL;\n    if (!is_page_pid(outpn, current))\n        return -EACCES;\n    if (!is_page_type(outpn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    /* check out fd: either invalid or empty */\n    if (is_fd_valid(outfd)) {\n        if (is_fn_valid(get_fd(current, outfd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    /* check if the receiver wants to accept anyone's request */\n    if (receiver->ipc_from && receiver->ipc_from != current)\n        return -EACCES;\n\n    /* client: prepare for response */\n    sender->ipc_page = outpn;\n    sender->ipc_fd = outfd;\n\n    /* server: transfer data from client */\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    /* transfer the page */\n    memcpy(get_page(receiver->ipc_page), get_page(inpn), size);\n    receiver->ipc_size = size;\n    /* transfer the fd */\n    if (is_fd_valid(infd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, infd));\n\n    /* switch control */\n\n    sender->state = PROC_SLEEPING;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    /* sender: running -> sleeping */\n    proc_ready_del(sender);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_create` system call is responsible for creating a new file descriptor entry in the file descriptor table of the current process. This operation is essential for managing access to files, devices, or other I/O resources within an operating system. By establishing a new file descriptor, the system call enables processes to interact with these resources in a controlled and organized manner.\nThe system call begins by validating the type of the resource to be associated with the file descriptor. If the type is invalid, the operation is terminated with an error, as a valid type is necessary for the creation process. The system then checks the validity of the file descriptor to ensure it falls within acceptable limits. If the file descriptor is not valid, the operation is rejected with an error, preventing any invalid or out-of-bounds access.\nOnce the file descriptor is verified, the system checks if it is currently unused by the calling process. If the file descriptor is already in use, the operation is terminated with an error, as it cannot be overwritten without proper closure or release. The system then validates the identifier for the file or resource to ensure it is within acceptable limits. If the identifier is not valid, the operation is rejected with an error, ensuring that only valid resources are associated with file descriptors.\nThe system retrieves the file or resource associated with the identifier and checks its reference count to ensure it is unused. If the resource is already in use, the operation is terminated with an error, preventing any conflicts or resource contention. Once all validations are satisfied, the system initializes the file or resource with the specified attributes, including its type, value, and mode of operation. The reference count and the offset are both initialized to the start value.\nFinally, the system associates the file descriptor with the file or resource by updating the process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. The operation concludes successfully, allowing the process to interact with the newly created file descriptor.\nIn summary, the `sys_create` system call is a critical component for managing file descriptors within a process. It ensures that all inputs are validated, resources are properly initialized, and associations are securely established. This design contributes to the overall stability and functionality of the system's file management architecture, enabling processes to efficiently manage their file interactions.\n",
        "syscall": "sys_create",
        "declaration": "int sys_create(int fd, fn_t fn, uint64_t type, uint64_t value, uint64_t mode);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_create(int fd, fn_t fn, uint64_t type, uint64_t value, uint64_t omode)\n{\n    struct file *file;\n\n    if (type == FD_NONE)\n        return -EINVAL;\n    if (!is_fd_valid(fd))\n        return -EBADF;\n    /* fd must be empty */\n    if (get_fd(current, fd) != 0)\n        return -EINVAL;\n    if (!is_fn_valid(fn))\n        return -EINVAL;\n    /* fn must be unused */\n    file = get_file(fn);\n    if (file->refcnt != 0)\n        return -EINVAL;\n\n    file->type = type;\n    file->value = value;\n    file->omode = omode;\n    file->refcnt = 0;\n    file->offset = 0;\n    set_fd(current, fd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_close` system call is responsible for closing a file descriptor associated with a specific process, thereby releasing the resources tied to that descriptor. This operation is fundamental in resource management within operating systems, ensuring that file descriptors are properly deallocated when they are no longer needed, preventing resource leaks and maintaining system stability.\nThe system call begins by validating the process identifier to ensure it corresponds to a valid process. If the process identifier is invalid, the operation is terminated with an error, as the closure cannot proceed without a valid target. Similarly, the system checks the validity of the file descriptor. If the file descriptor is invalid, the operation is terminated with an error, preventing any attempt to close a non-existent or out-of-bounds descriptor.\nOnce both the process identifier and file descriptor are verified, the system performs a permission check to ensure that the operation is allowed. The system permits the closure if the process is the current one or if it is in a terminated state. This restriction ensures that only authorized processes can close their file descriptors, maintaining system integrity and preventing unauthorized access.\nThe system then checks if the file descriptor is currently in use by the process. If the file descriptor is not associated with any open file, the operation is terminated with an error, as there is nothing to close. This check prevents unnecessary operations and ensures that only active file descriptors are targeted.\nIf all checks are satisfied, the system proceeds to clear the file descriptor, effectively closing it. This involves updating the process's file descriptor table to mark the descriptor as unused and decrementing the count of open file descriptors for the process. Additionally, the system updates the file's reference count to reflect the decrease of the file references. And if the file is no longer referenced by any process, it resets the file's attributes, including its type, value, offset, and mode of operation, releasing the associated resources.\nIn summary, the `sys_close` system call is an essential mechanism for managing file descriptors within a process or across processes. It ensures that all inputs are validated, permissions are enforced, and resources are securely released when a file descriptor is no longer needed. By allowing proper cleanup of file descriptors, the system call contributes to the stability and efficiency of the system's resource management, preventing resource leaks and ensuring orderly file descriptor handling.\n",
        "syscall": "sys_close",
        "declaration": "int sys_close(pid_t pid, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_close(pid_t pid, int fd)\n{\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_fd_valid(fd))\n        return -EBADF;\n    /* permission check: current or a dead pid */\n    if (pid != current && !is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_fd(pid, fd) == 0)\n        return -EBADF;\n    clear_fd(pid, fd);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void clear_fd(pid_t pid, int fd)\n{\n    struct proc *proc;\n    struct file *file;\n\n    proc = get_proc(pid);\n    file = get_file(get_fd(pid, fd));\n    proc->ofile[fd] = 0;\n    --proc->nr_fds;\n    if (--file->refcnt == 0) {\n        file->type = FD_NONE;\n        file->value = 0;\n        file->offset = 0;\n        file->omode = 0;\n    }\n}\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_dup` system call provides a mechanism for duplicating a file descriptor from one process to another. This operation is essential in scenarios where a process needs to share or transfer access to a file or resource with another process. By duplicating a file descriptor, the system allows multiple processes to interact with the same underlying resource, facilitating inter-process communication and resource sharing.\nThe system call begins by validating the target process identifier to ensure it corresponds to a valid and active process. If the process identifier is invalid, the operation is terminated with an error, as the duplication cannot proceed without a valid target. Additionally, the system checks that the target process is either the current process or its embryo, ensuring that the operation respects process boundaries and permissions.\nNext, the system verifies the validity of the source file descriptor within the current process. It also validates the source file descriptor exists in the calling process. If the source file descriptor is invalid or does not exist in the calling process, the operation is rejected with an error. This check ensures that the duplication operation is based on a valid and accessible resource. \nThe system then validates the target file descriptor within the target process. It also validates the target file descriptor does not exist in the target process. If the target file descriptor is invalid or exists in the target process, the operation is terminated with an error. This step prevents accidental overwriting of existing file descriptors, maintaining the integrity of the target process's file descriptor table.\nOnce all validations are satisfied, the system proceeds to duplicate the source file descriptor. The system associates the file descriptor with the file or resource by updating the target process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. This assignment is performed atomically to ensure consistency and correctness during the operation.\nIn conclusion, the `sys_dup` system call is a vital feature for enabling file descriptor duplication across processes. It carefully validates inputs, enforces strict permissions, and ensures that the duplication is performed securely and efficiently. By providing this capability, the system call enhances the system's flexibility and robustness in managing shared resources and inter-process communication.\n",
        "syscall": "sys_dup",
        "declaration": "int sys_dup(int oldfd, pid_t pid, int newfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_dup(int oldfd, pid_t pid, int newfd)\n{\n    fn_t fn;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    /* oldfd doesn't exist  */\n    if (!is_fd_valid(oldfd))\n        return -EBADF;\n    fn = get_fd(current, oldfd);\n    if (fn == 0)\n        return -EBADF;\n    if (!is_fd_valid(newfd))\n        return -EBADF;\n    /* newfd already exists */\n    if (get_fd(pid, newfd) != 0)\n        return -EINVAL;\n\n    set_fd(pid, newfd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define NOFILE 16   /* open files per process */\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_lseek` system call provides a mechanism for adjusting the position within a file for subsequent read or write operations. This operation is essential in file management, allowing processes to navigate through file contents efficiently without reading or writing data sequentially. By setting the file position to a specified location, processes can directly access desired portions of a file, enhancing performance and flexibility in file handling.\nThe system call begins by validating the validity of the specified file descriptor. If it is invalid, the operation is rejected with an error, preventing any further operations on an undefined or closed file. The system then retrieves the corresponding file number and validates its validity. It also ensures the file is an inode-based file, which supports seeking operations. If the conditions are not met, the operation is rejected with an error, preventing the system call from being applied to file types that do not support offset manipulation, such as sockets or pipes, which would result in undefined behavior. The system then verifies the validity of the specified offset, ensuring the correctness of the offset to be update.\nThe system then updates the file's position to the specified location. This update is performed atomically to ensure consistency during the operation. By adjusting the file position, the system enables subsequent read or write operations to occur at the new location, allowing processes to efficiently access and modify file contents as needed.\nIn conclusion, the `sys_lseek` system call is a crucial feature for enabling flexible file navigation in processes. It carefully validates inputs, enforces type restrictions, and ensures that the position adjustment is performed securely and efficiently. This design allows processes to manage file access dynamically, contributing to the overall robustness and flexibility of the system's file management architecture.\n",
        "syscall": "sys_lseek",
        "declaration": "int sys_lseek(int fd, off_t offset);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_lseek(int fd, off_t offset)\n{\n    fn_t fn;\n    struct file *file;\n\n    if (!is_fd_valid(fd))\n        return -EBADF;\n    fn = get_fd(current, fd);\n    if (!is_file_type(fn, FD_INODE))\n        return -EINVAL;\n    if (offset < 0)\n        return -EINVAL;\n    file = get_file(fn);\n\n    file->offset = offset;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_file_type(fn_t fn, enum file_type type)\n{\n    return is_fn_valid(fn) && get_file(fn)->type == type;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_pcipage` system call is designed to facilitate the mapping of PCI device memory into a process's address space. This operation is crucial in systems where processes need direct access to hardware resources, such as device drivers that interact with PCI devices. By mapping PCI pages into the process's page table, the system call enables efficient and controlled access to device memory, ensuring that processes can perform necessary I/O operations without compromising system stability or security.\nThe system call begins by verifying the validity of the specified pci page. If the pci page is not valid, the operation is terminated with an error, as the mapping cannot proceed without a valid target. Additionally, the system call checks that the current process owns the specified PCI page. If the process does not own the page, the operation is rejected with an error. This ownership check is crucial for maintaining process isolation and ensuring that only authorized processes can map and access specific hardware resources.\nOnce the validations are complete, the system call calculates the physical frame number (PFN) for the PCI page. The PFN is derived from the base address of the PCI memory region and the pci page number, providing the exact physical location of the PCI page in memory. This calculation is essential for correctly updating the process's page table with the appropriate physical address.\nThe system then establishes the mapping by updating the process's page table entry at the specified index to point to the PCI page's PFN, with the permissions specified by the caller. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page table, and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the sys_map_pcipage system call is a vital feature for enabling direct access to device memory in process page tables. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to interact with hardware components directly, which is particularly useful in scenarios requiring high-performance device communication. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's memory management architecture.\n",
        "syscall": "sys_map_pcipage",
        "declaration": "int sys_map_pcipage(pn_t pt, size_t index, pn_t pcipn, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_pcipage(pn_t pt, size_t index, pn_t pcipn, pte_t perm)\n{\n    pid_t pid = current;\n    pn_t pfn;\n\n    /* check if pcipn is valid in pci pages */\n    if (!is_pcipn_valid(pcipn))\n        return -EINVAL;\n    /* check if current owns the pcipage */\n    if (!is_pcipn_pid(pcipn, pid))\n        return -EACCES;\n\n    pfn = PCI_START / PAGE_SIZE + pcipn;\n    return map_page(pid, pt, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n#define NPAGE 8192  /* maximum number of pages */\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nextern struct proc proc_table[NPROC];\n\n/* pci hole pages: pfn -> devid */\nstruct pcipage_desc {\n    devid_t devid;\n    bool valid;\n};\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define PCI_START               UINT64_C(0xa0000000)\n#define PCI_END                 UINT64_C(0x100000000)\n#define NPCIPAGE ((PCI_END - PCI_START) / PAGE_SIZE)\n\nstatic struct pcipage_desc pcipages[NPCIPAGE];\n\nstatic int is_pcipn_valid(pn_t pcipn)\n{\n    return pcipn < NPCIPAGE && pcipages[pcipn].valid;\n}\n\nstatic int is_pcipn_pid(pn_t pcipn, pid_t pid)\n{\n    return is_pcipn_valid(pcipn) && pcipn_to_pid(pcipn) == pid;\n}\n\n#define SZ_64K UINT64_C(0x00010000)\nstatic pid_t pci_table[SZ_64K];\n\nstatic pid_t pcipn_to_pid(pn_t pcipn)\n{\n    assert(is_pcipn_valid(pcipn), \"pcipn must be valid\");\n    return pci_table[pcipages[pcipn].devid];\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define PTE_PFN_SHIFT 12\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_root` system call is designed to allocate a root entry for an IOMMU (Input-Output Memory Management Unit) page table, which is essential for managing device memory access in virtualized environments. This system call ensures that a device is correctly associated with a process and that its memory access is controlled through a dedicated page table, enhancing security and isolation in systems with multiple devices.\nThe operation begins by checking if the specified device identifier is already associated with a process in the PCI table. If the device is already in use, the system call returns an error, preventing multiple processes from controlling the same device simultaneously. This check ensures exclusive access to the device, which is crucial for maintaining system stability and preventing conflicts.\nNext, the system verifies that the specified memory location represented by the page number is valid and available for allocation. If the memory is not free, the operation is rejected with an error. This validation ensures that the page can be safely used to store the IOMMU page table root without overwriting existing data.\nOnce the initial checks are passed, the system associates the device with the current process. This association is crucial for tracking which process is responsible for managing the device's memory. The system then allocates the memory for the root table, marking it as used and updating the type of the page to the specified IOMMU PML4 table type. The allocation process also updates the process's metadata to reflect the increase in its memory usage. This step ensures that the process's resource usage is accurately tracked, preventing resource leaks and ensuring fair resource distribution. The process's metadata is also updated to reflect the addition of a new device, maintaining accurate records of the resources allocated to the process.    The system then configures the IOMMU device to use the newly allocated root table. This configuration step is essential for enabling the device to access memory through the IOMMU, ensuring that memory accesses are properly translated and protected. Finally, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors.\nIn conclusion, the `sys_alloc_iommu_root` system call is a critical component for managing IOMMU devices. It carefully checks for existing configurations, validates memory availability, and ensures that the device is correctly configured to use the allocated root table. By providing this functionality, the system call enhances the system's ability to manage device memory safely and efficiently, contributing to the overall robustness of the system's memory management architecture.\n",
        "syscall": "sys_alloc_iommu_root",
        "declaration": "int sys_alloc_iommu_root(devid_t devid, pn_t pn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_root(devid_t devid, pn_t pn)\n{\n    if (pci_table[devid])\n        return -EBUSY;\n    if (!is_page_type(pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n\n    pci_table[devid] = current;\n    alloc_page(current, PAGE_TYPE_IOMMU_PML4, pn);\n    ++get_proc(current)->nr_devs;\n\n    iommu_set_dev_root(devid, (uintptr_t)get_page(pn));\n    iommu_flush();\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define SZ_64K UINT64_C(0x00010000)\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pdpt` system call is designed to allocate and map a Page Directory Pointer Table (PDPT) entry in the IOMMU (Input-Output Memory Management Unit) page table hierarchy. This operation is crucial for managing device memory access in virtualized environments, where the IOMMU provides address translation and protection for device-initiated memory accesses. The system call ensures that the IOMMU page tables are correctly configured to allow or restrict device access to specific memory regions.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, the root level of the page table hierarchy of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page directory pointer table (PDPT) page. This involves marking the page as belonging to the calling process and designating it as a PDPT page in the page descriptor table. The memory associated with the PDPT page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.   the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors.  \nBy the end of the operation, the IOMMU PDPT page is allocated and mapped, allowing devices to access the specified memory region according to the defined permissions. This setup is essential for enabling secure and efficient device memory access in virtualized systems, where the IOMMU plays a critical role in isolating device memory accesses and preventing unauthorized access.\nIn summary, the `sys_alloc_iommu_pdpt` system call provides a robust mechanism for managing IOMMU page tables, ensuring that device memory accesses are controlled and secure. By validating inputs, configuring mappings, and handling platform-specific adjustments, the system call supports the complex requirements of virtualized environments, enhancing the system's ability to manage device memory access effectively.\n",
        "syscall": "sys_alloc_iommu_pdpt",
        "declaration": "int sys_alloc_iommu_pdpt(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pdpt(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    int r;\n    extern void iommu_hack_root(physaddr_t addr4, physaddr_t addr3);\n\n    r = alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PML4,\n                                    PAGE_TYPE_IOMMU_PDPT);\n    /* hack for qemu (3-level) */\n    if (r == 0 && index == 0)\n        iommu_hack_root((uintptr_t)get_page(from), (uintptr_t)get_page(to));\n    return r;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                        enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                        enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pd` system call is designed to allocate a new page directory (PD) entry in an IOMMU (Input-Output Memory Management Unit) page table hierarchy. This operation is crucial for managing device memory access in virtualized environments, where devices require controlled access to memory regions. The system call ensures that the memory is correctly mapped and accessible with specified permissions, supporting efficient and secure device memory management.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page directory pointer table of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page directory (PD) page. This involves marking the page as belonging to the calling process and designating it as a PD page in the page descriptor table. The memory associated with the PD page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_iommu_pd` system call provides a structured and secure mechanism for allocating and mapping PD pages in an IOMMU page table hierarchy. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling devices to manage their memory access flexibly, which is a cornerstone of modern virtualized system design.\n",
        "syscall": "sys_alloc_iommu_pd",
        "declaration": "int sys_alloc_iommu_pd(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pd(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    return alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PDPT,\n                                       PAGE_TYPE_IOMMU_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                       enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pt` system call is designed to allocate and map a new page table entry within an IOMMU (Input-Output Memory Management Unit) page table. This operation is crucial for managing device memory access in virtualized environments, where the IOMMU provides isolation and protection by translating device-generated addresses to physical addresses. The system call ensures that the IOMMU page table is correctly configured, allowing devices to access memory securely and efficiently.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page directory of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page table (PT) page. This involves marking the page as belonging to the calling process and designating it as a PT page in the page descriptor table. The memory associated with the PT page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_iommu_pt` system call provides a secure and efficient mechanism for allocating and mapping IOMMU page table entries. By validating inputs, enforcing permissions, and maintaining the integrity of the IOMMU hierarchy, the system call ensures that device memory access is managed safely and effectively. This functionality is essential for supporting virtualization and device isolation, enabling devices to interact with memory in a controlled and predictable manner.\n",
        "syscall": "sys_alloc_iommu_pt",
        "declaration": "int sys_alloc_iommu_pt(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pt(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    return alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PD,\n                                       PAGE_TYPE_IOMMU_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                       enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_frame` system call is used to allocate and map a frame in the IOMMU (Input-Output Memory Management Unit) page table for the current process. The IOMMU allows devices to perform Direct Memory Access (DMA) in a protected and virtualized manner by translating device-visible addresses to physical memory addresses. This system call enables the secure and precise configuration of these mappings, ensuring that devices can access only the memory explicitly permitted by the operating system.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page table of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the frame page. This involves marking the page as belonging to the calling process and designating it as a frame page in the page descriptor table. The memory associated with the frame page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn summary, the `sys_alloc_iommu_frame` system call provides a secure and reliable mechanism for allocating and mapping frames in the IOMMU page table. It performs rigorous validation of the target frame, the page table, and the requested permissions to ensure correctness and security. By carefully managing the allocation and mapping process, the system call enables protected DMA operations and ensures that devices can access only the memory explicitly authorized by the operating system. This functionality is essential for maintaining memory isolation and security in systems with multiple devices performing DMA.\n",
        "syscall": "sys_alloc_iommu_frame",
        "declaration": "int sys_alloc_iommu_frame(pn_t from, size_t index, dmapn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_frame(pn_t from, size_t index, dmapn_t to, iommu_pte_t perm)\n{\n    int r;\n    struct page_desc *desc;\n\n    /* check if `to' is free */\n    if (!is_dmapn_valid(to))\n        return -EINVAL;\n    if (!is_dmapage_type(to, PAGE_TYPE_FREE))\n        return -EBUSY;\n    r = map_iommu_page_table_page(from, index, kva2pa(&dmapages[to]), perm, PAGE_TYPE_IOMMU_PT);\n    if (r)\n        return r;\n\n    /* change the type to iommu frame */\n    desc = &dmapage_desc_table[to];\n    desc->type = PAGE_TYPE_IOMMU_FRAME;\n    desc->pid = current;\n    ++get_proc(current)->nr_dmapages;\n    return 0;\n}\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define NPROC 64    /* maximum number of processes */\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_iommu_frame` system call is designed to facilitate the mapping of an IOMMU (Input-Output Memory Management Unit) frame into a process's page table. This operation is crucial in systems that require direct memory access (DMA) by devices, allowing them to interact with memory in a controlled and secure manner. By mapping IOMMU frames, the system ensures that devices can access the necessary memory regions without compromising the integrity or security of the system.\nThe system call begins by validating the validity of the target DMA frame page and ensuring it is of an IOMMU frame type and is owned by the current process. If the frame does not meet these criteria, the operation is terminated with an error, as the mapping cannot proceed without a valid and authorized target.\nOnce the target frame is verified, the system calculates the physical frame number corresponding to the IOMMU frame. This physical frame number represents the actual memory location of the IOMMU frame and is essential for creating the mapping. The system then proceeds to establish the mapping in the page table by updating the appropriate entry to reference the IOMMU frame.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the IOMMU frame. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the current process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, IOMMU frame, and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn summary, the `sys_map_iommu_frame` system call provides a secure and efficient mechanism for mapping IOMMU frames into a process's page table. By validating inputs, enforcing permissions, and maintaining the integrity of the page table, the system call ensures that memory management operations are performed safely and effectively. This functionality is essential for supporting DMA operations and enabling devices to interact with memory in a controlled manner, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_map_iommu_frame",
        "declaration": "int sys_map_iommu_frame(pn_t pt, size_t index, dmapn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_iommu_frame(pn_t pt, size_t index, dmapn_t to, pte_t perm)\n{\n    pn_t pfn;\n\n    /* check if `to' is an iommu frame owned by current */\n    if (!is_dmapage_type(to, PAGE_TYPE_IOMMU_FRAME))\n        return -EINVAL;\n    if (!is_dmapage_pid(to, current))\n        return -EACCES;\n\n    pfn = (uintptr_t)dmapages / PAGE_SIZE + to;\n    return map_page(current, pt, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\n/* IOMMU frame pages */\nvolatile uint8_t dmapages[NDMAPAGE][PAGE_SIZE] __aligned(SZ_2M); /* 2M-aligned for PMR */\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\nstatic inline bool is_dmapage_pid(dmapn_t dmapn, pid_t pid)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].pid == pid;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_iommu_frame` system call is designed to reclaim a frame from the IOMMU (Input-Output Memory Management Unit) that was previously allocated to a process. This operation is crucial for freeing up resources that are no longer needed, particularly in scenarios where a process has terminated or is no longer using certain memory frames. The system call ensures that the reclamation process is performed safely and only under appropriate conditions, maintaining system stability and resource integrity.\nThe system call begins by validating the validity of the DMA frame page and ensuring it corresponds to a valid and active frame. If the frame is invalid or is already marked as free, the operation is terminated with an error. This initial validation step is essential to prevent erroneous operations on non-existent or already reclaimed frames.\nOnce the frame number is validated, the system call retrieves the page descriptor associated with the specified frame. This descriptor contains metadata about the frame, including its current type and the process identifier of the owning process. The system call checks the state of the owning process to ensure it is in a terminated state. If it is not satisfied, the operation is rejected with an error. This check is crucial because reclaiming frames from active processes could lead to data corruption or system instability.\nAdditionally, the system verifies that no devices are currently utilizing resources associated with the process that owns the frame. If any devices are in use, the operation is rejected with an error. This check is crucial to maintain system stability, as reclaiming frames in use by devices could lead to data corruption or device malfunctions.\nIf all conditions are satisfied, the system proceeds to reclaim the frame. It updates the target memory frame, marking it as free and removing its association with the previous owner. This update is performed atomically to ensure consistency and prevent race conditions during the operation. The system also updates the process's metadata to reflect the resource reclamation, decrementing the number of DMA pages associated with the process.\nIn conclusion, the sys_reclaim_iommu_frame system call is a vital mechanism for managing memory resources in environments involving memory management units. By enforcing strict validation and ownership checks, the system ensures that frames are reclaimed securely and efficiently, contributing to the overall robustness and flexibility of the system's memory management architecture.\n",
        "syscall": "sys_reclaim_iommu_frame",
        "declaration": "int sys_reclaim_iommu_frame(dmapn_t dmapn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_iommu_frame(dmapn_t dmapn)\n{\n    struct page_desc *desc;\n    pid_t pid;\n\n    if (!is_dmapn_valid(dmapn))\n        return -EINVAL;\n    if (is_dmapage_type(dmapn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    desc = &dmapage_desc_table[dmapn];\n    pid = desc->pid;\n    /* can reclaim pages owned by a zombie */\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    /* don't reclaim anything if any device is in use */\n    if (get_proc(pid)->nr_devs)\n        return -EBUSY;\n\n    desc->type = PAGE_TYPE_FREE;\n    desc->pid = 0;\n    --get_proc(pid)->nr_dmapages;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\n/* IOMMU frame pages */\nvolatile uint8_t dmapages[NDMAPAGE][PAGE_SIZE] __aligned(SZ_2M); /* 2M-aligned for PMR */\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_iommu_root` system call is designed to reclaim the IOMMU (Input-Output Memory Management Unit) root entry associated with a specific device, identified by its device ID (devid). This operation is crucial in systems where devices are dynamically managed, and resources need to be reallocated or cleaned up when they are no longer in use. The system call ensures that the IOMMU root entry is safely reclaimed, freeing up resources and maintaining system stability.\nThe system call begins by identifying the process associated with the specified device. It then validates the validity of the process and ensures the process is in a terminated state. This validation is essential because resources can only be safely reclaimed from processes that are no longer active, preventing potential conflicts or inconsistencies.\nAdditionally, the system call verifies that the process does not have any active interrupt remapping entries. Interrupt remapping is a feature of the IOMMU that allows interrupts to be dynamically redirected, and active entries indicate ongoing use of the device. If any interrupt remapping entries are present, the system call terminates with an error, as reclaiming the IOMMU root would disrupt active device operations.\nOnce these checks are passed, the system proceeds to decrement the count of devices associated with the process. This step is crucial for maintaining accurate bookkeeping of resources and ensuring that the process's resource usage is correctly reflected in the system's records.\nThe system then updates the device-to-process mapping to indicate that the device is no longer associated with any process. This update is essential for preventing future operations from mistakenly assuming that the device is still in use by the terminated process.\nFinally, the system resets the device's root in the IOMMU. It also invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. By performing these actions, the system ensures that the device is ready for reassignment or reuse by other processes, contributing to the overall efficiency and robustness of the system's resource management.\nIn conclusion, the `sys_reclaim_iommu_root` system call plays a vital role in managing device resources within the IOMMU. By carefully validating process states, checking for dependencies, and updating system records, it ensures that resources are reclaimed safely and efficiently. This functionality is essential for maintaining optimal resource utilization and system stability in environments where devices are frequently reassigned or reconfigured.\n",
        "syscall": "sys_reclaim_iommu_root",
        "declaration": "int sys_reclaim_iommu_root(devid_t devid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_iommu_root(devid_t devid)\n{\n    pid_t pid = pci_table[devid];\n\n    /* can free a page of a zombie process */\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_proc(pid)->nr_intremaps)\n        return -EBUSY;\n\n    --get_proc(pid)->nr_devs;\n    pci_table[devid] = 0;\n\n    iommu_reset_dev_root(devid);\n    iommu_flush();\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define SZ_64K UINT64_C(0x00010000)\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_vector` system call is designed to allocate an interrupt vector to the currently running process. Interrupt vectors are crucial in operating systems for handling hardware and software interrupts, allowing processes to be notified and respond to specific events. This system call ensures that a process can claim a vector for its exclusive use, facilitating efficient and organized interrupt handling.\nThe system call begins by checking if the requested vector is already in use. If the vector is occupied, the operation is terminated with an error, as each vector must be unique to ensure proper event handling. This check prevents conflicts and ensures that each process can be distinctly identified by its allocated vector.\nOnce it is confirmed that the vector is available, the system assigns it to the current process. This assignment involves updating a system-wide table that tracks which process is associated with each vector. By maintaining this mapping, the system can efficiently route events or interrupts to the correct process based on the vector.\nAfter successfully assigning the vector, the system increments a counter within the process. This counter keeps track of the number of vectors allocated to the process, providing a mechanism for resource management and ensuring that processes do not exceed their allocation limits.\nIn conclusion, the sys_alloc_vector system call is a fundamental mechanism for associating processes with unique vectors in systems that handle events or interrupts. By ensuring the uniqueness of vectors and maintaining an efficient mapping, the system call facilitates effective event handling and contributes to the overall stability and functionality of the system.\n",
        "syscall": "sys_alloc_vector",
        "declaration": "int sys_alloc_vector(uint8_t vector);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_vector(uint8_t vector)\n{\n    if (vector_table[vector])\n        return -EBUSY;\n\n    vector_table[vector] = current;\n    ++get_proc(current)->nr_vectors;\n    return 0;\n}\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NOFILE 16   /* open files per process */\n/* vector -> pid */\nstatic pid_t vector_table[256];\n#define NPROC 64    /* maximum number of processes */\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_vector` system call is designed to manage interrupt vectors by reclaiming them from processes that are no longer active. This operation is crucial in systems where interrupt vectors are a limited resource, and efficient management is necessary to ensure that they are available for use by active processes. By reclaiming vectors from processes that are in a terminated state, the system can free up these resources for reassignment, maintaining optimal utilization of interrupt handling capabilities.\nThe system call begins by validating the process associated with the specified interrupt vector is valid and in a terminated state. This association is crucial as it determines the ownership and current state of the resources linked to the vector. If the process is not valid or not in a terminated state, the operation is halted with an error. This restriction ensures that only resources from processes that are no longer active can be reclaimed, maintaining system stability and preventing unintended disruptions.\nOnce the process state is verified, the system checks for any outstanding interrupt remapping operations associated with the process. If such operations are present, the system denies the reclaim request with an error. This check ensures that all interrupt remapping activities are completed before resources are reclaimed, preventing potential conflicts or inconsistencies in interrupt handling.\nUpon successful validation of the process state and absence of pending operations, the system proceeds to reclaim the resources. It resets the corresponding mapping from interrupt vectors to processes to reflect the release of the interrupt vector, effectively making it available for future allocations. Additionally, the system decrements the count of active vectors associated with the process, maintaining accurate tracking of resource usage.\nIn summary, the sys_reclaim_vector system call plays a vital role in resource management within the system. By enforcing strict checks on process state and pending operations, it ensures that resources are reclaimed safely and efficiently. This functionality contributes to the overall robustness and flexibility of the system's interrupt management architecture, allowing for dynamic allocation and reclamation of resources as needed.\n",
        "syscall": "sys_reclaim_vector",
        "declaration": "int sys_reclaim_vector(uint8_t vector);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_vector(uint8_t vector)\n{\n    pid_t pid;\n\n    pid = vector_table[vector];\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_proc(pid)->nr_intremaps)\n        return -EBUSY;\n\n    vector_table[vector] = 0;\n    --get_proc(pid)->nr_vectors;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_intremap` system call is designed to allocate an interrupt remapping entry, which is crucial for managing hardware interrupts in systems that utilize an I/O Memory Management Unit (IOMMU). This system call ensures that interrupts from specific devices are correctly mapped to the appropriate interrupt vectors, allowing processes to handle hardware events efficiently and securely.\nThe system call begins by verifying the validity and availability of the specified interrupt remapping entry. If the entry is not valid or available, the operation is terminated with an error, as the allocation cannot proceed without a free entry.\nOnce the entry's validity and availability are confirmed, the system checks the ownership of the device and the interrupt vector. It ensures that both the device and the vector are owned by the current process. If either the device or the vector is not owned by the current process, the operation is rejected with an error. This ownership verification is critical to prevent unauthorized access to hardware resources, maintaining system security and integrity.\nAfter confirming ownership, the system proceeds to allocate the interrupt remapping entry. It updates the entry's state to indicate that it is now active and associates it with the specified device and vector. This association ensures that future interrupts from the device are correctly mapped to the specified vector, allowing the process to handle them appropriately.\nThe system also updates the process to reflect the allocation of the interrupt remapping entry. This update is essential for tracking the number of active remapping entries associated with the process, facilitating resource management and accounting.\nFinally, the system configures the hardware to establish the interrupt remapping. This configuration ensures that the hardware is aware of the new mapping, allowing interrupts to be delivered according to the specified configuration. By performing this step, the system ensures that the interrupt remapping is fully operational and effective.\nIn conclusion, the sys_alloc_intremap system call provides a mechanism for processes to allocate and manage interrupt remapping entries. It enforces strict ownership checks, updates system state, and configures hardware to ensure that interrupts are correctly mapped and handled. This capability is vital for systems requiring precise control over interrupt delivery, contributing to the overall robustness and efficiency of the system's interrupt management architecture.\n",
        "syscall": "sys_alloc_intremap",
        "declaration": "int sys_alloc_intremap(size_t index, devid_t devid, uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_intremap(size_t index, devid_t devid, uint8_t vector)\n{\n    struct intremap *ir;\n\n    if (!is_intremap_state(index, IR_FREE))\n        return -EINVAL;\n    /* is the device owned by current */\n    if (pci_table[devid] != current)\n        return -EACCES;\n    /* is the vector owned by current */\n    if (vector_table[vector] != current)\n        return -EACCES;\n\n    ir = &intremap_table[index];\n    ir->state = IR_ACTIVE;\n    ir->devid = devid;\n    ir->vector = vector;\n    ++get_proc(current)->nr_intremaps;\n    iommu_set_intremap(index, devid, vector);\n    return 0;\n}\n\nenum intremap_state {\n    IR_FREE = 0,\n    IR_ACTIVE,\n\n    IR_FORCE_WIDTH = ~UINT64_C(0),\n};\n\nstruct intremap {\n    enum intremap_state state;\n    devid_t devid;\n    uint8_t vector;\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define SZ_64K UINT64_C(0x00010000)\n#define NPROC 64    /* maximum number of processes */\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\n#define NINTREMAP 8 /* maximum number of interrupt remapping entries */\n\nstatic struct intremap intremap_table[NINTREMAP];\n\nstatic inline int is_intremap_state(size_t index, enum intremap_state state)\n{\n    return is_intremap_valid(index) && intremap_table[index].state == state;\n}\n\nstatic inline int is_intremap_valid(size_t index)\n{\n    return index < NINTREMAP;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_intremap` system call is designed to manage and reclaim interrupt remapping entries within the system. This operation is crucial for maintaining efficient use of interrupt remapping resources, which are essential for handling hardware interrupts in a virtualized environment. By reclaiming unused or obsolete entries, the system can optimize resource allocation and ensure that interrupt handling remains efficient and effective.\nThe system call begins by verifying the validity and the state of the specified interrupt remapping entry. It checks whether the entry is valid and currently active, as only active entries are eligible for reclamation. If the entry is not valid or active, the operation is terminated with an error, preventing any unintended modifications to inactive or already reclaimed entries.\nOnce the entry's state is validated, the system retrieves the associated process identifier from the interrupt remapping table. This identifier is crucial for determining the ownership and current state of the process linked to the entry. The system then checks the validity and the state of the process to ensure it is valid and in a terminated condition. This restriction ensures that only entries associated with processes that are no longer active can be reclaimed, maintaining system stability and preventing disruptions to active processes.\nIf the process state is verified, the system proceeds to update the interrupt remapping entry. It marks the entry as free, effectively releasing it for future use. Additionally, it clears any associated identifiers or vectors, ensuring that the entry is completely reset and ready for reassignment. This step is crucial for maintaining the integrity of the interrupt remapping table and preventing any residual data from affecting future operations.\nThe system then updates the process's metadata to reflect the decrease in the number of active interrupt remapping entries. This update ensures that the process's resource usage is accurately tracked, allowing the system to manage resources effectively and prevent any potential over-allocation or resource leaks.\nFinally, the system triggers a mechanism to reset the hardware state associated with the reclaimed entry. This step ensures that any hardware configurations related to the entry are cleared, preventing any unintended behavior or conflicts in future operations. By resetting the hardware state, the system maintains consistency between software and hardware configurations, ensuring reliable and predictable interrupt handling.\nIn conclusion, the `sys_reclaim_intremap` system call is a vital component for managing interrupt remapping resources within the system. It carefully validates the state of entries and processes, updates system tables and descriptors, and ensures hardware consistency. By providing this functionality, the system call contributes to the efficient and effective management of interrupt handling resources, enhancing the overall performance and reliability of the system's virtualized environment.\n",
        "syscall": "sys_reclaim_intremap",
        "declaration": "int sys_reclaim_intremap(size_t index);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_intremap(size_t index)\n{\n    struct intremap *ir;\n    pid_t pid;\n\n    if (!is_intremap_state(index, IR_ACTIVE))\n        return -EINVAL;\n\n    ir = &intremap_table[index];\n    pid = pci_table[ir->devid];\n    /* can only reclaim a zombie's IRTE */\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n\n    ir->state = IR_FREE;\n    ir->devid = 0;\n    ir->vector = 0;\n    --get_proc(pid)->nr_intremaps;\n    iommu_reset_intremap(index);\n    return 0;\n}\n\nenum intremap_state {\n    IR_FREE = 0,\n    IR_ACTIVE,\n\n    IR_FORCE_WIDTH = ~UINT64_C(0),\n};\n\nstruct intremap {\n    enum intremap_state state;\n    devid_t devid;\n    uint8_t vector;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define SZ_64K UINT64_C(0x00010000)\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\nstatic struct intremap intremap_table[NINTREMAP];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline int is_intremap_state(size_t index, enum intremap_state state)\n{\n    return is_intremap_valid(index) && intremap_table[index].state == state;\n}\n\n#define NINTREMAP 8 /* maximum number of interrupt remapping entries */\n\nstatic inline int is_intremap_valid(size_t index)\n{\n    return index < NINTREMAP;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_ack_intr` system call is designed to acknowledge and clear a specific interrupt for the currently running process. This operation is crucial in systems where processes need to manage and respond to multiple interrupts efficiently. By acknowledging an interrupt, the process indicates that it has handled the event associated with the interrupt vector, allowing the system to clear the interrupt state and prevent redundant handling.\nThe system call begins by retrieving the descriptor of the currently executing process. This descriptor contains crucial information about the process, including its interrupt status. The interrupt status is a bitset that tracks which interrupts are currently active for the process. By accessing this status, the system can determine which interrupts need to be acknowledged and cleared.\nOnce the process descriptor is obtained, the system proceeds to clear the specified interrupt from the process's interrupt status. This is achieved by manipulating the bitset to remove the bit corresponding to the interrupt. By clearing this bit, the system effectively acknowledges that the interrupt has been handled and should no longer be considered active for the process.\nThe operation is performed atomically to ensure consistency and prevent race conditions. This atomicity is crucial in a multi-threaded or multi-core environment, where multiple processes or threads might be interacting with the interrupt status simultaneously. By ensuring that the operation is atomic, the system maintains the integrity of the interrupt status and prevents any potential conflicts or inconsistencies.\nIn conclusion, the `sys_ack_intr` system call is a vital component in the management of interrupt-driven events within a process. By providing a mechanism to acknowledge and clear interrupts, it ensures that processes can efficiently handle and respond to interrupt events without redundancy or instability. This capability contributes to the overall robustness and reliability of the system's interrupt management architecture.\n",
        "syscall": "sys_ack_intr",
        "declaration": "int sys_ack_intr(uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_ack_intr(uint8_t v)\n{\n    struct proc *proc = get_proc(current);\n\n    bit_clear(v, proc->intr);\n    return 0;\n}\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n#define _BITSET_BITS       (sizeof(unsigned long) * 8)\n\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_clear(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] &= ~__bitset_mask(n);\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_port` system call is designed to allocate an I/O port to a process, allowing it to perform input/output operations on that port. This functionality is crucial in systems where processes need direct access to hardware resources, such as peripheral devices, through specific I/O ports. The system call ensures that port allocation is managed securely and efficiently, preventing conflicts and unauthorized access.\nThe system call begins by checking if the requested port is already in use. If the port is occupied, the operation is terminated with an error, indicating that the port is unavailable for allocation. This check prevents conflicts and ensures that each port is uniquely assigned to a single process at any given time.\nOnce the port's availability is confirmed, the system verifies whether the process is permitted to use the I/O bitmap. If the process lacks this permission, the operation is rejected with an error. This restriction ensures that only authorized processes can allocate ports, maintaining system security and stability.\nIf the process is authorized, the system proceeds to allocate the port by marking it as taken by the current process. It updates the I/O bitmap of the process to clear the bit corresponding to the allocated port, effectively granting the process access to the port. The bitmap is divided into two sections, and the system determines which section to update based on the port number. This update ensures that the process has the necessary permissions to access the allocated port.\nFinally, the system increments the count of ports allocated to the process, reflecting the successful allocation. The operation concludes with a success status, indicating that the port has been successfully allocated to the process.\nIn summary, the sys_alloc_port system call is a critical mechanism for managing I/O port allocations in a secure and efficient manner. It ensures that ports are uniquely assigned, verifies process permissions, and updates the process's I/O bitmap to reflect the allocation. By providing this functionality, the system call supports processes in performing direct hardware interactions, contributing to the overall flexibility and capability of the system's I/O management.\n",
        "syscall": "sys_alloc_port",
        "declaration": "int sys_alloc_port(uint16_t port);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_port(uint16_t port)\n{\n    struct proc *proc;\n\n    if (io_table[port])\n        return -EBUSY;\n\n    proc = get_proc(current);\n    if (!proc->use_io_bitmap)\n        return -EACCES;\n\n    io_table[port] = current;\n    if (port < 0x8000)\n        bit_clear(port, get_page(proc->io_bitmap_a));\n    else\n        bit_clear(port - 0x8000, get_page(proc->io_bitmap_b));\n    ++proc->nr_ports;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define SZ_64K UINT64_C(0x00010000)\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/*\n * Map port to owner pid:\n * 0: free\n * -1: reserved by kernel\n * others: taken by pid\n */\nstatic pid_t io_table[SZ_64K];\n\n#define _BITSET_BITS       (sizeof(unsigned long) * 8)\n\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_clear(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] &= ~__bitset_mask(n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_port` system call is designed to manage the ownership of I/O ports by reclaiming ports that were previously allocated to processes that are no longer active. This functionality is crucial in systems where I/O ports are a limited resource and need to be efficiently managed and reallocated as processes terminate or become inactive. The system call ensures that ports are only reclaimed from processes that are in a specific state, maintaining system integrity and preventing unauthorized access to I/O resources.\nThe system call begins by identifying the process associated with the specified resource. It retrieves the identifier of the process that currently holds the resource. This step is crucial for determining the ownership and state of the resource.\nOnce the process identifier is obtained, the system verifies the validity and the state of the process to ensure it is in a terminated condition that allows resource reclamation. If the process is not valid or in the required state, the operation is terminated with an error. This check prevents unauthorized access and ensures that only resources from processes in the appropriate state can be reclaimed.\nIf the process is in the correct state, the system proceeds to release the resource. It resets and clears the owner process of the resource to indicate that the resource is now available for allocation. This step is performed without the need to modify any additional process-specific configurations, simplifying the reclamation process.\nFinally, the system decrements the count of ports allocated to the process, reflecting the successful resource reclamation. It decrements the count of resources held by the process, ensuring that the process's resource usage is accurately tracked. This update is crucial for maintaining an accurate record of resource distribution across the system.\nIn summary, the `sys_reclaim_port` system call provides a mechanism for reclaiming resources from processes that are no longer actively using them. By enforcing strict checks on process state and updating resource management structures, the system ensures that resources are efficiently recycled and made available for future use. This contributes to the overall stability and performance of the system's resource management framework.\n",
        "syscall": "sys_reclaim_port",
        "declaration": "int sys_reclaim_port(uint16_t port);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_port(uint16_t port)\n{\n    pid_t pid = io_table[port];\n\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n\n    io_table[port] = 0;\n    /* no need to clear per-process I/O bitmap */\n    --get_proc(pid)->nr_ports;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define SZ_64K UINT64_C(0x00010000)\n#define NPROC 64    /* maximum number of processes */\n\nextern struct proc proc_table[NPROC];\n\n/*\n * Map port to owner pid:\n * 0: free\n * -1: reserved by kernel\n * others: taken by pid\n */\nstatic pid_t io_table[SZ_64K];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pdpt` system call is responsible for allocating a new Page Directory Pointer Table (PDPT) entry in a process's hierarchical page table, which is a critical structure in managing virtual memory. This system call involves mapping a newly allocated memory page to the next level in the page table hierarchy, ensuring that the memory is correctly configured and accessible with the specified permissions. The operation supports dynamic memory allocation for processes, enabling them to expand or modify their virtual address space as needed.\nThe operation begins by validating the target page designated for the page directory pointer table is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page directory pointer table entry. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. PML4, to point to the newly allocated page directory pointer table page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nAfter successfully establishing the mapping, the system proceeds to allocate the PDPT page. This involves marking the page as belonging to the process and designating it as a PDPT in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pdpt` system call provides a structured and secure mechanism for allocating and mapping PDPT pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pdpt",
        "declaration": "int sys_alloc_pdpt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pdpt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PML4,\n                                 PAGE_TYPE_X86_PDPT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define PTE_PFN_SHIFT 12\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* update the page table */\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n```\n",
    },
    {
        "description": "\n[Functional Description]:\nThe sys_free_pdpt system call is responsible for freeing a specific entry in a page table hierarchy by deallocating a page directory pointer table (PDPT) page and cleaning up its reference within a higher-level page table. This operation is an essential part of dynamic memory management in virtual memory systems, where hierarchical page tables are used to manage address mappings. The system call ensures that the memory associated with a PDPT page is properly released and no longer accessible, while maintaining the integrity of the page table structure.\nThe system call begins by validating that the source page directory pointer table is valid and is of the correct type, a Page Map Level 4 type. It also validates that the source PML4 page table belongs to the calling process. It ensures that the PML4 page table corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the PML4 page table, each of which points to PDPT page. This check ensures that the operation targets a valid entry within the PML4 page table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page directory pointer table is valid and is of the correct type, a Page Directory Pointer Table. It ensures that the target page directory pointer table corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the PML4 page table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing PML4 page table entry corresponds to the specified page directory pointer table by checking if the physical frame number derived from the PML4 page table entry matches the page directory pointer table's expected physiscal address.  This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the PDPT page. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the PML4 page table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PDPT from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PD is freed.\nBy the end of the operation, the specified PDPT page is fully deallocated, and its entry in the PML4 table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The sys_free_pdpt system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pdpt",
        "declaration": "int sys_free_pdpt(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pdpt(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PML4, PAGE_TYPE_X86_PDPT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `clone_proc` system call facilitates the creation of a new process by duplicating key aspects of an existing process, such as its memory layout, execution state, and kernel stack. This functionality is fundamental to multitasking operating systems, allowing new processes to be created either as independent entities or as lightweight threads that share certain resources with their parent. The clone_proc function, which implements this system call, ensures that the new process is correctly initialized and inherits the necessary context to execute seamlessly.\nThe system call begins by allocating resources for the new process. It first validates the validity and the state of the specified process. If the process if invalid or not unused, the operation is rejected with an error. It then ensures that the necessary memory pages for the process's page table root, stack, and hardware state are valid and unallocated. If any of these resources are not valid,unavailable, or already in use, the operation is terminated with an error, preventing resource conflicts and ensuring system stability. Also, the system validates the process's page table root, stack, and hardware state are unique to each other. If any two of them are identical, the operation is rejected with an error.\nOnce the validations are complete, the system initializes the new process's descriptor, setting its parent process identifier and marking it as in the embryonic state. This state indicates that the process is in the initial stages of creation and not yet fully operational. The system also allocates and initializes pages for the page table root, stack and hvm with the corresponding page type and then updates the current process's metadata to reflect the increase of pages allocated for the specified process. The metadata of the process's parent process is also updated to reflect the increase of its child processes.\nThe system then duplicates the current process's execution context. It copies all the data of the kernel stack, which contains saved registers and execution state, to the new process's stack. This ensures that the new process begins execution with the same context as the parent process, allowing it to continue from the same point in the program.\nNext, the system copies the hardware virtual machine (HVM) state from the current process to the new process. This involves flushing the stale mappings to ensure consistency and copy data from the parent HVM to the child HVM state specified. This step is crucial for maintaining the execution environment, as it includes processor state and other critical hardware configurations.\nAfter duplicating the execution context, the system prepares the new process for execution.\nFinally, the system returns control to the user space, allowing the new process to begin execution. The new process starts with the same execution context as the parent, enabling it to perform tasks independently while sharing the same initial state.\nIn summary, the `clone_proc` system call is a vital mechanism for process creation in operating systems. It carefully allocates resources, duplicates execution context, and prepares the new process for execution, ensuring a seamless and efficient process creation experience. By providing this functionality, the system call supports multitasking and process management, contributing to the overall robustness and flexibility of the operating system.\n",
        "syscall": "clone_proc",
        "declaration": "int sys_clone(pid_t pid, pn_t pml4, pn_t stack, pn_t hvm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint clone_proc(pid_t pid, pn_t pml4, pn_t stack, pn_t hvm)\n{\n    int r;\n    struct proc *proc;\n    void *parent_hvm, *child_hvm;\n\n    r = alloc_proc(pid, pml4, stack, hvm);\n    if (r)\n        return r;\n\n    proc = get_proc(current);\n\n    /* copy the kernel stack (saved registers) */\n    memcpy(get_page(stack), get_page(proc->stack), PAGE_SIZE);\n\n    parent_hvm = get_page(proc->hvm);\n    child_hvm = get_page(hvm);\n    /* copy hvm state */\n    flush_current();\n    hvm_flush(child_hvm);\n    memcpy(child_hvm, parent_hvm, PAGE_SIZE);\n    hvm_copy(child_hvm, parent_hvm, pid);\n\n    /* will call run_current() upon return */\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nint alloc_proc(pid_t pid, pn_t page_table_root, pn_t stack, pn_t hvm)\n{\n    struct proc *proc, *parent;\n\n    if (!is_proc_state(pid, PROC_UNUSED))\n        return -ENOMEM;\n    if (!is_page_type(page_table_root, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (!is_page_type(stack, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (!is_page_type(hvm, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (page_table_root == stack)\n        return -EINVAL;\n    if (page_table_root == hvm)\n        return -EINVAL;\n    if (stack == hvm)\n        return -EINVAL;\n\n    proc = get_proc(pid);\n    bzero(proc, sizeof(*proc));\n    proc->ppid = current;\n    proc->state = PROC_EMBRYO;\n\n    alloc_page(pid, PAGE_TYPE_X86_PML4, page_table_root);\n    proc->page_table_root = page_table_root;\n\n    alloc_page(pid, PAGE_TYPE_PROC_DATA, stack);\n    proc->stack = stack;\n\n    alloc_page(pid, PAGE_TYPE_PROC_DATA, hvm);\n    proc->hvm = hvm;\n\n    parent = get_proc(current);\n    ++parent->nr_children;\n\n    return 0;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* called in entry.S */\nvoid flush_current(void)\n{\n    struct proc *proc;\n    void *hvm;\n\n    proc = get_proc(current);\n    hvm = get_page(proc->hvm);\n    hvm_flush(hvm);\n    proc->launched = 0;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `send_proc` system call facilitates one-way interprocess communication (IPC) by enabling a process (the sender) to deliver data and control information to another process (the receiver). This mechanism is particularly useful in scenarios where a server process is waiting to handle requests or data from client processes. The system ensures secure and synchronized communication by validating inputs, transferring data, and transitioning the states of the involved processes appropriately.\nThe system call begins by validating the validity of the target process and ensuring that it is in a sleeping state. If the target process is not valid or in the appropriate state, the operation is aborted with an error, as data cannot be sent to a process that is not ready to receive it.\nOnce the target process is verified, the system checks the validity and the ownership of the memory region from which data will be sent. This involves ensuring that the memory page is valid and belongs to the sending process and that the specified size does not exceed the allowable limit. If these conditions are not met, the operation is terminated with an error, preventing unauthorized access or buffer overflows.\nIf the file descriptor is included, it must be either invalid, indicating the file descriptor is not in use, or valid and associated with an open file. If the file descriptor is valid but not associated with an open file, the operation is rejected with an error.\nAfter all validations are complete, the system retrieves the descriptors for both the sending and receiving processes. It then updates the receiving process's state to reflect the incoming data, including the source process, the data value, and the size of the data. The system ensures that the memory region designated for receiving data is valid and owned by the target process, maintaining memory integrity.\nThe data is then copied from the sending process's memory to the receiving process's designated memory region. This operation is performed securely to prevent data corruption or unauthorized access.\nIf the file descriptor provided and the receiver's file descriptor are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nFinally, the system updates the states of both processes to reflect the completion of the data transfer. The sending process is marked as ready to run, while the receiving process is transitioned to a running state. This ensures that the receiving process can immediately begin processing the received data. And then the current process is switched to the receiving process.\nIn conclusion, the `send_proc` system call is a vital mechanism for enabling efficient and secure data exchange between processes. By enforcing strict validations and ensuring proper state transitions, the system call maintains the integrity and reliability of inter-process communication within the operating system.\n",
        "syscall": "send_proc",
        "declaration": "int sys_send(pid_t pid, uint64_t val, pn_t pn, size_t size, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint send_proc(pid_t pid, uint64_t val, pn_t pn, size_t size, int fd)\n{\n    struct proc *sender, *receiver;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    if (!is_pn_valid(pn))\n        return -EINVAL;\n    /* pn doesn't have to be a frame */\n    if (!is_page_pid(pn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    if (is_fd_valid(fd)) {\n        if (!is_fn_valid(get_fd(current, fd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    receiver->ipc_size = size;\n    /* invariant: proc->ipc_page is a valid page owned by pid */\n    memcpy(get_page(receiver->ipc_page), get_page(pn), size);\n    /* invariant: ipc_fd is empty if it's valid */\n    if (is_fd_valid(fd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, fd));\n\n    sender->state = PROC_RUNNABLE;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    current = pid;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NPAGE 8192  /* maximum number of pages */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `reply_wait_proc` system call implements a two-way communication mechanism between a client and a server process, enabling a client to send data and wait for a response from the server. The system ensures that the server is in a specific state to handle the request while maintaining proper synchronization and resource allocation. This functionality is crucial for interprocess communication (IPC) in operating systems where processes must exchange data or signals in a controlled and coordinated manner.\nThe system call begins by verifying the validity of the target process and ensuring it is in the sleeping state, indicating readiness to receive data. If the target process is not valid or is actively running, the system call terminates with an error.\nNext, the system validates the validity of the input page and the output page. It also validates that the input and output pages belong to the calling process. The type of the output page should be the correct frame page and the size of the data must not exceed the limits of a memory page. Any violations to these constriants will make the operation to terminate with an error.\nThe system then validates that the input and output file descriptor is either invalid or non-empty and the output file descriptor is either invalid or empty. The output file descriptor is set to invalid to indicate that no output file descriptor is used in the operation. If these conditions are not met, the operation is rejected with an error. These checks ensure that communication adheres to system constraints and prevents unauthorized access.\nThe system then sets up the communication. It sets the current process as the sender process and the target process as the receiver process. It then validates that the receiver process wants to accept the other process's requests. If the condition is not met, the operation is rejected with an error. The sender process then prepares to send its request by specifying the data to be transferred and optional resources such as file descriptors. The receiver process prepares to receive this data by specifying the source process that the data is from and the specific control value. The system then securely transfers the page of data from the input page to the designated page of the receiver process within the specified size limit and updates the transferred size for the receiver process. establishing the memory location (outpn) where the input data will be copied, ensuring that the receiver can process the request without needing additional access to the sender's resources. If the input file descriptor and the file descriptor of the receiver process are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nAfter the data and resources are transferred, the system transitions control between the two processes. The sender process is placed into a sleeping state, indicating that it is waiting for the receiver to complete its task. At the same time, the receiver process is transitioned to a running state, allowing it to process the request immediately. This context switch ensures that the receiver begins handling the request without delay while the sender remains blocked until the receiver completes its task. The state transition is carefully managed to maintain system stability and prevent race conditions or deadlocks.\nFinally, the system ensures the current process is set to accept IPC communication from the specified process and then switches the current process context to the specified process.\nIn summary, the `reply_wait_proc` system call is used to facilitate interprocess communication where a process replies to a waiting process (receiver) and simultaneously prepares itself to wait for further communication. It validates inputs, securely transfers data (including optional file descriptors), and updates process states to ensure the sender transitions to sleeping (waiting) while the receiver is activated. This system call is critical in managing synchronous communication between processes, enabling efficient data exchange and coordinated execution in the operating system.",
        "syscall": "reply_wait_proc",
        "declaration": "int sys_reply_wait(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint reply_wait_proc(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn)\n{\n    int r;\n\n    r = send_recv(pid, val, inpn, size, infd, outpn, -1);\n    if (r)\n        return r;\n    /* accept any ipc */\n    get_proc(current)->ipc_from = 0;\n    current = pid;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic int send_recv(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn,\n                     int outfd)\n{\n    struct proc *sender, *receiver;\n\n    /* target process must be sleeping */\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    /* check in page */\n    if (!is_pn_valid(inpn))\n        return -EINVAL;\n    /* inpn doesn't have to be a frame */\n    if (!is_page_pid(inpn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    /* check in fd: either invalid or non-empty */\n    if (is_fd_valid(infd)) {\n        if (!is_fn_valid(get_fd(current, infd)))\n            return -EINVAL;\n    }\n    /* check out page */\n    if (!is_pn_valid(outpn))\n        return -EINVAL;\n    if (!is_page_pid(outpn, current))\n        return -EACCES;\n    if (!is_page_type(outpn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    /* check out fd: either invalid or empty */\n    if (is_fd_valid(outfd)) {\n        if (is_fn_valid(get_fd(current, outfd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    /* check if the receiver wants to accept anyone's request */\n    if (receiver->ipc_from && receiver->ipc_from != current)\n        return -EACCES;\n\n    /* client: prepare for response */\n    sender->ipc_page = outpn;\n    sender->ipc_fd = outfd;\n\n    /* server: transfer data from client */\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    /* transfer the page */\n    memcpy(get_page(receiver->ipc_page), get_page(inpn), size);\n    receiver->ipc_size = size;\n    /* transfer the fd */\n    if (is_fd_valid(infd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, infd));\n\n    /* switch control */\n\n    sender->state = PROC_SLEEPING;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    /* sender: running -> sleeping */\n    proc_ready_del(sender);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_dup2` system call provides a mechanism for duplicating a file descriptor from one process to another or within the same process. This operation is essential for managing file descriptor tables, allowing processes to redirect input/output streams or share file descriptors between processes. By duplicating a file descriptor, a process can create an alias for an existing file descriptor, enabling flexible file management and inter-process communication.\nThe system call begins by validating the specified process identifier to ensure it corresponds to a valid and active process. If the process identifier is invalid, the operation is terminated with an error, as the duplication cannot proceed without a valid target. The system also checks that the process is either the current one or its embryo process, ensuring that the operation is authorized.\nNext, the system verifies the validity of the source file descriptor within the current process. It also validates the source file descriptor exists in the calling process. If the source file descriptor is invalid or does not exist in the calling process, the operation is rejected with an error. This check ensures that the duplication operation is based on a valid file descriptor, preventing errors or undefined behavior.\nThe system then checks the validity of the target file descriptor. If the target file descriptor is invalid, the operation is terminated with an error. This validation ensures that the target location for the duplication is within acceptable limits, maintaining the integrity of the file descriptor table.\nIf the source and target file descriptors are the same and belong to the same process, the system call does nothing and returns successfully. This behavior aligns with the POSIX standard, which specifies that duplicating a file descriptor to itself should have no effect.\nIf the target file descriptor already exists in the target process, the system closes it before proceeding with the duplication.    Closing the file involves updating the process's file descriptor table to mark the descriptor as unused and decrementing the count of open file descriptors for the process. Additionally, the system updates the file's reference count to reflect the decrease of the file references. And if the file is no longer referenced by any process, it resets the file's attributes, including its type, value, offset, and mode of operation, releasing the associated resources. This step guarantees that newfd is free and available for duplication.\nFinally, the system proceeds to duplicate the source file descriptor. The system associates the file descriptor with the file or resource by updating the target process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. This assignment is performed atomically to ensure consistency and correctness during the operation.\nIn conclusion, the `sys_dup2` system call is a crucial feature for managing file descriptors in a flexible and efficient manner. It carefully validates inputs, enforces strict permissions, and ensures that the duplication is performed securely and accurately. This design allows processes to manage their file descriptors effectively, contributing to the overall robustness and flexibility of the system's file management architecture.\n\n",
        "syscall": "sys_dup2",
        "declaration": "int sys_dup2(int oldfd, pid_t pid, int newfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_dup2(int oldfd, pid_t pid, int newfd)\n{\n    fn_t fn;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    /* oldfd doesn't exist  */\n    if (!is_fd_valid(oldfd))\n        return -EBADF;\n    fn = get_fd(current, oldfd);\n    if (fn == 0)\n        return -EBADF;\n    if (!is_fd_valid(newfd))\n        return -EBADF;\n\n    /* POSIX: do nothing for the same fd */\n    if ((current == pid) && (oldfd == newfd))\n        return 0;\n\n    /* close newfd if it already exists */\n    if (get_fd(pid, newfd) != 0)\n        clear_fd(pid, newfd);\n    set_fd(pid, newfd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void clear_fd(pid_t pid, int fd)\n{\n    struct proc *proc;\n    struct file *file;\n\n    proc = get_proc(pid);\n    file = get_file(get_fd(pid, fd));\n    proc->ofile[fd] = 0;\n    --proc->nr_fds;\n    if (--file->refcnt == 0) {\n        file->type = FD_NONE;\n        file->value = 0;\n        file->offset = 0;\n        file->omode = 0;\n    }\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe sys_alloc_io_bitmap system call is designed to enable a process to allocate an I/O bitmap, which controls access to I/O ports in virtualized environments. The I/O bitmap acts as a mechanism for restricting or granting access to specific I/O ports by mapping them to a bit array, where each bit corresponds to a port. This system call ensures proper setup of the I/O bitmap while adhering to security and hardware requirements, making it essential for processes that require fine-grained control over I/O port access.\nThe system call begins by validating the sequence of memory pages provided. It requires three consecutive pages to be specified, ensuring that the memory allocation is contiguous. This requirement arises because hardware virtualization, particularly in x86 architectures, demands that I/O bitmaps be stored in contiguous memory regions for efficient access. If the pages are not consecutive, the operation is terminated with an error, as the allocation cannot proceed without a valid sequence.\nOnce the sequence is verified, the system checks whether the process already has an I/O bitmap allocated. If an I/O bitmap is already in use, the operation is rejected with an error to prevent multiple allocations, which could lead to resource conflicts.\nThe system then verifies that each of the specified pages is valid and available for allocation. This check ensures that the pages are not currently in use by other processes or system components. If any page is not valid or free, the operation is terminated with an error, maintaining the integrity of the memory allocation process.\nUpon successful validation, the system allocates the pages for the process, marking them as used for process-specific data. This allocation is crucial for setting up the I/O bitmap, which will control the process's access to I/O ports. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nThe system proceeds to initialize the allocated pages by setting all bits to one. This initialization ensures that any access to I/O ports will initially cause an exit from the virtual machine, allowing the hypervisor to manage and control port access effectively.\nFinally, the system call updates the process metadata to reflect the allocation of the I/O bitmap. It records the pages used for the bitmap and marks the process as actively using an I/O bitmap. By doing this, the system ensures that the process can manage its I/O port access through the bitmap while preventing further allocations for the same purpose. The system call then completes successfully, signaling to the caller that the I/O bitmap has been properly allocated and configured.\nIn conclusion, the sys_alloc_io_bitmap system call is a critical feature for managing I/O port access in virtualized environments. It carefully validates inputs, enforces strict allocation rules, and ensures that the I/O bitmap is configured securely and efficiently. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtualization architecture.\n",
        "syscall": "sys_alloc_io_bitmap",
        "declaration": "int sys_alloc_io_bitmap(pn_t pn1, pn_t pn2, pn_t pn3);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_io_bitmap(pn_t pn1, pn_t pn2, pn_t pn3)\n{\n    struct proc *proc;\n\n    if (!(pn1 + 1 == pn2 && pn2 + 1 == pn3))\n        return -EINVAL;\n\n    proc = get_proc(current);\n    if (proc->use_io_bitmap)\n        return -EEXIST;\n\n    /*\n     * Since svm needs 3 consecutive pages and vmx needs 2 pages,\n     * we follow the more stricted (svm) rule.  Note that we use only\n     * 2 pages for the I/O bitmap; as the 3rd page contains all 1s,\n     * any wrap-around port access will cause vmexit on svm, which\n     * matches the unconditional vmexit behavior on vmx.\n     */\n\n    if (!is_page_type(pn1, PAGE_TYPE_FREE))\n        return -EINVAL;\n    if (!is_page_type(pn2, PAGE_TYPE_FREE))\n        return -EINVAL;\n    if (!is_page_type(pn3, PAGE_TYPE_FREE))\n        return -EINVAL;\n\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn1);\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn2);\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn3);\n\n    /* set all bits to 1s */\n    memset(get_page(pn1), 0xff, PAGE_SIZE);\n    memset(get_page(pn2), 0xff, PAGE_SIZE);\n    memset(get_page(pn3), 0xff, PAGE_SIZE);\n\n    hvm_set_io_bitmap(get_page(proc->hvm), get_page(pn1));\n    proc->io_bitmap_a = pn1;\n    proc->io_bitmap_b = pn2;\n    proc->use_io_bitmap = 1;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `extintr` system call is responsible for handling external interrupts by associating a specific interrupt vector with a process and ensuring that the process is notified accordingly. This mechanism is essential in systems where external events, such as hardware signals or software-generated interrupts, need to be communicated to processes in a timely and efficient manner. By updating the interrupt state of the designated process and potentially waking it up if it is sleeping, the system call ensures that the interrupt is handled effectively.\nThe system call begins by identifying the process associated with the specified interrupt vector. It retrieves the process identifier from a predefined table that maps interrupt vectors to processes. This mapping ensures that each interrupt is directed to the correct process for handling.\nOnce the process identifier is obtained, the system validates it to ensure it corresponds to a legitimate and active process. If the identifier is invalid, the operation is terminated with an error, as it cannot proceed without a valid target process.\nAfter validation, the system retrieves the process descriptor, which contains essential information about the process, including its current state and interrupt handling capabilities. The system then sets a specific bit in the process's interrupt bitmask, indicating that the process has been signaled for the interrupt by calculating the specific bit index and bit mask using the specified interrupt vector.\nIf the process is currently in a sleeping state, the system transitions it to a runnable state, enabling it to respond to the interrupt. This state change is crucial for ensuring that the process can execute and handle the interrupt promptly. Additionally, the system sets special values in the process descriptor to facilitate inter-process communication, allowing the process to identify the source and nature of the interrupt.\nIn conclusion, the `extintr` system call is a vital component for managing external interrupts in a multitasking environment. It ensures that interrupts are directed to the appropriate processes, validates process identifiers, updates process states, and facilitates communication between processes. By providing this functionality, the system call enhances the system's ability to handle asynchronous events efficiently and effectively.\n",
        "syscall": "extintr",
        "declaration": "int extintr(uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint extintr(uint8_t v)\n{\n    pid_t pid = vector_table[v];\n    struct proc *proc;\n\n    /* be paranoid  */\n    if (!is_pid_valid(pid))\n        return -EINVAL;\n    proc = get_proc(pid);\n\n    bit_set(v, proc->intr);\n    /* wake up a process if a new bit is set */\n    if (proc->state == PROC_SLEEPING) {\n        proc->state = PROC_RUNNABLE;\n        /* special value for kernel */\n        proc->ipc_from = 0;\n        proc->ipc_val = v;\n        proc->ipc_size = 0;\n    }\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\nstatic pid_t vector_table[256];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_set(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] |= __bitset_mask(n);\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_pml4` system call provides a mechanism for establishing a self-referential mapping in a process's Page Map Level 4 (PML4) table. This mapping technique is commonly used in virtual memory systems to allow a process to access its own page table hierarchy through virtual memory. By mapping the PML4 table into itself at a specific index, the process can dynamically traverse and manipulate its paging structures without requiring additional system calls or privileged operations.\nThe system call begins by validating the identifier of the target process to ensure that it corresponds to a valid and active process. If the process identifier is not valid, the operation is terminated with an error, as the mapping cannot proceed without a valid target.\nOnce the process identifier is verified, the system calculates the physical frame number corresponding to the PML4 table (page table root) using the page table root of the process. The physical frame number represents the physical memory location of the PML4 table and is essential for creating the mapping. Before proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the PML4 table, as allowing write permissions could lead to accidental or malicious corruption of the page table hierarchy. By enforcing read-only or execute-only permissions, the system maintains the stability and security of the virtual memory system.\nThe system then establishes a self-referential mapping in the PML4 table by updating the appropriate entry to reference itself. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page, the page table root, corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the page of the page table root and verifies that the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the expected physical memory of the page table root using the specified page table root entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_pml4` system call is a crucial feature for enabling self-referential mappings in process page tables. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage their page tables directly, which is particularly useful in advanced memory management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtual memory architecture.\n",
        "syscall": "sys_map_pml4",
        "declaration": "int sys_map_pml4(pid_t pid, size_t index, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_pml4(pid_t pid, size_t index, pte_t perm)\n{\n    struct proc *proc;\n    pn_t from, pfn;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    from = proc->page_table_root;\n    pfn = pn_to_pfn(from);\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PML4);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n"
    },


    {
        "description": "\n[Functional Description]:\nThe `sys_map_page_desc` system call is designed to map a portion of the page descriptor table into a process's address space. This operation is crucial for processes that need to access or manage page descriptors directly, such as in advanced memory management tasks or when implementing custom paging mechanisms. By allowing a process to map page descriptors, the system call provides flexibility in how memory is managed and accessed within the operating system.\nThe system call begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing page descriptors. If the request number is too large, the system call returns an error, as it would attempt to map beyond the available descriptors. This check ensures that the mapping operation remains within the bounds of the page descriptor table, preventing access to invalid memory regions.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the page descriptor table in memory based on the number of pages requested. This calculation determines the specific memory region within the page descriptor table that will be mapped. Before proceeding with the mapping, the system call checks the specified permissions. If the permissions include write access, the operation is rejected. This restriction is crucial for maintaining the integrity of the page descriptor table, as allowing write access could lead to corruption or unauthorized modifications.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the page descriptors. It then performs a series of checks to ensure system consistency and security. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permissions do not include any unsafe bits by comparing them against the permission mask and ensures the page table entry is valid. If any of these checks fail, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the source page number, and verifies the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nFinally, the system updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nThe result of this operation is a mapped region in the process's address space that corresponds to a portion of the page descriptor table. This capability allows the process to access and manage page descriptors directly, enabling advanced memory management techniques and custom paging implementations. By integrating this functionality into the virtual memory system, the `sys_map_page_desc` system call enhances the flexibility and efficiency of memory management in the operating system.\nIn conclusion, the `sys_map_page_desc` system call provides a mechanism for mapping page descriptors into a process's address space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage page descriptors directly, which is particularly useful in advanced memory management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtual memory architecture.\n",
        "syscall": "sys_map_page_desc",
        "declaration": "int sys_map_page_desc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_page_desc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n < bytes_to_pages(NPAGE * sizeof(struct page_desc)))\n        return -EINVAL;\n    pfn = (uintptr_t)page_desc_table / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_proc` system call provides a mechanism for mapping process descriptors into a process's page table. This operation is crucial for scenarios where processes need to share memory regions, such as in interprocess communication or shared memory applications. The system call ensures that the mapping is performed securely and adheres to the system's memory management policies.        \nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing processes. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system then calculates the physical frame number corresponding to the starting point of the process table based on the number of pages requested. This calculation determines the specific memory region within the process table that will be mapped.                Before proceeding with the mapping, the system call checks the specified permissions. If the permissions include write access, the operation is rejected. This restriction is crucial for maintaining the integrity of the process table, as allowing write access could lead to corruption or unauthorized modifications.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the processes.        \nIt then performs a series of checks to ensure system consistency and security. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system enforces strict validation of the permissions associated with the mapping. It checks that the requested permissions do not include any unsafe bits by comparing them against the permission mask and ensures the entry is valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the source page number, and verifies the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nThe result of this operation is a memory mapping that allows the target process to access the specified region of the process table. This capability is essential for enabling shared memory applications, where multiple processes need to access the same data concurrently. By providing a secure and efficient mechanism for memory mapping, the `sys_map_proc` system call enhances the flexibility and functionality of the system's memory management architecture.\nIn conclusion, the `sys_map_proc` system call provides a robust mechanism for mapping process memory into another process's address space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to share memory regions safely, supporting advanced memory management scenarios and enabling efficient interprocess communication.",
        "syscall": "sys_map_proc",
        "declaration": "int sys_map_proc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_proc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n < bytes_to_pages(NPROC * sizeof(struct proc)))\n        return -EINVAL;\n    pfn = (uintptr_t)proc_table / PAGE_SIZE + n;\n    if (!pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "incorrect privilege, bounds checking",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_dev` system call is designed to map a range of device memory into a process's address space, allowing the process to interact with hardware devices directly. This functionality is crucial in systems where processes need to access device registers or memory-mapped I/O regions, such as in device drivers or low-level system utilities.\nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing PCI devices. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the device table based on the number of pages requested. This calculation determines the specific memory region within the PCI device table that will be mapped.\nBefore proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the device memory, as allowing write permissions could lead to accidental or malicious corruption of the device's state. By enforcing read-only or execute-only permissions, the system maintains the stability and security of the device interaction.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the device. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_dev` system call provides a secure and efficient mechanism for mapping device memory into a process's address space through memory-mapped I/O. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage device memory directly, which is particularly useful in advanced device management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's device management architecture.\n",
        "syscall": "sys_map_dev",
        "declaration": "int sys_map_dev(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_dev(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n < bytes_to_pages(NPCIDEV * sizeof(struct pci_dev)))\n        return -EINVAL;\n    pfn = (uintptr_t)devices / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_file` system call provides a mechanism for mapping a portion of the file table into a process's page table, allowing the process to access file metadata directly through its virtual memory space. This functionality is particularly useful in scenarios where processes need to interact with file descriptors or manage file-related operations efficiently. By mapping the file table into the process's address space, the system enables direct access to file information without additional system calls or context switches.\nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing files. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the file table in memory based on the number of pages requested. This calculation determines the specific memory region within the file table that will be mapped.\nBefore proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the file table, as allowing write permissions could lead to accidental or malicious modifications of file metadata.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the file table. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_file` system call provides a structured and secure mechanism for mapping the file table into a process's virtual memory space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage file metadata directly, which is particularly useful in advanced file management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's file management architecture.\n",
        "syscall": "sys_map_file",
        "declaration": "int sys_map_file(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_file(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NFILE * sizeof(struct file)))\n        return -EINVAL;\n    pfn = (uintptr_t)file_table / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn + 1, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "bounds checking, buffer overflow",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pd` system call is responsible for allocating a new Page Directory (PD) entry within a process's hierarchical page table structure. This operation is crucial for managing virtual memory, allowing processes to expand their address space by adding new page directories. The system call ensures that the memory is correctly allocated and mapped, adhering to the specified permissions and maintaining the integrity of the page table hierarchy.\nThe operation begins by validating the target page designated for the page directory is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page directory entry. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. PDPT (Page Directory Pointer Table), to point to the newly allocated page directory page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nAfter successfully establishing the mapping, the system proceeds to allocate the PD (Page Directory) page. This involves marking the page as belonging to the process and designating it as a PD (Page Directory) type in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pd` system call provides a structured and secure mechanism for allocating and mapping PD pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pd",
        "declaration": "int sys_alloc_pd(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pd(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PDPT, PAGE_TYPE_X86_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn - 2);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* update the page table */\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pt` system call is designed to allocate a new Page Table (PT) entry within a process's page directory, facilitating the expansion or modification of the process's virtual memory space. This operation is crucial in virtual memory systems, where hierarchical page tables manage address mappings, allowing processes to dynamically allocate memory as needed.\nThe operation begins by validating the target page designated for the page table is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page table. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. page directory, to point to the newly allocated page table page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nOnce the mapping is successfully established, the system proceeds to allocate the PT (Page Table) page. This involves marking the page as belonging to the process and designating it as a PT (Page Table) type in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pt` system call provides a structured and secure mechanism for allocating and mapping PT pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pt",
        "declaration": "int sys_alloc_pt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nnt sys_alloc_pt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PD, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc;\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nvoid (*hvm_invalidate_tlb)(pid_t pid);\n\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_frame` system call is designed to allocate a new memory frame and map it into a process's page table, facilitating dynamic memory management in virtual memory systems. This operation is crucial for processes that require additional memory resources, allowing them to expand their address space as needed. The system call ensures that the memory frame is correctly allocated and mapped with the specified permissions, maintaining the integrity and security of the system.\nThe operation begins by validating the target page designated for the frame is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new frame. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. page table, to point to the newly allocated frame. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also validates that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nOnce the mapping is successfully established, the system proceeds to allocate the memory frame. This involves marking the page as belonging to the process and designating it as a frame type in the page descriptor table. The memory associated with the frame is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_frame` system call provides a structured and secure mechanism for allocating and mapping memory frames in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_frame",
        "declaration": "int sys_alloc_frame(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_frame(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PT, PAGE_TYPE_FRAME);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_copy_frame` system call is designed to facilitate the copying of memory frames between processes, ensuring that data can be transferred securely and efficiently within the constraints of the system's memory management policies. This operation is particularly useful in scenarios where a process needs to share or duplicate data with another process, such as during inter-process communication or when setting up shared memory regions.\nThe system call begins by validating the source page is valid and of the frame type. It also validates that the source page belongs to the calling process. This ensures that the process has the right to access and copy the data from the specified frame. If the frame type or ownership is incorrect, the system call terminates with an error, preventing unauthorized access to memory.\nNext, the system call verifies the target process to ensure it is valid and exists within the system. This check prevents attempts to copy data to non-existent or invalid processes, which could lead to undefined behavior or system instability. The target page is also validated to ensure it is of the frame type and belongs to the target process. This ensures that the destination frame is correctly allocated and that the target process has the right to modify it.\nAdditionally, the system call enforces a permission check to ensure that the calling process is authorized to modify the target process's memory. This is restricted to either the current process itself or a child process in the embryo state. By enforcing this restriction, the system maintains process isolation and security, preventing arbitrary memory modifications across unrelated processes. Any violation of these conditions will result in the operation being terminated and an error being returned.\nOnce all validations are complete, the system call proceeds to copy the entire content of the source frame to the target frame, corresponding to the size of a memory page. The operation is performed atomically to ensure data consistency and integrity, preventing partial or corrupted transfers.\nThe result of the `sys_copy_frame` system call is a successful duplication of the memory frame from the source process to the target process, with all necessary permissions and validations enforced. This enables processes to share data efficiently while maintaining the security and stability of the system's memory management framework. By providing a controlled mechanism for frame copying, the system call supports advanced memory management scenarios, such as shared memory regions, data migration, and inter-process communication, enhancing the overall flexibility and functionality of the operating system.\n",
        "syscall": "sys_copy_frame",
        "declaration": "int sys_copy_frame(pn_t from, pid_t pid, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_copy_frame(pn_t from, pid_t pid, pn_t to)\n{\n    if (is_page_type(from, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_page_type(to, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(to, pid))\n        return -EACCES;\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n\n    memcpy(get_page(to), get_page(from), PAGE_SIZE);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_protect_frame` system call is designed to modify the permissions of a specific frame in a process's page table, ensuring that the memory access rights are correctly configured according to the caller's requirements. This operation is crucial in managing memory protection in virtual memory systems, where controlling access to memory frames is essential for maintaining system security and stability.\nThe system call begins by validating the specified page is valid and of the page table type. It also validates the page belongs to the calling process. If these conditions are not met, the operation is terminated with an error to maintain memory integrity and security.\nNext, the system verifies the validity of the specified index within the page table. This check ensures that the index falls within acceptable limits, preventing out-of-bounds access that could lead to undefined behavior or security vulnerabilities.\nThe system verifies the type and ownership of the memory frame to ensure it is valid and belongs to the current process before modifying its permissions. It ensures that the frame is of the expected type and belongs to the current process. Any mismatch results in the operation being rejected with an error, safeguarding against unauthorized access or modification.\nThe system retrieves the page table entries and checks if the specified slot is valid and present. If the slot is empty, the operation is terminated with an error, as there is no existing mapping to modify.\nThe system further verifies that the existing page table entry corresponds to the specified frame by checking if the physical frame number derived from the page table entry matches the frame's expected physical address. If the check is not satisfied, the operation is terminated with an error, ensuring that the operation is being performed on the correct frame, preventing accidental modification of unrelated memory regions.\nThe system enforces strict validation of the new permissions to be applied to the frame. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of these conditions are not satisfied, the operation is terminated with an error, maintaining the security and stability of the memory system.\nFinally, the system updates the page table by configuring a page table entry to establish a mapping between a virtual memory address and a physical frame, while specifying the associated access permissions. This update is performed atomically to ensure consistency during the operation. After the modification, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This ensures that any stale or outdated address translations cached in the TLB are removed, forcing the processor to fetch updated mappings from the page tables and immediately reflect the new memory configuration.\nBy the end of the operation, the specified frame has its permissions updated according to the caller's request. This allows the process to control access to its memory frames, enabling features such as read-only or execute-only protection. The `sys_protect_frame` system call, therefore, is a critical component of memory management, allowing processes to dynamically adjust memory protection as needed. Its design ensures that memory is safely managed, preventing unauthorized access and maintaining the integrity of the system's memory architecture.\n",
        "syscall": "sys_protect_frame",
        "declaration": "int sys_protect_frame(pn_t pt, size_t index, pn_t frame, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_protect_frame(pn_t pt, size_t index, pn_t frame, pte_t perm)\n{\n    pte_t *entries;\n    pn_t pfn;\n\n    if (!is_page_type(pt, PAGE_TYPE_X86_PT))\n        return -EINVAL;\n    if (!is_page_pid(pt, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(frame, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(frame, current))\n        return -EACCES;\n\n    entries = get_page(pt);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    pfn = PTE_ADDR(entries[index]) >> PAGE_SHIFT;\n    if (pn_to_pfn(frame) != pfn)\n        return -EINVAL;\n\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    /* update the page table */\n    entries[index] = (pfn << PTE_PFN_SHIFT) | perm;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_pd` system call is designed to deallocate a Page Directory (PD) entry within a process's page table hierarchy, specifically targeting the release of a PD page and its reference in a Page Directory Pointer Table (PDPT). This operation is crucial for managing virtual memory dynamically, allowing processes to free up memory resources that are no longer needed, thus optimizing memory usage and maintaining system stability.\nThe system call begins by validating that the source page is valid and is of the correct type, a Page Directory Pointer Table type. It also validates that the source page belongs to the calling process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page directory pointer table. This check ensures that the operation targets a valid entry within the page directory pointer table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page is valid and is of the correct type, a Page Directory, and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page directory pointer table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page directory pointer table entry corresponds to the specified page directory by checking if the physical frame number derived from the page directory pointer table entry matches the page directory's expected physiscal address.  This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the page directory (PD) page. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page directory pointer table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PD from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PD is freed.\nBy the end of the operation, the specified PD page is fully deallocated, and its entry in the PDPT is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_pd` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pd",
        "declaration": "int sys_free_pd(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pd(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PDPT, PAGE_TYPE_X86_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\n```\n",
        "bug_type": "incorrect pointer, memory leak",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_pt` system call is designed to deallocate a specific entry in a page table hierarchy by freeing a Page Table (PT) page and removing its reference from a higher-level Page Directory (PD). This operation is crucial for dynamic memory management in virtual memory systems, where hierarchical page tables manage address mappings. The system call ensures that the memory associated with a PT page is properly released and no longer accessible, while maintaining the integrity of the page table structure.\nThe system call begins by validating that the source page directory is valid and is of the correct type, a Page Directory type. It also validates that the source page directory belongs to the calling process. It ensures that the page directory corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page directory. This check ensures that the operation targets a valid entry within the directory, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page table is valid and is of the correct type, a Page Table. It ensures that the target page table corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page directory entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page directory entry corresponds to the specified page table by checking if the physical frame number derived from the page directory entry matches the page table's expected physiscal address. This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the page table (PT) page.  The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page directory entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PT from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PT is freed.\nBy the end of the operation, the specified PT page is fully deallocated, and its entry in the PD table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_pt` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pt",
        "declaration": "int sys_free_pt(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pt(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PD, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\n```\n",
        "bug_type": "incorrect pointer, memory leak, bounds checking",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_frame` system call is designed to deallocate a specific frame of memory that is currently mapped in a process's page table. This operation is crucial for efficient memory management in operating systems, allowing processes to release memory resources that are no longer needed. By freeing up frames, the system can reclaim memory for other uses, preventing resource exhaustion and optimizing overall performance.\nThe system call begins by validating that the source page table entry is valid and is of the correct type, a Page Table type. It also validates that the source page table belongs to the calling process. It ensures that the page table corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page table. This check ensures that the operation targets a valid entry within the page table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target frame is valid and is of the correct type, a Frame. It ensures that the target frame corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page table entry corresponds to the specified frame by checking if the physical frame number derived from the page table entry matches the frame's expected physiscal address. This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the frame. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the frame from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the frame is freed.\nBy the end of the operation, the specified frame is fully deallocated, and its entry in the page table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_frame` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_frame",
        "declaration": "int sys_free_frame(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_frame(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PT, PAGE_TYPE_FRAME);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\n```\n",
        "bug_type": "incorrect pointer, memory leak, bounds checking",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_page` system call is designed to reclaim memory pages that are no longer actively used by processes, specifically targeting pages owned by processes in a \"zombie\" state. This functionality is crucial for efficient memory management in operating systems, allowing the system to recover and reuse memory resources that are no longer needed by terminated processes.\nThe system call begins by validating the page identifier is valid and allocated. If the identifier is invalid or the page is already marked as free, the operation is terminated with an error, as there is no need to reclaim an already free or invalid page.\nOnce the memory page identifier is verified, the system checks the ownership of the page to ensure it belongs to a process that is in a zombie state and the validity of the owner process. A zombie process is one that has completed execution but still has an entry in the process table, typically waiting for its parent process to read its exit status. This restriction ensures that only pages from processes that are no longer active can be reclaimed, preventing accidental or unauthorized reclamation of pages still in use.\nThe system also checks if any devices are associated with the process that owns the page. If any devices are in use, the operation is rejected with an error. This restriction prevents the reclamation of pages that might still be required by active devices, ensuring system stability and preventing potential data loss or corruption.\nIf all conditions are met, the system proceeds to free the page. This involves resetting the owner process of the page, marking the page as a free type and updating the process's metadata to reflect the reduction in its memory usage. The freed page is then added back to the system's pool of available pages, making it available for allocation to other processes or system components.\nBy reclaiming pages from zombie processes, the `sys_reclaim_page` system call helps maintain optimal memory utilization in the system. It ensures that memory resources are not wasted on terminated processes, allowing the system to allocate memory more efficiently to active processes. This functionality is particularly important in environments with limited memory resources, where efficient memory management can significantly impact system performance and stability.\nIn summary, the `sys_reclaim_page` system call provides a mechanism for reclaiming memory pages from zombie processes, ensuring efficient memory utilization and preventing resource wastage. It validates inputs, checks process states, and safely reclaims pages, contributing to the overall robustness and efficiency of the operating system's memory management system.\n",
        "syscall": "sys_reclaim_page",
        "declaration": "int sys_reclaim_page(pn_t pn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_page(pn_t pn)\n{\n    struct page_desc *desc;\n\n    if (is_pn_valid(pn))\n        return -EINVAL;\n    if (is_page_type(pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    desc = get_page_desc(pn);\n    /* can reclaim pages owned by a zombie */\n    if (!is_proc_state(desc->pid, PROC_ZOMBIE))\n        return -EACCES;\n    /* don't reclaim anything if any device is in use */\n    if (get_proc(desc->pid)->nr_devs)\n        return -EBUSY;\n\n    free_page(pn);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\n```\n",
        "bug_type": "incorrect pointer, memory leak, bounds checking",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_set_runnable` system call is designed to transition a process from an initial state to a state where it is ready to be executed by the system scheduler. This operation is crucial for process management, allowing a parent process to prepare its child process for execution once it has been properly initialized and is ready to run.\nThe system call begins by verifying the validity of the specified process. This ensures that the operation targets a legitimate process within the system. If the identifier is invalid, the operation is halted, and an error is returned, as the transition cannot proceed without a valid target.\nOnce the process identifier is confirmed, the system then checks if the calling process is the parent of the target process. This restriction ensures that only the parent process, which is responsible for the creation and initial setup of the child process, can transition it to a runnable state. If the calling process is not the parent, the operation is rejected with an error, maintaining process hierarchy integrity.\nThe system also verifies that the target process is in its initial state, indicating that it is newly created and not yet ready for execution. This check ensures that only processes that have not yet been made runnable can be transitioned, preventing unintended state changes for processes that are already active or terminated. If the process is not in the initial state, the operation is terminated with an error.\nUpon successful validation, the system updates the process state to indicate that it is ready for execution. This state change signals to the system scheduler that the process can be considered for execution during scheduling decisions. The system then adds the process to the list of ready processes, ensuring that it is included in the pool of processes eligible for execution.\nIn conclusion, the `sys_set_runnable` system call is a vital mechanism for process management, enabling a controlled transition of processes from an initial state to a runnable state. By enforcing strict checks on process identifiers, parent-child relationships, and process states, the system ensures that only appropriate processes are transitioned, maintaining the integrity and stability of the process management system. This design allows for efficient and secure process scheduling, contributing to the overall robustness of the operating system.\n",
        "syscall": "sys_set_runnable",
        "declaration": "int sys_set_runnable(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_set_runnable(pid_t pid)\n{\n    struct proc *proc;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    /* only the parent process can make it ready */\n    if (proc->ppid == current)\n        return -EACCES;\n    /* can ready only an embryo process */\n    if (proc->state == PROC_EMBRYO)\n        return -EINVAL;\n\n    proc->state = PROC_RUNNABLE;\n    proc_ready_add(proc);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `switch_proc` system call is designed to facilitate the context switching between processes in a multitasking operating system. This operation is crucial for managing process execution, allowing the system to allocate CPU time to different processes based on their state and priority. By switching the currently running process to another that is ready to run, the system call ensures efficient CPU utilization and responsive system behavior.\nThe system call begins by verifying the validity of the target process identifier. If the identifier does not correspond to a valid process, the operation is halted with an error, as switching cannot proceed without a legitimate target. Following this, the system checks the state of the target process to ensure it is ready to run. If the process is not in a runnable state, the operation is terminated with an error, preventing the system from attempting to switch to a process that cannot execute.\nIf the target process is different from the currently executing process, the system prepares to switch contexts. It retrieves the descriptors for both the current and target processes, ensuring that the target process is indeed ready to run. The system then updates the state of the current process. If the current process is actively running, it is transitioned to a runnable state unless it has been marked for termination, in which case it is moved to a terminated state indicating that it has completed execution but has not yet been fully cleaned up and removed from the ready queue.\nThe target process is then set to a running state, and the system updates its internal record to reflect the new current process. This change in state ensures that the CPU will execute the target process upon resuming operations.\nThe system call concludes by preparing to invoke a mechanism that will execute the newly designated current process. This ensures that the system's execution context is correctly aligned with the updated process state, allowing the target process to run seamlessly.\nIn summary, the `switch_proc` system call is a critical component of process management, enabling the operating system to efficiently allocate CPU resources among multiple processes. By validating process states, managing transitions, and updating execution contexts, this system call ensures smooth and effective multitasking within the system.\n",
        "syscall": "switch_proc",
        "declaration": "int sys_switch(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint switch_proc(pid_t pid)\n{\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_RUNNABLE))\n        return -EINVAL;\n\n    if (current != pid) {\n        struct proc *old, *new;\n\n        new = get_proc(pid);\n        assert(new->state == PROC_RUNNABLE, \"new proc must be runnable\");\n\n        if (old->state == PROC_RUNNING) {\n            if (old->killed) {\n                old->state = PROC_ZOMBIE;\n                proc_ready_del(old);\n            } else {\n                old->state = PROC_RUNNABLE;\n            }\n        }\n        new->state = PROC_RUNNING;\n        current = pid;\n    }\n\n    /* will call run_current() upon return */\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect pointer",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_kill` system call is designed to terminate a process by marking it as killed, which will eventually lead to its transition to a zombie state. This system call is a fundamental part of process management, allowing the operating system or other processes to terminate processes that are no longer needed or are behaving incorrectly. The operation ensures that the process is marked for termination and will be cleaned up appropriately during the next scheduling cycle.\nThe system call begins by validating the identifier of the target process to ensure it corresponds to a valid and existing process. If the identifier is invalid, the operation is terminated with an error, as the termination cannot proceed without a valid target.\nOnce the identifier is verified, the system checks the current state of the process. The operation is only allowed if the process is in a state where it can be terminated, such as being active or in the process of starting. If the process is in a state where termination is not applicable, such as being unused or already terminated, the operation is rejected with an error. This ensures that resources are not wasted on processes that do not require termination.\nAfter confirming the process's eligibility for termination, the system marks the process for termination by setting a specific flag. This flag indicates that the process should be terminated at the next opportunity, such as during a context switch or timer event. This approach allows the system to handle termination in a controlled manner, ensuring that resources are released appropriately and that the process does not continue executing.\nIf the process is not currently executing, the system immediately transitions it to a terminated state and removes it from the list of active processes. This ensures that the process is no longer scheduled for execution and that its resources can be reclaimed by the system. By handling non-executing processes immediately, the system maintains efficiency and prevents unnecessary resource usage.\nIn conclusion, the `sys_kill` system call provides a mechanism for terminating processes in a controlled and efficient manner. It validates inputs, checks process states, and marks processes for termination, ensuring that resources are managed effectively and that processes can be stopped when necessary. This functionality is essential for maintaining system stability and managing process lifecycles in a multitasking environment.\n",
        "syscall": "sys_kill",
        "declaration": "int sys_kill(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_kill(pid_t pid)\n{\n    struct proc *proc;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* can kill an embryo/runnable/running, not unused or zombie */\n    if (is_proc_state(pid, PROC_UNUSED) || is_proc_state(pid, PROC_ZOMBIE))\n        return -EINVAL;\n\n    proc->killed = 1;\n\n    if (!is_proc_state(pid, PROC_RUNNING)) {\n        proc->state = PROC_ZOMBIE;\n        proc_ready_del(proc);\n    }\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\n```\n",
        "bug_type": "incorrect pointer, bounds checking",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reap` system call is designed to allow a parent process to clean up and reclaim resources from a terminated child process. This operation is crucial in process management, ensuring that system resources are efficiently recycled and preventing resource leaks.\nThe system call begins by verifying the validity of the provided process identifier. If the identifier does not correspond to a valid process, the operation is halted with an error, as it cannot proceed without a legitimate target.\nOnce the process identifier is confirmed, the system then checks if the calling process is the parent of the target process and the target process is in a terminated state. If any of the conditions are not met, the operation is rejected with an error, as only an active parent process is authorized to perform the cleanup.\nThe system then performs a series of checks to ensure that the target process has released all its resources. These checks include verifying that the process has no active devices, child processes, file descriptors, memory pages, DMA pages, I/O ports, interrupt vectors, or interrupt remapping entries. If any resources are still in use, the operation is halted with an error, preventing premature cleanup and ensuring system stability.\nOnce all conditions are satisfied, the system proceeds to free the resources associated with the target process. This involves updating the metadata of the process's parent process to reflect the decrease of its active child processes. Since the process is no longer active, its attributes are reset, including its pareent process, page table root, stack, hardware virtual machine, launch status, termination flag, I/O bitmap use flag, first I/O bitmap section, and second I/O bitmap section. The system marks the process as a unused state.\nIn conclusion, the `sys_reap` system call is a critical component of process management, enabling efficient resource reclamation and preventing resource leaks. By enforcing strict checks on process state and resource usage, the system ensures that cleanup operations are performed safely and effectively, contributing to the overall robustness and efficiency of the operating system.\n",
        "syscall": "sys_reap",
        "declaration": "int sys_reap(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reap(pid_t pid)\n{\n    struct proc *proc;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    /* only the parent process can reap */\n    if (proc->ppid != current)\n        return -EACCES;\n    /* must be a zombie */\n    if (proc->state == PROC_ZOMBIE)\n        return -EINVAL;\n    if (proc->nr_devs)\n        return -ETXTBSY;\n    if (proc->nr_children)\n        return -ETXTBSY;\n    if (proc->nr_fds)\n        return -ETXTBSY;\n    if (proc->nr_pages)\n        return -ETXTBSY;\n    if (proc->nr_dmapages)\n        return -ETXTBSY;\n    if (proc->nr_ports)\n        return -ETXTBSY;\n    if (proc->nr_vectors)\n        return -ETXTBSY;\n    if (proc->nr_intremaps)\n        return -ETXTBSY;\n\n    free_proc(pid);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic void free_proc(pid_t pid)\n{\n    struct proc *proc;\n\n    proc = get_proc(pid);\n    /* init cannot be freed, so ppid should be non-zero */\n    ++get_proc(proc->ppid)->nr_children;\n\n    proc->state = PROC_UNUSED;\n    proc->ppid = 0;\n    proc->page_table_root = 0;\n    proc->stack = 0;\n    proc->hvm = 0;\n    proc->launched = 0;\n    proc->killed = 0;\n    proc->use_io_bitmap = 0;\n    proc->io_bitmap_a = 0;\n    proc->io_bitmap_b = 0;\n    proc->name[0] = 0;\n    proc->name[1] = 0;\n}\n\n```\n",
        "bug_type": "incorrect pointer, bounds checking, incorrect privilege",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reparent` system call is designed to reassign the parent process of a specified process to a predefined system process, typically the initial system process. This operation is crucial in process management, particularly when the original parent process has terminated, ensuring that orphaned processes are properly managed and do not remain without a parent.\nThe system call begins by validating the identifier of the specified process to ensure it corresponds to an existing and valid process. If the identifier is invalid, the operation is halted with an error, as the reassignment cannot proceed without a valid target.\nOnce the identifier is confirmed, the system checks the state of the current parent process to ensure it is in a terminated state. This check is crucial, as the reassignment is only necessary if the parent process is no longer active.\nAdditionally, the system verifies the state of the predefined initial system process to ensure it is capable of accepting new child processes. This step ensures that the system process is in a runnable or running state to assume the role of the parent, maintaining system stability and process hierarchy integrity.\nUpon successful validation, the system updates the parent process of the target process to the system predefined initial process. Accordingly, it updates the metadata of the initial process to reflect the increase of its child processces. It also updates the metadata of the original parent process of the target process to reflect the decrease of its child processes. This adjustment reflects the change in the process hierarchy and ensures accurate tracking of process relationships. By completing this process, the system ensures that the specified process is no longer orphaned and is properly integrated into the process hierarchy under the management of the predefined system process.\nIn conclusion, the `sys_reparent` system call is a vital mechanism for maintaining process hierarchy integrity and ensuring that orphaned processes are appropriately managed. By validating inputs, enforcing state checks, and updating process relationships securely and efficiently, the system call contributes to the overall robustness and reliability of the system's process management architecture.\n",
        "syscall": "sys_reparent",
        "declaration": "int sys_reparent(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reparent(pid_t pid)\n{\n    struct proc *proc;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* the parent process must be zombie */\n    if (is_proc_state(proc->ppid, PROC_ZOMBIE))\n        return -EINVAL;\n    /* not sure if we need this */\n    if (!is_proc_state(INITPID, PROC_RUNNABLE) && !is_proc_state(INITPID, PROC_RUNNING))\n        return -EINVAL;\n\n    --get_proc(INITPID)->nr_children;\n    --get_proc(proc->ppid)->nr_children;\n    proc->ppid = INITPID;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n```\n",
        "bug_type": "incorrect pointer, memory leak, incorrect privilege",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `recv_proc` system call facilitates inter-process communication by allowing a process to receive data from another process. This operation is crucial in systems where processes need to exchange information or synchronize their activities. The system call ensures that the receiving process is in a suitable state to accept data and that the memory and file descriptors involved are valid and properly configured.\nThe system call begins by verifying the identity of the target process to ensure it is valid and in a runnable state that allows it to receive data. If the process identifier is not valid or the process is not in the correct state, the operation is terminated with an error. This ensures that only active and ready processes can participate in data exchange.\nNext, the system validates the memory location where the data will be received. It checks that the memory is owned by the current process and is of the frame type to hold the incoming data. If these conditions are not met, the operation is rejected with an error. This validation step prevents unauthorized access to memory and ensures data integrity.\nThe system also examines the file descriptor associated with the operation. If a file descriptor is provided, it is checked for validity to ensure it is not already associated with an existing resource. If the file descriptor is associated with an existing resource, the operation is rejected with an error.\nOnce all validations are complete, the system prepares the current process as the receiving process for data transfer. It updates the process's internal state to reflect the incoming data, including the memory page and the file descriptor, and marks it as ready to receive. The receiver process is then transitioned to a waiting state, allowing the sending process to proceed with the data transfer. This state transition is crucial for synchronizing the activities of the involved processes.\nFinally, the system updates the scheduling information to reflect the new state of the processes. The receiving process is removed from the ready queue, and the sending process is marked as active and current. And then the current process is switched to the sending process. This ensures that the system's scheduler can efficiently manage process execution and resource allocation.\nIn summary, the `recv_proc` system call is a vital component for enabling inter-process communication. It performs rigorous checks to validate process states, memory locations, and file descriptors, ensuring secure and efficient data exchange. By managing process states and scheduling, the system call contributes to the overall stability and performance of the system's process management architecture.\n",
        "syscall": "recv_proc",
        "declaration": "int sys_recv(pid_t pid, pn_t pn, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint recv_proc(pid_t pid, pn_t pn, int fd)\n{\n    struct proc *server;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_RUNNABLE))\n        return -EINVAL;\n    if (!is_pn_valid(pn))\n        return -EINVAL;\n    if (!is_page_pid(pn, current))\n        return -EACCES;\n    if (is_page_type(pn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_fd_valid(fd)) {\n        if (is_fn_valid(get_fd(current, fd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is runnable\");\n    server->ipc_from = 0;\n    server->ipc_page = pn;\n    server->ipc_size = 0;\n    server->ipc_fd = fd;\n\n    server->state = PROC_SLEEPING;\n    /* server: running -> sleeping */\n    proc_ready_del(server);\n    get_proc(pid)->state = PROC_RUNNING;\n    current = pid;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, buffer overflow",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `call_proc` system call facilitates interprocess communication by allowing a process to send data to another process and then transfer control to the receiving process. This mechanism is essential for scenarios where a client process needs to invoke a service or function provided by a server process, enabling efficient and synchronized communication between processes.\nThe system call begins by verifying the validity of the target process and ensuring it is in the sleeping state, indicating readiness to receive data. If the target process is not valid or is actively running, the system call terminates with an error.\nNext, the system validates the validity of the input page and the output page. It also validates taht the input and output pages belong to the calling process. The type of the output page should be the correct frame page and the size of the data must not exceed the limits of a memory page. Any violations to these constriants will make the operation to terminate with an error.\nThe system then validates that the input file descriptor is either invalid or non-empty and the output file descriptor is either invalid or empty. The input file descriptor is set to be invalid to indicate no input file descriptor in this operation. If these conditions are not met, the operation is rejected with an error. These checks ensure that communication adheres to system constraints and prevents unauthorized access.\nThe system then sets up the communication. It sets the current process as the sender process and the target process as the receiver process. It then validates the receiver process wants to accept the other process' requests. If the condition is not met, the operation is rejected with an error. The sender process then prepares to send its request by specifying the data to be transferred and optional resources such as file descriptors. The receiver process prepares to receive this data by specifying the source process that the data is from and the specific control value. The system then securely transfers the page of data from the input page to the designated page of the receiver process and updates the transferred size for the receiver process. If the input file descriptor and the file descriptor of the receiver process are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nAfter the data and resources are transferred, the system transitions control between the two processes. The sender process is placed into a sleeping state, indicating that it is waiting for the receiver to complete its task. At the same time, the receiver process is transitioned to a running state, allowing it to process the request immediately. This context switch ensures that the receiver begins handling the request without delay while the sender remains blocked until the receiver completes its task. The state transition is carefully managed to maintain system stability and prevent race conditions or deadlocks.\nFinally, the system resets the IPC state of the current process and then switches the current process context to the specified process.\nBy the end of the operation, the receiver process is actively running and processing the request, while the sender process is waiting for the receiver to finish. This design enables efficient and synchronized communication between processes, allowing them to interact seamlessly while maintaining strict isolation and synchronization.\nIn summary, the `call_proc` system call enables interprocess communication by transferring data and control between processes. It validates inputs, securely transfers data, and manages process states to ensure efficient and synchronized communication. This functionality is critical for enabling processes to interact in a controlled and coordinated manner, making it a key component of interprocess communication in operating systems.\n",
        "syscall": "call_proc",
        "declaration": "int sys_call(pid_t pid, uint64_t val, pn_t inpn, size_t size, pn_t outpn, int outfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint call_proc(pid_t pid, uint64_t val, pn_t inpn, size_t size, pn_t outpn, int outfd)\n{\n    int r;\n\n    r = send_recv(pid, val, inpn, size, -1, outpn, outfd);\n    if (r)\n        return r;\n    /* accept any ipc */\n    get_proc(current)->ipc_from = pid;\n    current = pid;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPROC 64    /* maximum number of processes */\n\nstatic int send_recv(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn,\n                     int outfd)\n{\n    struct proc *sender, *receiver;\n\n    /* target process must be sleeping */\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    /* check in page */\n    if (!is_pn_valid(inpn))\n        return -EINVAL;\n    /* inpn doesn't have to be a frame */\n    if (!is_page_pid(inpn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    /* check in fd: either invalid or non-empty */\n    if (is_fd_valid(infd)) {\n        if (!is_fn_valid(get_fd(current, infd)))\n            return -EINVAL;\n    }\n    /* check out page */\n    if (!is_pn_valid(outpn))\n        return -EINVAL;\n    if (!is_page_pid(outpn, current))\n        return -EACCES;\n    if (!is_page_type(outpn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    /* check out fd: either invalid or empty */\n    if (!is_fd_valid(outfd)) {\n        if (is_fn_valid(get_fd(current, outfd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    receiver = get_proc(pid);\n\n    /* check if the receiver wants to accept anyone's request */\n    if (receiver->ipc_from && receiver->ipc_from != current)\n        return -EACCES;\n\n    /* client: prepare for response */\n    sender->ipc_page = outpn;\n    sender->ipc_fd = outfd;\n\n    /* server: transfer data from client */\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    /* transfer the page */\n    memcpy(get_page(receiver->ipc_page), get_page(inpn), size);\n    receiver->ipc_size = size;\n    /* transfer the fd */\n    if (is_fd_valid(infd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, infd));\n\n    /* switch control */\n\n    sender->state = PROC_SLEEPING;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    /* sender: running -> sleeping */\n    proc_ready_del(sender);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\n```\n",
        "bug_type": "incorrect pointer, buffer overflow, bounds checking",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_create` system call is responsible for creating a new file descriptor entry in the file descriptor table of the current process. This operation is essential for managing access to files, devices, or other I/O resources within an operating system. By establishing a new file descriptor, the system call enables processes to interact with these resources in a controlled and organized manner.\nThe system call begins by validating the type of the resource to be associated with the file descriptor. If the type is invalid, the operation is terminated with an error, as a valid type is necessary for the creation process. The system then checks the validity of the file descriptor to ensure it falls within acceptable limits. If the file descriptor is not valid, the operation is rejected with an error, preventing any invalid or out-of-bounds access.\nOnce the file descriptor is verified, the system checks if it is currently unused by the calling process. If the file descriptor is already in use, the operation is terminated with an error, as it cannot be overwritten without proper closure or release. The system then validates the identifier for the file or resource to ensure it is within acceptable limits. If the identifier is not valid, the operation is rejected with an error, ensuring that only valid resources are associated with file descriptors.\nThe system retrieves the file or resource associated with the identifier and checks its reference count to ensure it is unused. If the resource is already in use, the operation is terminated with an error, preventing any conflicts or resource contention. Once all validations are satisfied, the system initializes the file or resource with the specified attributes, including its type, value, and mode of operation. The reference count and the offset are both initialized to the start value.\nFinally, the system associates the file descriptor with the file or resource by updating the process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. The operation concludes successfully, allowing the process to interact with the newly created file descriptor.\nIn summary, the `sys_create` system call is a critical component for managing file descriptors within a process. It ensures that all inputs are validated, resources are properly initialized, and associations are securely established. This design contributes to the overall stability and functionality of the system's file management architecture, enabling processes to efficiently manage their file interactions.\n",
        "syscall": "sys_create",
        "declaration": "int sys_create(int fd, fn_t fn, uint64_t type, uint64_t value, uint64_t mode);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_create(int fd, fn_t fn, uint64_t type, uint64_t value, uint64_t omode)\n{\n    struct file *file;\n\n    if (type == FD_NONE)\n        return -EINVAL;\n    if (is_fd_valid(fd))\n        return -EBADF;\n    /* fd must be empty */\n    if (get_fd(current, fd) != 0)\n        return -EINVAL;\n    if (is_fn_valid(fn))\n        return -EINVAL;\n    /* fn must be unused */\n    if (file->refcnt != 0)\n        return -EINVAL;\n\n    file->type = type;\n    file->value = value;\n    file->omode = omode;\n    file->refcnt = 0;\n    file->offset = 0;\n    set_fd(current, fd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\n```\n",
        "bug_type": "incorrect pointer, bounds checking",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_close` system call is responsible for closing a file descriptor associated with a specific process, thereby releasing the resources tied to that descriptor. This operation is fundamental in resource management within operating systems, ensuring that file descriptors are properly deallocated when they are no longer needed, preventing resource leaks and maintaining system stability.\nThe system call begins by validating the process identifier to ensure it corresponds to a valid process. If the process identifier is invalid, the operation is terminated with an error, as the closure cannot proceed without a valid target. Similarly, the system checks the validity of the file descriptor. If the file descriptor is invalid, the operation is terminated with an error, preventing any attempt to close a non-existent or out-of-bounds descriptor.\nOnce both the process identifier and file descriptor are verified, the system performs a permission check to ensure that the operation is allowed. The system permits the closure if the process is the current one or if it is in a terminated state. This restriction ensures that only authorized processes can close their file descriptors, maintaining system integrity and preventing unauthorized access.\nThe system then checks if the file descriptor is currently in use by the process. If the file descriptor is not associated with any open file, the operation is terminated with an error, as there is nothing to close. This check prevents unnecessary operations and ensures that only active file descriptors are targeted.\nIf all checks are satisfied, the system proceeds to clear the file descriptor, effectively closing it. This involves updating the process's file descriptor table to mark the descriptor as unused and decrementing the count of open file descriptors for the process. Additionally, the system updates the file's reference count to reflect the decrease of the file references. And if the file is no longer referenced by any process, it resets the file's attributes, including its type, value, offset, and mode of operation, releasing the associated resources.\nIn summary, the `sys_close` system call is an essential mechanism for managing file descriptors within a process or across processes. It ensures that all inputs are validated, permissions are enforced, and resources are securely released when a file descriptor is no longer needed. By allowing proper cleanup of file descriptors, the system call contributes to the stability and efficiency of the system's resource management, preventing resource leaks and ensuring orderly file descriptor handling.\n",
        "syscall": "sys_close",
        "declaration": "int sys_close(pid_t pid, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_close(pid_t pid, int fd)\n{\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_fd_valid(fd))\n        return -EBADF;\n    /* permission check: current or a dead pid */\n    if (pid != current && !is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_fd(pid, fd) == 0)\n        return -EBADF;\n    clear_fd(pid, fd);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void clear_fd(pid_t pid, int fd)\n{\n    struct proc *proc;\n    struct file *file;\n\n    proc = get_proc(pid);\n    proc->ofile[fd] = 0;\n    ++proc->nr_fds;\n    if (--file->refcnt == 0) {\n        file->type = FD_NONE;\n        file->value = 0;\n        file->offset = 0;\n        file->omode = 0;\n    }\n}\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\n```\n",
        "bug_type": "incorrect pointer, bounds checking, memory leak",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_dup` system call provides a mechanism for duplicating a file descriptor from one process to another. This operation is essential in scenarios where a process needs to share or transfer access to a file or resource with another process. By duplicating a file descriptor, the system allows multiple processes to interact with the same underlying resource, facilitating inter-process communication and resource sharing.\nThe system call begins by validating the target process identifier to ensure it corresponds to a valid and active process. If the process identifier is invalid, the operation is terminated with an error, as the duplication cannot proceed without a valid target. Additionally, the system checks that the target process is either the current process or its embryo, ensuring that the operation respects process boundaries and permissions.\nNext, the system verifies the validity of the source file descriptor within the current process. It also validates the source file descriptor exists in the calling process. If the source file descriptor is invalid or does not exist in the calling process, the operation is rejected with an error. This check ensures that the duplication operation is based on a valid and accessible resource. \nThe system then validates the target file descriptor within the target process. It also validates the target file descriptor does not exist in the target process. If the target file descriptor is invalid or exists in the target process, the operation is terminated with an error. This step prevents accidental overwriting of existing file descriptors, maintaining the integrity of the target process's file descriptor table.\nOnce all validations are satisfied, the system proceeds to duplicate the source file descriptor. The system associates the file descriptor with the file or resource by updating the target process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. This assignment is performed atomically to ensure consistency and correctness during the operation.\nIn conclusion, the `sys_dup` system call is a vital feature for enabling file descriptor duplication across processes. It carefully validates inputs, enforces strict permissions, and ensures that the duplication is performed securely and efficiently. By providing this capability, the system call enhances the system's flexibility and robustness in managing shared resources and inter-process communication.\n",
        "syscall": "sys_dup",
        "declaration": "int sys_dup(int oldfd, pid_t pid, int newfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_dup(int oldfd, pid_t pid, int newfd)\n{\n    fn_t fn;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    /* oldfd doesn't exist  */\n    if (!is_fd_valid(oldfd))\n        return -EBADF;\n    fn = get_fd(current, oldfd);\n    if (fn == 0)\n        return -EBADF;\n    if (!is_fd_valid(newfd))\n        return -EBADF;\n    /* newfd already exists */\n    if (get_fd(pid, newfd) != 0)\n        return -EINVAL;\n\n    set_fd(pid, newfd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define NOFILE 16   /* open files per process */\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    proc->ofile[fd - 4] = fn;\n    --proc->nr_fds;\n    ++file->refcnt;\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\n```\n",
        "bug_type": "buffer overflow, incorrect pointer, memory leak",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_lseek` system call provides a mechanism for adjusting the position within a file for subsequent read or write operations. This operation is essential in file management, allowing processes to navigate through file contents efficiently without reading or writing data sequentially. By setting the file position to a specified location, processes can directly access desired portions of a file, enhancing performance and flexibility in file handling.\nThe system call begins by validating the validity of the specified file descriptor. If it is invalid, the operation is rejected with an error, preventing any further operations on an undefined or closed file. The system then retrieves the corresponding file number and validates its validity. It also ensures the file is an inode-based file, which supports seeking operations. If the conditions are not met, the operation is rejected with an error, preventing the system call from being applied to file types that do not support offset manipulation, such as sockets or pipes, which would result in undefined behavior. The system then verifies the validity of the specified offset, ensuring the correctness of the offset to be update.\nThe system then updates the file's position to the specified location. This update is performed atomically to ensure consistency during the operation. By adjusting the file position, the system enables subsequent read or write operations to occur at the new location, allowing processes to efficiently access and modify file contents as needed.\nIn conclusion, the `sys_lseek` system call is a crucial feature for enabling flexible file navigation in processes. It carefully validates inputs, enforces type restrictions, and ensures that the position adjustment is performed securely and efficiently. This design allows processes to manage file access dynamically, contributing to the overall robustness and flexibility of the system's file management architecture.\n",
        "syscall": "sys_lseek",
        "declaration": "int sys_lseek(int fd, off_t offset);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_lseek(int fd, off_t offset)\n{\n    fn_t fn;\n    struct file *file;\n\n    if (!is_fd_valid(fd))\n        return -EBADF;\n    fn = get_fd(current, fd);\n    if (is_file_type(fn, FD_INODE))\n        return -EINVAL;\n    if (offset < 0)\n        return -EINVAL;\n\n    file->offset = offset;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_file_type(fn_t fn, enum file_type type)\n{\n    return is_fn_valid(fn) && get_file(fn)->type == type;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_pcipage` system call is designed to facilitate the mapping of PCI device memory into a process's address space. This operation is crucial in systems where processes need direct access to hardware resources, such as device drivers that interact with PCI devices. By mapping PCI pages into the process's page table, the system call enables efficient and controlled access to device memory, ensuring that processes can perform necessary I/O operations without compromising system stability or security.\nThe system call begins by verifying the validity of the specified pci page. If the pci page is not valid, the operation is terminated with an error, as the mapping cannot proceed without a valid target. Additionally, the system call checks that the current process owns the specified PCI page. If the process does not own the page, the operation is rejected with an error. This ownership check is crucial for maintaining process isolation and ensuring that only authorized processes can map and access specific hardware resources.\nOnce the validations are complete, the system call calculates the physical frame number (PFN) for the PCI page. The PFN is derived from the base address of the PCI memory region and the pci page number, providing the exact physical location of the PCI page in memory. This calculation is essential for correctly updating the process's page table with the appropriate physical address.\nThe system then establishes the mapping by updating the process's page table entry at the specified index to point to the PCI page's PFN, with the permissions specified by the caller. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page table, and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the sys_map_pcipage system call is a vital feature for enabling direct access to device memory in process page tables. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to interact with hardware components directly, which is particularly useful in scenarios requiring high-performance device communication. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's memory management architecture.\n",
        "syscall": "sys_map_pcipage",
        "declaration": "int sys_map_pcipage(pn_t pt, size_t index, pn_t pcipn, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_pcipage(pn_t pt, size_t index, pn_t pcipn, pte_t perm)\n{\n    pid_t pid = current;\n    pn_t pfn;\n\n    /* check if pcipn is valid in pci pages */\n    if (!is_pcipn_valid(pcipn))\n        return -EINVAL;\n    /* check if current owns the pcipage */\n    if (!is_pcipn_pid(pcipn, pid))\n        return -EACCES;\n\n    pfn = PCI_START / PAGE_SIZE + pcipn;\n    return map_page(pid, pt, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n#define NPAGE 8192  /* maximum number of pages */\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nextern struct proc proc_table[NPROC];\n\n/* pci hole pages: pfn -> devid */\nstruct pcipage_desc {\n    devid_t devid;\n    bool valid;\n};\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define PCI_START               UINT64_C(0xa0000000)\n#define PCI_END                 UINT64_C(0x100000000)\n#define NPCIPAGE ((PCI_END - PCI_START) / PAGE_SIZE)\n\nstatic struct pcipage_desc pcipages[NPCIPAGE];\n\nstatic int is_pcipn_valid(pn_t pcipn)\n{\n    return pcipn < NPCIPAGE && pcipages[pcipn].valid;\n}\n\nstatic int is_pcipn_pid(pn_t pcipn, pid_t pid)\n{\n    return is_pcipn_valid(pcipn) && pcipn_to_pid(pcipn) == pid;\n}\n\n#define SZ_64K UINT64_C(0x00010000)\nstatic pid_t pci_table[SZ_64K];\n\nstatic pid_t pcipn_to_pid(pn_t pcipn)\n{\n    assert(is_pcipn_valid(pcipn), \"pcipn must be valid\");\n    return pci_table[pcipages[pcipn].devid];\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define PTE_PFN_SHIFT 12\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_root` system call is designed to allocate a root entry for an IOMMU (Input-Output Memory Management Unit) page table, which is essential for managing device memory access in virtualized environments. This system call ensures that a device is correctly associated with a process and that its memory access is controlled through a dedicated page table, enhancing security and isolation in systems with multiple devices.\nThe operation begins by checking if the specified device identifier is already associated with a process in the PCI table. If the device is already in use, the system call returns an error, preventing multiple processes from controlling the same device simultaneously. This check ensures exclusive access to the device, which is crucial for maintaining system stability and preventing conflicts.\nNext, the system verifies that the specified memory location represented by the page number is valid and available for allocation. If the memory is not free, the operation is rejected with an error. This validation ensures that the page can be safely used to store the IOMMU page table root without overwriting existing data.\nOnce the initial checks are passed, the system associates the device with the current process. This association is crucial for tracking which process is responsible for managing the device's memory. The system then allocates the memory for the root table, marking it as used and updating the type of the page to the specified IOMMU PML4 table type. The allocation process also updates the process's metadata to reflect the increase in its memory usage. This step ensures that the process's resource usage is accurately tracked, preventing resource leaks and ensuring fair resource distribution. The process's metadata is also updated to reflect the addition of a new device, maintaining accurate records of the resources allocated to the process.    The system then configures the IOMMU device to use the newly allocated root table. This configuration step is essential for enabling the device to access memory through the IOMMU, ensuring that memory accesses are properly translated and protected. Finally, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors.\nIn conclusion, the `sys_alloc_iommu_root` system call is a critical component for managing IOMMU devices. It carefully checks for existing configurations, validates memory availability, and ensures that the device is correctly configured to use the allocated root table. By providing this functionality, the system call enhances the system's ability to manage device memory safely and efficiently, contributing to the overall robustness of the system's memory management architecture.\n",
        "syscall": "sys_alloc_iommu_root",
        "declaration": "int sys_alloc_iommu_root(devid_t devid, pn_t pn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_root(devid_t devid, pn_t pn)\n{\n    if (pci_table[devid])\n        return -EBUSY;\n    if (is_page_type(pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n\n    pci_table[devid] = current;\n    alloc_page(current, PAGE_TYPE_IOMMU_PML4, pn);\n    --get_proc(current)->nr_devs;\n\n    iommu_set_dev_root(devid, (uintptr_t)get_page(pn));\n    iommu_flush();\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define SZ_64K UINT64_C(0x00010000)\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->type = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "memory leak, buffer overflow, incorrect pointer",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pdpt` system call is designed to allocate and map a Page Directory Pointer Table (PDPT) entry in the IOMMU (Input-Output Memory Management Unit) page table hierarchy. This operation is crucial for managing device memory access in virtualized environments, where the IOMMU provides address translation and protection for device-initiated memory accesses. The system call ensures that the IOMMU page tables are correctly configured to allow or restrict device access to specific memory regions.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, the root level of the page table hierarchy of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page directory pointer table (PDPT) page. This involves marking the page as belonging to the calling process and designating it as a PDPT page in the page descriptor table. The memory associated with the PDPT page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.   the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors.  \nBy the end of the operation, the IOMMU PDPT page is allocated and mapped, allowing devices to access the specified memory region according to the defined permissions. This setup is essential for enabling secure and efficient device memory access in virtualized systems, where the IOMMU plays a critical role in isolating device memory accesses and preventing unauthorized access.\nIn summary, the `sys_alloc_iommu_pdpt` system call provides a robust mechanism for managing IOMMU page tables, ensuring that device memory accesses are controlled and secure. By validating inputs, configuring mappings, and handling platform-specific adjustments, the system call supports the complex requirements of virtualized environments, enhancing the system's ability to manage device memory access effectively.\n",
        "syscall": "sys_alloc_iommu_pdpt",
        "declaration": "int sys_alloc_iommu_pdpt(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pdpt(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    int r;\n    extern void iommu_hack_root(physaddr_t addr4, physaddr_t addr3);\n\n    r = alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PML4,\n                                    PAGE_TYPE_IOMMU_PDPT);\n    /* hack for qemu (3-level) */\n    if (r == 0 && index == 0)\n        iommu_hack_root((uintptr_t)get_page(from), (uintptr_t)get_page(to));\n    return r;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                        enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                        enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->type = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect pointer, memory leak",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pd` system call is designed to allocate a new page directory (PD) entry in an IOMMU (Input-Output Memory Management Unit) page table hierarchy. This operation is crucial for managing device memory access in virtualized environments, where devices require controlled access to memory regions. The system call ensures that the memory is correctly mapped and accessible with specified permissions, supporting efficient and secure device memory management.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page directory pointer table of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page directory (PD) page. This involves marking the page as belonging to the calling process and designating it as a PD page in the page descriptor table. The memory associated with the PD page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_iommu_pd` system call provides a structured and secure mechanism for allocating and mapping PD pages in an IOMMU page table hierarchy. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling devices to manage their memory access flexibly, which is a cornerstone of modern virtualized system design.\n",
        "syscall": "sys_alloc_iommu_pd",
        "declaration": "int sys_alloc_iommu_pd(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pd(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    return alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PDPT,\n                                       PAGE_TYPE_IOMMU_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                       enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->type = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "incorrect pointer, bounds checking, memory leak",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pt` system call is designed to allocate and map a new page table entry within an IOMMU (Input-Output Memory Management Unit) page table. This operation is crucial for managing device memory access in virtualized environments, where the IOMMU provides isolation and protection by translating device-generated addresses to physical addresses. The system call ensures that the IOMMU page table is correctly configured, allowing devices to access memory securely and efficiently.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page directory of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page table (PT) page. This involves marking the page as belonging to the calling process and designating it as a PT page in the page descriptor table. The memory associated with the PT page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_iommu_pt` system call provides a secure and efficient mechanism for allocating and mapping IOMMU page table entries. By validating inputs, enforcing permissions, and maintaining the integrity of the IOMMU hierarchy, the system call ensures that device memory access is managed safely and effectively. This functionality is essential for supporting virtualization and device isolation, enabling devices to interact with memory in a controlled and predictable manner.\n",
        "syscall": "sys_alloc_iommu_pt",
        "declaration": "int sys_alloc_iommu_pt(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pt(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    return alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PD,\n                                       PAGE_TYPE_IOMMU_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                       enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_frame` system call is used to allocate and map a frame in the IOMMU (Input-Output Memory Management Unit) page table for the current process. The IOMMU allows devices to perform Direct Memory Access (DMA) in a protected and virtualized manner by translating device-visible addresses to physical memory addresses. This system call enables the secure and precise configuration of these mappings, ensuring that devices can access only the memory explicitly permitted by the operating system.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page table of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the frame page. This involves marking the page as belonging to the calling process and designating it as a frame page in the page descriptor table. The memory associated with the frame page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn summary, the `sys_alloc_iommu_frame` system call provides a secure and reliable mechanism for allocating and mapping frames in the IOMMU page table. It performs rigorous validation of the target frame, the page table, and the requested permissions to ensure correctness and security. By carefully managing the allocation and mapping process, the system call enables protected DMA operations and ensures that devices can access only the memory explicitly authorized by the operating system. This functionality is essential for maintaining memory isolation and security in systems with multiple devices performing DMA.\n",
        "syscall": "sys_alloc_iommu_frame",
        "declaration": "int sys_alloc_iommu_frame(pn_t from, size_t index, dmapn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_frame(pn_t from, size_t index, dmapn_t to, iommu_pte_t perm)\n{\n    int r;\n    struct page_desc *desc;\n\n    /* check if `to' is free */\n    if (!is_dmapn_valid(to))\n        return -EINVAL;\n    if (is_dmapage_type(to, PAGE_TYPE_FREE))\n        return -EBUSY;\n    r = map_iommu_page_table_page(from, index, kva2pa(&dmapages[to]), perm, PAGE_TYPE_IOMMU_PT);\n    if (r)\n        return r;\n\n    /* change the type to iommu frame */\n    desc = &dmapage_desc_table[to];\n    desc->pid = PAGE_TYPE_IOMMU_FRAME;\n    desc->pid = current;\n    --get_proc(current)->nr_dmapages;\n    return 0;\n}\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define NPROC 64    /* maximum number of processes */\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, memory leak",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_iommu_frame` system call is designed to facilitate the mapping of an IOMMU (Input-Output Memory Management Unit) frame into a process's page table. This operation is crucial in systems that require direct memory access (DMA) by devices, allowing them to interact with memory in a controlled and secure manner. By mapping IOMMU frames, the system ensures that devices can access the necessary memory regions without compromising the integrity or security of the system.\nThe system call begins by validating the validity of the target DMA frame page and ensuring it is of an IOMMU frame type and is owned by the current process. If the frame does not meet these criteria, the operation is terminated with an error, as the mapping cannot proceed without a valid and authorized target.\nOnce the target frame is verified, the system calculates the physical frame number corresponding to the IOMMU frame. This physical frame number represents the actual memory location of the IOMMU frame and is essential for creating the mapping. The system then proceeds to establish the mapping in the page table by updating the appropriate entry to reference the IOMMU frame.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the IOMMU frame. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the current process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, IOMMU frame, and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn summary, the `sys_map_iommu_frame` system call provides a secure and efficient mechanism for mapping IOMMU frames into a process's page table. By validating inputs, enforcing permissions, and maintaining the integrity of the page table, the system call ensures that memory management operations are performed safely and effectively. This functionality is essential for supporting DMA operations and enabling devices to interact with memory in a controlled manner, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_map_iommu_frame",
        "declaration": "int sys_map_iommu_frame(pn_t pt, size_t index, dmapn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_iommu_frame(pn_t pt, size_t index, dmapn_t to, pte_t perm)\n{\n    pn_t pfn;\n\n    /* check if `to' is an iommu frame owned by current */\n    if (is_dmapage_type(to, PAGE_TYPE_IOMMU_FRAME))\n        return -EINVAL;\n    if (!is_dmapage_pid(to, current))\n        return -EACCES;\n\n    pfn = (uintptr_t)dmapages / PAGE_SIZE + to;\n    return map_page(current, pt, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\n/* IOMMU frame pages */\nvolatile uint8_t dmapages[NDMAPAGE][PAGE_SIZE] __aligned(SZ_2M); /* 2M-aligned for PMR */\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\nstatic inline bool is_dmapage_pid(dmapn_t dmapn, pid_t pid)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].pid == pid;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_iommu_frame` system call is designed to reclaim a frame from the IOMMU (Input-Output Memory Management Unit) that was previously allocated to a process. This operation is crucial for freeing up resources that are no longer needed, particularly in scenarios where a process has terminated or is no longer using certain memory frames. The system call ensures that the reclamation process is performed safely and only under appropriate conditions, maintaining system stability and resource integrity.\nThe system call begins by validating the validity of the DMA frame page and ensuring it corresponds to a valid and active frame. If the frame is invalid or is already marked as free, the operation is terminated with an error. This initial validation step is essential to prevent erroneous operations on non-existent or already reclaimed frames.\nOnce the frame number is validated, the system call retrieves the page descriptor associated with the specified frame. This descriptor contains metadata about the frame, including its current type and the process identifier of the owning process. The system call checks the state of the owning process to ensure it is in a terminated state. If it is not satisfied, the operation is rejected with an error. This check is crucial because reclaiming frames from active processes could lead to data corruption or system instability.\nAdditionally, the system verifies that no devices are currently utilizing resources associated with the process that owns the frame. If any devices are in use, the operation is rejected with an error. This check is crucial to maintain system stability, as reclaiming frames in use by devices could lead to data corruption or device malfunctions.\nIf all conditions are satisfied, the system proceeds to reclaim the frame. It updates the target memory frame, marking it as free and removing its association with the previous owner. This update is performed atomically to ensure consistency and prevent race conditions during the operation. The system also updates the process's metadata to reflect the resource reclamation, decrementing the number of DMA pages associated with the process.\nIn conclusion, the sys_reclaim_iommu_frame system call is a vital mechanism for managing memory resources in environments involving memory management units. By enforcing strict validation and ownership checks, the system ensures that frames are reclaimed securely and efficiently, contributing to the overall robustness and flexibility of the system's memory management architecture.\n",
        "syscall": "sys_reclaim_iommu_frame",
        "declaration": "int sys_reclaim_iommu_frame(dmapn_t dmapn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_iommu_frame(dmapn_t dmapn)\n{\n    struct page_desc *desc;\n    pid_t pid;\n\n    if (is_dmapn_valid(dmapn))\n        return -EINVAL;\n    if (is_dmapage_type(dmapn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    desc = &dmapage_desc_table[dmapn];\n    pid = desc->pid;\n    /* can reclaim pages owned by a zombie */\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    /* don't reclaim anything if any device is in use */\n    if (get_proc(pid - 2)->nr_devs)\n        return -EBUSY;\n\n    desc->pid = PAGE_TYPE_FREE;\n    desc->pid = 0;\n    --get_proc(pid)->nr_dmapages;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\n/* IOMMU frame pages */\nvolatile uint8_t dmapages[NDMAPAGE][PAGE_SIZE] __aligned(SZ_2M); /* 2M-aligned for PMR */\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "bounds checking, buffer overflow, incorrect pointer",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_iommu_root` system call is designed to reclaim the IOMMU (Input-Output Memory Management Unit) root entry associated with a specific device, identified by its device ID (devid). This operation is crucial in systems where devices are dynamically managed, and resources need to be reallocated or cleaned up when they are no longer in use. The system call ensures that the IOMMU root entry is safely reclaimed, freeing up resources and maintaining system stability.\nThe system call begins by identifying the process associated with the specified device. It then validates the validity of the process and ensures the process is in a terminated state. This validation is essential because resources can only be safely reclaimed from processes that are no longer active, preventing potential conflicts or inconsistencies.\nAdditionally, the system call verifies that the process does not have any active interrupt remapping entries. Interrupt remapping is a feature of the IOMMU that allows interrupts to be dynamically redirected, and active entries indicate ongoing use of the device. If any interrupt remapping entries are present, the system call terminates with an error, as reclaiming the IOMMU root would disrupt active device operations.\nOnce these checks are passed, the system proceeds to decrement the count of devices associated with the process. This step is crucial for maintaining accurate bookkeeping of resources and ensuring that the process's resource usage is correctly reflected in the system's records.\nThe system then updates the device-to-process mapping to indicate that the device is no longer associated with any process. This update is essential for preventing future operations from mistakenly assuming that the device is still in use by the terminated process.\nFinally, the system resets the device's root in the IOMMU. It also invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. By performing these actions, the system ensures that the device is ready for reassignment or reuse by other processes, contributing to the overall efficiency and robustness of the system's resource management.\nIn conclusion, the `sys_reclaim_iommu_root` system call plays a vital role in managing device resources within the IOMMU. By carefully validating process states, checking for dependencies, and updating system records, it ensures that resources are reclaimed safely and efficiently. This functionality is essential for maintaining optimal resource utilization and system stability in environments where devices are frequently reassigned or reconfigured.\n",
        "syscall": "sys_reclaim_iommu_root",
        "declaration": "int sys_reclaim_iommu_root(devid_t devid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_iommu_root(devid_t devid)\n{\n    pid_t pid = pci_table[devid];\n\n    /* can free a page of a zombie process */\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_proc(pid)->nr_intremaps)\n        return -EBUSY;\n\n    ++get_proc(pid)->nr_devs;\n    pci_table[devid - 2] = 0;\n\n    iommu_reset_dev_root(devid);\n    iommu_flush();\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define SZ_64K UINT64_C(0x00010000)\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "memory leak, buffer overflow",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_vector` system call is designed to allocate an interrupt vector to the currently running process. Interrupt vectors are crucial in operating systems for handling hardware and software interrupts, allowing processes to be notified and respond to specific events. This system call ensures that a process can claim a vector for its exclusive use, facilitating efficient and organized interrupt handling.\nThe system call begins by checking if the requested vector is already in use. If the vector is occupied, the operation is terminated with an error, as each vector must be unique to ensure proper event handling. This check prevents conflicts and ensures that each process can be distinctly identified by its allocated vector.\nOnce it is confirmed that the vector is available, the system assigns it to the current process. This assignment involves updating a system-wide table that tracks which process is associated with each vector. By maintaining this mapping, the system can efficiently route events or interrupts to the correct process based on the vector.\nAfter successfully assigning the vector, the system increments a counter within the process. This counter keeps track of the number of vectors allocated to the process, providing a mechanism for resource management and ensuring that processes do not exceed their allocation limits.\nIn conclusion, the sys_alloc_vector system call is a fundamental mechanism for associating processes with unique vectors in systems that handle events or interrupts. By ensuring the uniqueness of vectors and maintaining an efficient mapping, the system call facilitates effective event handling and contributes to the overall stability and functionality of the system.\n",
        "syscall": "sys_alloc_vector",
        "declaration": "int sys_alloc_vector(uint8_t vector);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_vector(uint8_t vector)\n{\n    if (!vector_table[vector])\n        return -EBUSY;\n\n    vector_table[vector - 1] = current;\n    ++get_proc(current)->nr_devs;\n    return 0;\n}\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NOFILE 16   /* open files per process */\n/* vector -> pid */\nstatic pid_t vector_table[256];\n#define NPROC 64    /* maximum number of processes */\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "buffer overflow, incorrect privilege, incorrect pointer, memory leak",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_vector` system call is designed to manage interrupt vectors by reclaiming them from processes that are no longer active. This operation is crucial in systems where interrupt vectors are a limited resource, and efficient management is necessary to ensure that they are available for use by active processes. By reclaiming vectors from processes that are in a terminated state, the system can free up these resources for reassignment, maintaining optimal utilization of interrupt handling capabilities.\nThe system call begins by validating the process associated with the specified interrupt vector is valid and in a terminated state. This association is crucial as it determines the ownership and current state of the resources linked to the vector. If the process is not valid or not in a terminated state, the operation is halted with an error. This restriction ensures that only resources from processes that are no longer active can be reclaimed, maintaining system stability and preventing unintended disruptions.\nOnce the process state is verified, the system checks for any outstanding interrupt remapping operations associated with the process. If such operations are present, the system denies the reclaim request with an error. This check ensures that all interrupt remapping activities are completed before resources are reclaimed, preventing potential conflicts or inconsistencies in interrupt handling.\nUpon successful validation of the process state and absence of pending operations, the system proceeds to reclaim the resources. It resets the corresponding mapping from interrupt vectors to processes to reflect the release of the interrupt vector, effectively making it available for future allocations. Additionally, the system decrements the count of active vectors associated with the process, maintaining accurate tracking of resource usage.\nIn summary, the sys_reclaim_vector system call plays a vital role in resource management within the system. By enforcing strict checks on process state and pending operations, it ensures that resources are reclaimed safely and efficiently. This functionality contributes to the overall robustness and flexibility of the system's interrupt management architecture, allowing for dynamic allocation and reclamation of resources as needed.\n",
        "syscall": "sys_reclaim_vector",
        "declaration": "int sys_reclaim_vector(uint8_t vector);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_vector(uint8_t vector)\n{\n    pid_t pid;\n\n    pid = vector_table[vector];\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_proc(pid)->nr_intremaps)\n        return -EBUSY;\n\n    vector_table[vector] = 0;\n    --get_proc(pid)->nr_ports;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "incorrect pointer, memory leak, bounds checking, incorrect privilege",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_intremap` system call is designed to allocate an interrupt remapping entry, which is crucial for managing hardware interrupts in systems that utilize an I/O Memory Management Unit (IOMMU). This system call ensures that interrupts from specific devices are correctly mapped to the appropriate interrupt vectors, allowing processes to handle hardware events efficiently and securely.\nThe system call begins by verifying the validity and availability of the specified interrupt remapping entry. If the entry is not valid or available, the operation is terminated with an error, as the allocation cannot proceed without a free entry.\nOnce the entry's validity and availability are confirmed, the system checks the ownership of the device and the interrupt vector. It ensures that both the device and the vector are owned by the current process. If either the device or the vector is not owned by the current process, the operation is rejected with an error. This ownership verification is critical to prevent unauthorized access to hardware resources, maintaining system security and integrity.\nAfter confirming ownership, the system proceeds to allocate the interrupt remapping entry. It updates the entry's state to indicate that it is now active and associates it with the specified device and vector. This association ensures that future interrupts from the device are correctly mapped to the specified vector, allowing the process to handle them appropriately.\nThe system also updates the process to reflect the allocation of the interrupt remapping entry. This update is essential for tracking the number of active remapping entries associated with the process, facilitating resource management and accounting.\nFinally, the system configures the hardware to establish the interrupt remapping. This configuration ensures that the hardware is aware of the new mapping, allowing interrupts to be delivered according to the specified configuration. By performing this step, the system ensures that the interrupt remapping is fully operational and effective.\nIn conclusion, the sys_alloc_intremap system call provides a mechanism for processes to allocate and manage interrupt remapping entries. It enforces strict ownership checks, updates system state, and configures hardware to ensure that interrupts are correctly mapped and handled. This capability is vital for systems requiring precise control over interrupt delivery, contributing to the overall robustness and efficiency of the system's interrupt management architecture.\n",
        "syscall": "sys_alloc_intremap",
        "declaration": "int sys_alloc_intremap(size_t index, devid_t devid, uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_intremap(size_t index, devid_t devid, uint8_t vector)\n{\n    struct intremap *ir;\n\n    if (!is_intremap_state(index, IR_FREE))\n        return -EINVAL;\n    /* is the device owned by current */\n    if (pci_table[devid] != current)\n        return -EACCES;\n    /* is the vector owned by current */\n    if (vector_table[vector] != current)\n        return -EACCES;\n\n    ir = &intremap_table[index];\n    ir->devid = IR_ACTIVE;\n    ir->devid = devid;\n    ir->vector = vector;\n    --get_proc(current)->nr_intremaps;\n    iommu_set_intremap(index, devid, vector);\n    return 0;\n}\n\nenum intremap_state {\n    IR_FREE = 0,\n    IR_ACTIVE,\n\n    IR_FORCE_WIDTH = ~UINT64_C(0),\n};\n\nstruct intremap {\n    enum intremap_state state;\n    devid_t devid;\n    uint8_t vector;\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define SZ_64K UINT64_C(0x00010000)\n#define NPROC 64    /* maximum number of processes */\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\n#define NINTREMAP 8 /* maximum number of interrupt remapping entries */\n\nstatic struct intremap intremap_table[NINTREMAP];\n\nstatic inline int is_intremap_state(size_t index, enum intremap_state state)\n{\n    return is_intremap_valid(index) && intremap_table[index].state == state;\n}\n\nstatic inline int is_intremap_valid(size_t index)\n{\n    return index < NINTREMAP;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "incorrect pointer, memory leak",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_intremap` system call is designed to manage and reclaim interrupt remapping entries within the system. This operation is crucial for maintaining efficient use of interrupt remapping resources, which are essential for handling hardware interrupts in a virtualized environment. By reclaiming unused or obsolete entries, the system can optimize resource allocation and ensure that interrupt handling remains efficient and effective.\nThe system call begins by verifying the validity and the state of the specified interrupt remapping entry. It checks whether the entry is valid and currently active, as only active entries are eligible for reclamation. If the entry is not valid or active, the operation is terminated with an error, preventing any unintended modifications to inactive or already reclaimed entries.\nOnce the entry's state is validated, the system retrieves the associated process identifier from the interrupt remapping table. This identifier is crucial for determining the ownership and current state of the process linked to the entry. The system then checks the validity and the state of the process to ensure it is valid and in a terminated condition. This restriction ensures that only entries associated with processes that are no longer active can be reclaimed, maintaining system stability and preventing disruptions to active processes.\nIf the process state is verified, the system proceeds to update the interrupt remapping entry. It marks the entry as free, effectively releasing it for future use. Additionally, it clears any associated identifiers or vectors, ensuring that the entry is completely reset and ready for reassignment. This step is crucial for maintaining the integrity of the interrupt remapping table and preventing any residual data from affecting future operations.\nThe system then updates the process's metadata to reflect the decrease in the number of active interrupt remapping entries. This update ensures that the process's resource usage is accurately tracked, allowing the system to manage resources effectively and prevent any potential over-allocation or resource leaks.\nFinally, the system triggers a mechanism to reset the hardware state associated with the reclaimed entry. This step ensures that any hardware configurations related to the entry are cleared, preventing any unintended behavior or conflicts in future operations. By resetting the hardware state, the system maintains consistency between software and hardware configurations, ensuring reliable and predictable interrupt handling.\nIn conclusion, the `sys_reclaim_intremap` system call is a vital component for managing interrupt remapping resources within the system. It carefully validates the state of entries and processes, updates system tables and descriptors, and ensures hardware consistency. By providing this functionality, the system call contributes to the efficient and effective management of interrupt handling resources, enhancing the overall performance and reliability of the system's virtualized environment.\n",
        "syscall": "sys_reclaim_intremap",
        "declaration": "int sys_reclaim_intremap(size_t index);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_intremap(size_t index)\n{\n    struct intremap *ir;\n    pid_t pid;\n\n    if (is_intremap_state(index, IR_ACTIVE))\n        return -EINVAL;\n\n    ir = &intremap_table[index];\n    pid = pci_table[ir->devid];\n    /* can only reclaim a zombie's IRTE */\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n\n    ir->state = IR_FREE;\n    ir->devid = 0;\n    ir->vector = 0;\n    --get_proc(pid)->nr_intremaps;\n    iommu_reset_intremap(index);\n    return 0;\n}\n\nenum intremap_state {\n    IR_FREE = 0,\n    IR_ACTIVE,\n\n    IR_FORCE_WIDTH = ~UINT64_C(0),\n};\n\nstruct intremap {\n    enum intremap_state state;\n    devid_t devid;\n    uint8_t vector;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define SZ_64K UINT64_C(0x00010000)\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\nstatic struct intremap intremap_table[NINTREMAP];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline int is_intremap_state(size_t index, enum intremap_state state)\n{\n    return is_intremap_valid(index) && intremap_table[index].state == state;\n}\n\n#define NINTREMAP 8 /* maximum number of interrupt remapping entries */\n\nstatic inline int is_intremap_valid(size_t index)\n{\n    return index < NINTREMAP;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_ack_intr` system call is designed to acknowledge and clear a specific interrupt for the currently running process. This operation is crucial in systems where processes need to manage and respond to multiple interrupts efficiently. By acknowledging an interrupt, the process indicates that it has handled the event associated with the interrupt vector, allowing the system to clear the interrupt state and prevent redundant handling.\nThe system call begins by retrieving the descriptor of the currently executing process. This descriptor contains crucial information about the process, including its interrupt status. The interrupt status is a bitset that tracks which interrupts are currently active for the process. By accessing this status, the system can determine which interrupts need to be acknowledged and cleared.\nOnce the process descriptor is obtained, the system proceeds to clear the specified interrupt from the process's interrupt status. This is achieved by manipulating the bitset to remove the bit corresponding to the interrupt. By clearing this bit, the system effectively acknowledges that the interrupt has been handled and should no longer be considered active for the process.\nThe operation is performed atomically to ensure consistency and prevent race conditions. This atomicity is crucial in a multi-threaded or multi-core environment, where multiple processes or threads might be interacting with the interrupt status simultaneously. By ensuring that the operation is atomic, the system maintains the integrity of the interrupt status and prevents any potential conflicts or inconsistencies.\nIn conclusion, the `sys_ack_intr` system call is a vital component in the management of interrupt-driven events within a process. By providing a mechanism to acknowledge and clear interrupts, it ensures that processes can efficiently handle and respond to interrupt events without redundancy or instability. This capability contributes to the overall robustness and reliability of the system's interrupt management architecture.\n",
        "syscall": "sys_ack_intr",
        "declaration": "int sys_ack_intr(uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_ack_intr(uint8_t v)\n{\n    struct proc *proc = get_proc(current - 1);\n\n    bit_clear(v, proc->nr_intremaps);\n    return 0;\n}\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n#define _BITSET_BITS       (sizeof(unsigned long) * 8)\n\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_clear(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] &= ~__bitset_mask(n);\n}\n\n```\n",
        "bug_type": "incorrect pointer, buffer overflow",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_port` system call is designed to allocate an I/O port to a process, allowing it to perform input/output operations on that port. This functionality is crucial in systems where processes need direct access to hardware resources, such as peripheral devices, through specific I/O ports. The system call ensures that port allocation is managed securely and efficiently, preventing conflicts and unauthorized access.\nThe system call begins by checking if the requested port is already in use. If the port is occupied, the operation is terminated with an error, indicating that the port is unavailable for allocation. This check prevents conflicts and ensures that each port is uniquely assigned to a single process at any given time.\nOnce the port's availability is confirmed, the system verifies whether the process is permitted to use the I/O bitmap. If the process lacks this permission, the operation is rejected with an error. This restriction ensures that only authorized processes can allocate ports, maintaining system security and stability.\nIf the process is authorized, the system proceeds to allocate the port by marking it as taken by the current process. It updates the I/O bitmap of the process to clear the bit corresponding to the allocated port, effectively granting the process access to the port. The bitmap is divided into two sections, and the system determines which section to update based on the port number. This update ensures that the process has the necessary permissions to access the allocated port.\nFinally, the system increments the count of ports allocated to the process, reflecting the successful allocation. The operation concludes with a success status, indicating that the port has been successfully allocated to the process.\nIn summary, the sys_alloc_port system call is a critical mechanism for managing I/O port allocations in a secure and efficient manner. It ensures that ports are uniquely assigned, verifies process permissions, and updates the process's I/O bitmap to reflect the allocation. By providing this functionality, the system call supports processes in performing direct hardware interactions, contributing to the overall flexibility and capability of the system's I/O management.\n",
        "syscall": "sys_alloc_port",
        "declaration": "int sys_alloc_port(uint16_t port);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_port(uint16_t port)\n{\n    struct proc *proc;\n\n    if (io_table[port])\n        return -EBUSY;\n\n    proc = get_proc(current);\n    if (!proc->use_io_bitmap)\n        return -EACCES;\n\n    io_table[port] = current;\n    if (port < 0x8000)\n        bit_clear(port, get_page(proc->io_bitmap_a));\n    else\n        bit_clear(port - 0x8000, get_page(proc->io_bitmap_b));\n    --proc->nr_ports;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define SZ_64K UINT64_C(0x00010000)\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/*\n * Map port to owner pid:\n * 0: free\n * -1: reserved by kernel\n * others: taken by pid\n */\nstatic pid_t io_table[SZ_64K];\n\n#define _BITSET_BITS       (sizeof(unsigned long) * 8)\n\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_clear(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] &= ~__bitset_mask(n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_port` system call is designed to manage the ownership of I/O ports by reclaiming ports that were previously allocated to processes that are no longer active. This functionality is crucial in systems where I/O ports are a limited resource and need to be efficiently managed and reallocated as processes terminate or become inactive. The system call ensures that ports are only reclaimed from processes that are in a specific state, maintaining system integrity and preventing unauthorized access to I/O resources.\nThe system call begins by identifying the process associated with the specified resource. It retrieves the identifier of the process that currently holds the resource. This step is crucial for determining the ownership and state of the resource.\nOnce the process identifier is obtained, the system verifies the validity and the state of the process to ensure it is in a terminated condition that allows resource reclamation. If the process is not valid or in the required state, the operation is terminated with an error. This check prevents unauthorized access and ensures that only resources from processes in the appropriate state can be reclaimed.\nIf the process is in the correct state, the system proceeds to release the resource. It resets and clears the owner process of the resource to indicate that the resource is now available for allocation. This step is performed without the need to modify any additional process-specific configurations, simplifying the reclamation process.\nFinally, the system decrements the count of ports allocated to the process, reflecting the successful resource reclamation. It decrements the count of resources held by the process, ensuring that the process's resource usage is accurately tracked. This update is crucial for maintaining an accurate record of resource distribution across the system.\nIn summary, the `sys_reclaim_port` system call provides a mechanism for reclaiming resources from processes that are no longer actively using them. By enforcing strict checks on process state and updating resource management structures, the system ensures that resources are efficiently recycled and made available for future use. This contributes to the overall stability and performance of the system's resource management framework.\n",
        "syscall": "sys_reclaim_port",
        "declaration": "int sys_reclaim_port(uint16_t port);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_port(uint16_t port)\n{\n    pid_t pid = io_table[port];\n\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n\n    io_table[port] = 0;\n    /* no need to clear per-process I/O bitmap */\n    ++get_proc(pid)->nr_ports;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define SZ_64K UINT64_C(0x00010000)\n#define NPROC 64    /* maximum number of processes */\n\nextern struct proc proc_table[NPROC];\n\n/*\n * Map port to owner pid:\n * 0: free\n * -1: reserved by kernel\n * others: taken by pid\n */\nstatic pid_t io_table[SZ_64K];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "incorrect privilege, memory leak",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pdpt` system call is responsible for allocating a new Page Directory Pointer Table (PDPT) entry in a process's hierarchical page table, which is a critical structure in managing virtual memory. This system call involves mapping a newly allocated memory page to the next level in the page table hierarchy, ensuring that the memory is correctly configured and accessible with the specified permissions. The operation supports dynamic memory allocation for processes, enabling them to expand or modify their virtual address space as needed.\nThe operation begins by validating the target page designated for the page directory pointer table is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page directory pointer table entry. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. PML4, to point to the newly allocated page directory pointer table page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nAfter successfully establishing the mapping, the system proceeds to allocate the PDPT page. This involves marking the page as belonging to the process and designating it as a PDPT in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pdpt` system call provides a structured and secure mechanism for allocating and mapping PDPT pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pdpt",
        "declaration": "int sys_alloc_pdpt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pdpt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PML4,\n                                 PAGE_TYPE_X86_PDPT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define PTE_PFN_SHIFT 12\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* update the page table */\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe sys_free_pdpt system call is responsible for freeing a specific entry in a page table hierarchy by deallocating a page directory pointer table (PDPT) page and cleaning up its reference within a higher-level page table. This operation is an essential part of dynamic memory management in virtual memory systems, where hierarchical page tables are used to manage address mappings. The system call ensures that the memory associated with a PDPT page is properly released and no longer accessible, while maintaining the integrity of the page table structure.\nThe system call begins by validating that the source page directory pointer table is valid and is of the correct type, a Page Map Level 4 type. It also validates that the source PML4 page table belongs to the calling process. It ensures that the PML4 page table corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the PML4 page table, each of which points to PDPT page. This check ensures that the operation targets a valid entry within the PML4 page table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page directory pointer table is valid and is of the correct type, a Page Directory Pointer Table. It ensures that the target page directory pointer table corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the PML4 page table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing PML4 page table entry corresponds to the specified page directory pointer table by checking if the physical frame number derived from the PML4 page table entry matches the page directory pointer table's expected physiscal address.  This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the PDPT page. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the PML4 page table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PDPT from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PD is freed.\nBy the end of the operation, the specified PDPT page is fully deallocated, and its entry in the PML4 table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The sys_free_pdpt system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pdpt",
        "declaration": "int sys_free_pdpt(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pdpt(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PML4, PAGE_TYPE_X86_PDPT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `clone_proc` system call facilitates the creation of a new process by duplicating key aspects of an existing process, such as its memory layout, execution state, and kernel stack. This functionality is fundamental to multitasking operating systems, allowing new processes to be created either as independent entities or as lightweight threads that share certain resources with their parent. The clone_proc function, which implements this system call, ensures that the new process is correctly initialized and inherits the necessary context to execute seamlessly.\nThe system call begins by allocating resources for the new process. It first validates the validity and the state of the specified process. If the process if invalid or not unused, the operation is rejected with an error. It then ensures that the necessary memory pages for the process's page table root, stack, and hardware state are valid and unallocated. If any of these resources are not valid,unavailable, or already in use, the operation is terminated with an error, preventing resource conflicts and ensuring system stability. Also, the system validates the process's page table root, stack, and hardware state are unique to each other. If any two of them are identical, the operation is rejected with an error.\nOnce the validations are complete, the system initializes the new process's descriptor, setting its parent process identifier and marking it as in the embryonic state. This state indicates that the process is in the initial stages of creation and not yet fully operational. The system also allocates and initializes pages for the page table root, stack and hvm with the corresponding page type and then updates the current process's metadata to reflect the increase of pages allocated for the specified process. The metadata of the process's parent process is also updated to reflect the increase of its child processes.\nThe system then duplicates the current process's execution context. It copies all the data of the kernel stack, which contains saved registers and execution state, to the new process's stack. This ensures that the new process begins execution with the same context as the parent process, allowing it to continue from the same point in the program.\nNext, the system copies the hardware virtual machine (HVM) state from the current process to the new process. This involves flushing the stale mappings to ensure consistency and copy data from the parent HVM to the child HVM state specified. This step is crucial for maintaining the execution environment, as it includes processor state and other critical hardware configurations.\nAfter duplicating the execution context, the system prepares the new process for execution.\nFinally, the system returns control to the user space, allowing the new process to begin execution. The new process starts with the same execution context as the parent, enabling it to perform tasks independently while sharing the same initial state.\nIn summary, the `clone_proc` system call is a vital mechanism for process creation in operating systems. It carefully allocates resources, duplicates execution context, and prepares the new process for execution, ensuring a seamless and efficient process creation experience. By providing this functionality, the system call supports multitasking and process management, contributing to the overall robustness and flexibility of the operating system.\n",
        "syscall": "clone_proc",
        "declaration": "int sys_clone(pid_t pid, pn_t pml4, pn_t stack, pn_t hvm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint clone_proc(pid_t pid, pn_t pml4, pn_t stack, pn_t hvm)\n{\n    int r;\n    struct proc *proc;\n    void *parent_hvm, *child_hvm;\n\n    r = alloc_proc(pid, pml4, stack, hvm);\n    if (r)\n        return r;\n\n    proc = get_proc(current);\n\n    /* copy the kernel stack (saved registers) */\n    memcpy(get_page(stack), get_page(proc->stack), PAGE_SIZE);\n\n    parent_hvm = get_page(proc->hvm);\n    child_hvm = get_page(hvm);\n    /* copy hvm state */\n    flush_current();\n    hvm_flush(child_hvm);\n    memcpy(child_hvm, parent_hvm, PAGE_SIZE);\n    hvm_copy(child_hvm, parent_hvm, pid);\n\n    /* will call run_current() upon return */\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nint alloc_proc(pid_t pid, pn_t page_table_root, pn_t stack, pn_t hvm)\n{\n    struct proc *proc, *parent;\n\n    if (!is_proc_state(pid, PROC_UNUSED))\n        return -ENOMEM;\n    if (!is_page_type(page_table_root, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (is_page_type(stack, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (is_page_type(hvm, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (page_table_root == stack)\n        return -EINVAL;\n    if (page_table_root == hvm)\n        return -EINVAL;\n    if (stack == hvm)\n        return -EINVAL;\n\n    proc = get_proc(pid);\n    bzero(proc, sizeof(*proc));\n    proc->ppid = current;\n    proc->state = PROC_EMBRYO;\n\n    proc->page_table_root = page_table_root;\n\n    alloc_page(pid, PAGE_TYPE_PROC_DATA, stack);\n    proc->stack = stack;\n\n    alloc_page(pid, PAGE_TYPE_PROC_DATA, hvm);\n    proc->hvm = hvm;\n\n    parent = get_proc(current);\n    ++parent->nr_children;\n\n    return 0;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* called in entry.S */\nvoid flush_current(void)\n{\n    struct proc *proc;\n    void *hvm;\n\n    proc = get_proc(current);\n    hvm = get_page(proc->hvm);\n    hvm_flush(hvm);\n    proc->launched = 0;\n}\n\n```\n",
        "bug_type": "incorrect privilege, memory leak",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `send_proc` system call facilitates one-way interprocess communication (IPC) by enabling a process (the sender) to deliver data and control information to another process (the receiver). This mechanism is particularly useful in scenarios where a server process is waiting to handle requests or data from client processes. The system ensures secure and synchronized communication by validating inputs, transferring data, and transitioning the states of the involved processes appropriately.\nThe system call begins by validating the validity of the target process and ensuring that it is in a sleeping state. If the target process is not valid or in the appropriate state, the operation is aborted with an error, as data cannot be sent to a process that is not ready to receive it.\nOnce the target process is verified, the system checks the validity and the ownership of the memory region from which data will be sent. This involves ensuring that the memory page is valid and belongs to the sending process and that the specified size does not exceed the allowable limit. If these conditions are not met, the operation is terminated with an error, preventing unauthorized access or buffer overflows.\nIf the file descriptor is included, it must be either invalid, indicating the file descriptor is not in use, or valid and associated with an open file. If the file descriptor is valid but not associated with an open file, the operation is rejected with an error.\nAfter all validations are complete, the system retrieves the descriptors for both the sending and receiving processes. It then updates the receiving process's state to reflect the incoming data, including the source process, the data value, and the size of the data. The system ensures that the memory region designated for receiving data is valid and owned by the target process, maintaining memory integrity.\nThe data is then copied from the sending process's memory to the receiving process's designated memory region. This operation is performed securely to prevent data corruption or unauthorized access.\nIf the file descriptor provided and the receiver's file descriptor are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nFinally, the system updates the states of both processes to reflect the completion of the data transfer. The sending process is marked as ready to run, while the receiving process is transitioned to a running state. This ensures that the receiving process can immediately begin processing the received data. And then the current process is switched to the receiving process.\nIn conclusion, the `send_proc` system call is a vital mechanism for enabling efficient and secure data exchange between processes. By enforcing strict validations and ensuring proper state transitions, the system call maintains the integrity and reliability of inter-process communication within the operating system.\n",
        "syscall": "send_proc",
        "declaration": "int sys_send(pid_t pid, uint64_t val, pn_t pn, size_t size, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint send_proc(pid_t pid, uint64_t val, pn_t pn, size_t size, int fd)\n{\n    struct proc *sender, *receiver;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    if (!is_pn_valid(pn))\n        return -EINVAL;\n    /* pn doesn't have to be a frame */\n    if (!is_page_pid(pn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    if (!is_fd_valid(fd)) {\n        if (!is_fn_valid(get_fd(current, fd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    sender->ipc_from = current;\n    receiver->ipc_val = val;\n    receiver->ipc_size = size;\n    /* invariant: proc->ipc_page is a valid page owned by pid */\n    memcpy(get_page(receiver->ipc_page), get_page(pn), size);\n    /* invariant: ipc_fd is empty if it's valid */\n    if (is_fd_valid(fd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, fd));\n\n    sender->state = PROC_RUNNABLE;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    current = pid;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NPAGE 8192  /* maximum number of pages */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n```\n",
        "bug_type": "incorrect privilege, buffer overflow, incorrect pointer",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `reply_wait_proc` system call implements a two-way communication mechanism between a client and a server process, enabling a client to send data and wait for a response from the server. The system ensures that the server is in a specific state to handle the request while maintaining proper synchronization and resource allocation. This functionality is crucial for interprocess communication (IPC) in operating systems where processes must exchange data or signals in a controlled and coordinated manner.\nThe system call begins by verifying the validity of the target process and ensuring it is in the sleeping state, indicating readiness to receive data. If the target process is not valid or is actively running, the system call terminates with an error.\nNext, the system validates the validity of the input page and the output page. It also validates that the input and output pages belong to the calling process. The type of the output page should be the correct frame page and the size of the data must not exceed the limits of a memory page. Any violations to these constriants will make the operation to terminate with an error.\nThe system then validates that the input and output file descriptor is either invalid or non-empty and the output file descriptor is either invalid or empty. The output file descriptor is set to invalid to indicate that no output file descriptor is used in the operation. If these conditions are not met, the operation is rejected with an error. These checks ensure that communication adheres to system constraints and prevents unauthorized access.\nThe system then sets up the communication. It sets the current process as the sender process and the target process as the receiver process. It then validates that the receiver process wants to accept the other process's requests. If the condition is not met, the operation is rejected with an error. The sender process then prepares to send its request by specifying the data to be transferred and optional resources such as file descriptors. The receiver process prepares to receive this data by specifying the source process that the data is from and the specific control value. The system then securely transfers the page of data from the input page to the designated page of the receiver process within the specified size limit and updates the transferred size for the receiver process. establishing the memory location (outpn) where the input data will be copied, ensuring that the receiver can process the request without needing additional access to the sender's resources. If the input file descriptor and the file descriptor of the receiver process are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nAfter the data and resources are transferred, the system transitions control between the two processes. The sender process is placed into a sleeping state, indicating that it is waiting for the receiver to complete its task. At the same time, the receiver process is transitioned to a running state, allowing it to process the request immediately. This context switch ensures that the receiver begins handling the request without delay while the sender remains blocked until the receiver completes its task. The state transition is carefully managed to maintain system stability and prevent race conditions or deadlocks.\nFinally, the system ensures the current process is set to accept IPC communication from the specified process and then switches the current process context to the specified process.\nIn summary, the `reply_wait_proc` system call is used to facilitate interprocess communication where a process replies to a waiting process (receiver) and simultaneously prepares itself to wait for further communication. It validates inputs, securely transfers data (including optional file descriptors), and updates process states to ensure the sender transitions to sleeping (waiting) while the receiver is activated. This system call is critical in managing synchronous communication between processes, enabling efficient data exchange and coordinated execution in the operating system.",
        "syscall": "reply_wait_proc",
        "declaration": "int sys_reply_wait(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint reply_wait_proc(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn)\n{\n    int r;\n\n    r = send_recv(pid, val, inpn, size, infd, outpn, -1);\n    if (r)\n        return r;\n    /* accept any ipc */\n    get_proc(current)->ipc_from = 0;\n    current = pid;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic int send_recv(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn,\n                     int outfd)\n{\n    struct proc *sender, *receiver;\n\n    /* target process must be sleeping */\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    /* check in page */\n    if (!is_pn_valid(inpn))\n        return -EINVAL;\n    /* inpn doesn't have to be a frame */\n    if (!is_page_pid(inpn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    /* check in fd: either invalid or non-empty */\n    if (is_fd_valid(infd)) {\n        if (!is_fn_valid(get_fd(current, infd)))\n            return -EINVAL;\n    }\n    /* check out page */\n    if (is_pn_valid(outpn))\n        return -EINVAL;\n    if (!is_page_pid(outpn, current))\n        return -EACCES;\n    if (is_page_type(outpn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    /* check out fd: either invalid or empty */\n    if (!is_fd_valid(outfd)) {\n        if (is_fn_valid(get_fd(current, outfd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    /* check if the receiver wants to accept anyone's request */\n    if (receiver->ipc_from && receiver->ipc_from != current)\n        return -EACCES;\n\n    /* client: prepare for response */\n    sender->ipc_page = outpn;\n    sender->ipc_fd = outfd;\n\n    /* server: transfer data from client */\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    /* transfer the page */\n    memcpy(get_page(receiver->ipc_page), get_page(inpn), size);\n    receiver->ipc_size = size;\n    /* transfer the fd */\n    if (is_fd_valid(infd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, infd));\n\n    /* switch control */\n\n    sender->state = PROC_SLEEPING;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    /* sender: running -> sleeping */\n    proc_ready_del(sender);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\ns\n```\n",
        "bug_type": "buffer overflow, bounds checking, incorrect privilege",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_dup2` system call provides a mechanism for duplicating a file descriptor from one process to another or within the same process. This operation is essential for managing file descriptor tables, allowing processes to redirect input/output streams or share file descriptors between processes. By duplicating a file descriptor, a process can create an alias for an existing file descriptor, enabling flexible file management and inter-process communication.\nThe system call begins by validating the specified process identifier to ensure it corresponds to a valid and active process. If the process identifier is invalid, the operation is terminated with an error, as the duplication cannot proceed without a valid target. The system also checks that the process is either the current one or its embryo process, ensuring that the operation is authorized.\nNext, the system verifies the validity of the source file descriptor within the current process. It also validates the source file descriptor exists in the calling process. If the source file descriptor is invalid or does not exist in the calling process, the operation is rejected with an error. This check ensures that the duplication operation is based on a valid file descriptor, preventing errors or undefined behavior.\nThe system then checks the validity of the target file descriptor. If the target file descriptor is invalid, the operation is terminated with an error. This validation ensures that the target location for the duplication is within acceptable limits, maintaining the integrity of the file descriptor table.\nIf the source and target file descriptors are the same and belong to the same process, the system call does nothing and returns successfully. This behavior aligns with the POSIX standard, which specifies that duplicating a file descriptor to itself should have no effect.\nIf the target file descriptor already exists in the target process, the system closes it before proceeding with the duplication.    Closing the file involves updating the process's file descriptor table to mark the descriptor as unused and decrementing the count of open file descriptors for the process. Additionally, the system updates the file's reference count to reflect the decrease of the file references. And if the file is no longer referenced by any process, it resets the file's attributes, including its type, value, offset, and mode of operation, releasing the associated resources. This step guarantees that newfd is free and available for duplication.\nFinally, the system proceeds to duplicate the source file descriptor. The system associates the file descriptor with the file or resource by updating the target process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. This assignment is performed atomically to ensure consistency and correctness during the operation.\nIn conclusion, the `sys_dup2` system call is a crucial feature for managing file descriptors in a flexible and efficient manner. It carefully validates inputs, enforces strict permissions, and ensures that the duplication is performed securely and accurately. This design allows processes to manage their file descriptors effectively, contributing to the overall robustness and flexibility of the system's file management architecture.\n\n",
        "syscall": "sys_dup2",
        "declaration": "int sys_dup2(int oldfd, pid_t pid, int newfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_dup2(int oldfd, pid_t pid, int newfd)\n{\n    fn_t fn;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    /* oldfd doesn't exist  */\n    if (!is_fd_valid(oldfd))\n        return -EBADF;\n    fn = get_fd(current, oldfd);\n    if (fn == 0)\n        return -EBADF;\n    if (!is_fd_valid(newfd))\n        return -EBADF;\n\n    /* POSIX: do nothing for the same fd */\n    if ((current == pid) && (oldfd == newfd))\n        return 0;\n\n    /* close newfd if it already exists */\n    if (get_fd(pid, newfd) == 0)\n        clear_fd(pid, newfd);\n    set_fd(pid, newfd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void clear_fd(pid_t pid, int fd)\n{\n    struct proc *proc;\n    struct file *file;\n\n    proc = get_proc(pid);\n    file = get_file(get_fd(pid, fd));\n    proc->ofile[fd] = 0;\n    --proc->nr_fds;\n    if (--file->refcnt == 0) {\n        file->type = FD_NONE;\n        file->value = 0;\n        file->offset = 0;\n        file->omode = 0;\n    }\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe sys_alloc_io_bitmap system call is designed to enable a process to allocate an I/O bitmap, which controls access to I/O ports in virtualized environments. The I/O bitmap acts as a mechanism for restricting or granting access to specific I/O ports by mapping them to a bit array, where each bit corresponds to a port. This system call ensures proper setup of the I/O bitmap while adhering to security and hardware requirements, making it essential for processes that require fine-grained control over I/O port access.\nThe system call begins by validating the sequence of memory pages provided. It requires three consecutive pages to be specified, ensuring that the memory allocation is contiguous. This requirement arises because hardware virtualization, particularly in x86 architectures, demands that I/O bitmaps be stored in contiguous memory regions for efficient access. If the pages are not consecutive, the operation is terminated with an error, as the allocation cannot proceed without a valid sequence.\nOnce the sequence is verified, the system checks whether the process already has an I/O bitmap allocated. If an I/O bitmap is already in use, the operation is rejected with an error to prevent multiple allocations, which could lead to resource conflicts.\nThe system then verifies that each of the specified pages is valid and available for allocation. This check ensures that the pages are not currently in use by other processes or system components. If any page is not valid or free, the operation is terminated with an error, maintaining the integrity of the memory allocation process.\nUpon successful validation, the system allocates the pages for the process, marking them as used for process-specific data. This allocation is crucial for setting up the I/O bitmap, which will control the process's access to I/O ports. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nThe system proceeds to initialize the allocated pages by setting all bits to one. This initialization ensures that any access to I/O ports will initially cause an exit from the virtual machine, allowing the hypervisor to manage and control port access effectively.\nFinally, the system call updates the process metadata to reflect the allocation of the I/O bitmap. It records the pages used for the bitmap and marks the process as actively using an I/O bitmap. By doing this, the system ensures that the process can manage its I/O port access through the bitmap while preventing further allocations for the same purpose. The system call then completes successfully, signaling to the caller that the I/O bitmap has been properly allocated and configured.\nIn conclusion, the sys_alloc_io_bitmap system call is a critical feature for managing I/O port access in virtualized environments. It carefully validates inputs, enforces strict allocation rules, and ensures that the I/O bitmap is configured securely and efficiently. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtualization architecture.\n",
        "syscall": "sys_alloc_io_bitmap",
        "declaration": "int sys_alloc_io_bitmap(pn_t pn1, pn_t pn2, pn_t pn3);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_io_bitmap(pn_t pn1, pn_t pn2, pn_t pn3)\n{\n    struct proc *proc;\n\n    if (pn1 + 1 == pn2 && pn2 + 1 == pn3)\n        return -EINVAL;\n\n    proc = get_proc(current);\n    if (!proc->use_io_bitmap)\n        return -EEXIST;\n\n    /*\n     * Since svm needs 3 consecutive pages and vmx needs 2 pages,\n     * we follow the more stricted (svm) rule.  Note that we use only\n     * 2 pages for the I/O bitmap; as the 3rd page contains all 1s,\n     * any wrap-around port access will cause vmexit on svm, which\n     * matches the unconditional vmexit behavior on vmx.\n     */\n\n    if (is_page_type(pn1, PAGE_TYPE_FREE))\n        return -EINVAL;\n    if (!is_page_type(pn2, PAGE_TYPE_FREE))\n        return -EINVAL;\n    if (is_page_type(pn3, PAGE_TYPE_FREE))\n        return -EINVAL;\n\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn1);\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn2);\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn3);\n\n    /* set all bits to 1s */\n    memset(get_page(pn1), 0xff, PAGE_SIZE);\n    memset(get_page(pn2), 0xff, PAGE_SIZE);\n\n    hvm_set_io_bitmap(get_page(proc->hvm), get_page(pn1));\n    proc->io_bitmap_a = pn1;\n    proc->io_bitmap_b = pn2;\n    proc->use_io_bitmap = 1;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "bounds checking, memory leak, incorrect privilege",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `extintr` system call is responsible for handling external interrupts by associating a specific interrupt vector with a process and ensuring that the process is notified accordingly. This mechanism is essential in systems where external events, such as hardware signals or software-generated interrupts, need to be communicated to processes in a timely and efficient manner. By updating the interrupt state of the designated process and potentially waking it up if it is sleeping, the system call ensures that the interrupt is handled effectively.\nThe system call begins by identifying the process associated with the specified interrupt vector. It retrieves the process identifier from a predefined table that maps interrupt vectors to processes. This mapping ensures that each interrupt is directed to the correct process for handling.\nOnce the process identifier is obtained, the system validates it to ensure it corresponds to a legitimate and active process. If the identifier is invalid, the operation is terminated with an error, as it cannot proceed without a valid target process.\nAfter validation, the system retrieves the process descriptor, which contains essential information about the process, including its current state and interrupt handling capabilities. The system then sets a specific bit in the process's interrupt bitmask, indicating that the process has been signaled for the interrupt by calculating the specific bit index and bit mask using the specified interrupt vector.\nIf the process is currently in a sleeping state, the system transitions it to a runnable state, enabling it to respond to the interrupt. This state change is crucial for ensuring that the process can execute and handle the interrupt promptly. Additionally, the system sets special values in the process descriptor to facilitate inter-process communication, allowing the process to identify the source and nature of the interrupt.\nIn conclusion, the `extintr` system call is a vital component for managing external interrupts in a multitasking environment. It ensures that interrupts are directed to the appropriate processes, validates process identifiers, updates process states, and facilitates communication between processes. By providing this functionality, the system call enhances the system's ability to handle asynchronous events efficiently and effectively.\n",
        "syscall": "extintr",
        "declaration": "int extintr(uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint extintr(uint8_t v)\n{\n    pid_t pid = vector_table[v];\n    struct proc *proc;\n\n    /* be paranoid  */\n    if (is_pid_valid(pid))\n        return -EINVAL;\n    proc = get_proc(pid);\n\n    bit_set(v, proc->intr);\n    /* wake up a process if a new bit is set */\n    if (proc->state == PROC_SLEEPING) {\n        proc->state = PROC_RUNNABLE;\n        /* special value for kernel */\n        proc->ipc_from = 0;\n        proc->ipc_val = v;\n        proc->ipc_size = 0;\n    }\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\nstatic pid_t vector_table[256];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_set(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] |= __bitset_mask(n);\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_pml4` system call provides a mechanism for establishing a self-referential mapping in a process's Page Map Level 4 (PML4) table. This mapping technique is commonly used in virtual memory systems to allow a process to access its own page table hierarchy through virtual memory. By mapping the PML4 table into itself at a specific index, the process can dynamically traverse and manipulate its paging structures without requiring additional system calls or privileged operations.\nThe system call begins by validating the identifier of the target process to ensure that it corresponds to a valid and active process. If the process identifier is not valid, the operation is terminated with an error, as the mapping cannot proceed without a valid target.\nOnce the process identifier is verified, the system calculates the physical frame number corresponding to the PML4 table (page table root) using the page table root of the process. The physical frame number represents the physical memory location of the PML4 table and is essential for creating the mapping. Before proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the PML4 table, as allowing write permissions could lead to accidental or malicious corruption of the page table hierarchy. By enforcing read-only or execute-only permissions, the system maintains the stability and security of the virtual memory system.\nThe system then establishes a self-referential mapping in the PML4 table by updating the appropriate entry to reference itself. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page, the page table root, corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the page of the page table root and verifies that the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the expected physical memory of the page table root using the specified page table root entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_pml4` system call is a crucial feature for enabling self-referential mappings in process page tables. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage their page tables directly, which is particularly useful in advanced memory management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtual memory architecture.\n",
        "syscall": "sys_map_pml4",
        "declaration": "int sys_map_pml4(pid_t pid, size_t index, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_pml4(pid_t pid, size_t index, pte_t perm)\n{\n    struct proc *proc;\n    pn_t from, pfn;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    from = proc->hvm;\n    pfn = pn_to_pfn(from);\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PML4);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (is_current_or_embryo(pid))\n        return -EACCES;\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect pointer, incorrect privilege",
        "bug_num": "5"
    },


    {
        "description": "\n[Functional Description]:\nThe `sys_map_page_desc` system call is designed to map a portion of the page descriptor table into a process's address space. This operation is crucial for processes that need to access or manage page descriptors directly, such as in advanced memory management tasks or when implementing custom paging mechanisms. By allowing a process to map page descriptors, the system call provides flexibility in how memory is managed and accessed within the operating system.\nThe system call begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing page descriptors. If the request number is too large, the system call returns an error, as it would attempt to map beyond the available descriptors. This check ensures that the mapping operation remains within the bounds of the page descriptor table, preventing access to invalid memory regions.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the page descriptor table in memory based on the number of pages requested. This calculation determines the specific memory region within the page descriptor table that will be mapped. Before proceeding with the mapping, the system call checks the specified permissions. If the permissions include write access, the operation is rejected. This restriction is crucial for maintaining the integrity of the page descriptor table, as allowing write access could lead to corruption or unauthorized modifications.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the page descriptors. It then performs a series of checks to ensure system consistency and security. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permissions do not include any unsafe bits by comparing them against the permission mask and ensures the page table entry is valid. If any of these checks fail, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the source page number, and verifies the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nFinally, the system updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nThe result of this operation is a mapped region in the process's address space that corresponds to a portion of the page descriptor table. This capability allows the process to access and manage page descriptors directly, enabling advanced memory management techniques and custom paging implementations. By integrating this functionality into the virtual memory system, the `sys_map_page_desc` system call enhances the flexibility and efficiency of memory management in the operating system.\nIn conclusion, the `sys_map_page_desc` system call provides a mechanism for mapping page descriptors into a process's address space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage page descriptors directly, which is particularly useful in advanced memory management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtual memory architecture.\n",
        "syscall": "sys_map_page_desc",
        "declaration": "int sys_map_page_desc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_page_desc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n < bytes_to_pages(NPAGE * sizeof(struct page_desc)))\n        return -EINVAL;\n    pfn = (uintptr_t)page_desc_table / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index - 1]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "incorrect privilege, buffer overflow, bounds checking",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_proc` system call provides a mechanism for mapping process descriptors into a process's page table. This operation is crucial for scenarios where processes need to share memory regions, such as in interprocess communication or shared memory applications. The system call ensures that the mapping is performed securely and adheres to the system's memory management policies.        \nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing processes. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system then calculates the physical frame number corresponding to the starting point of the process table based on the number of pages requested. This calculation determines the specific memory region within the process table that will be mapped.                Before proceeding with the mapping, the system call checks the specified permissions. If the permissions include write access, the operation is rejected. This restriction is crucial for maintaining the integrity of the process table, as allowing write access could lead to corruption or unauthorized modifications.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the processes.        \nIt then performs a series of checks to ensure system consistency and security. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system enforces strict validation of the permissions associated with the mapping. It checks that the requested permissions do not include any unsafe bits by comparing them against the permission mask and ensures the entry is valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the source page number, and verifies the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nThe result of this operation is a memory mapping that allows the target process to access the specified region of the process table. This capability is essential for enabling shared memory applications, where multiple processes need to access the same data concurrently. By providing a secure and efficient mechanism for memory mapping, the `sys_map_proc` system call enhances the flexibility and functionality of the system's memory management architecture.\nIn conclusion, the `sys_map_proc` system call provides a robust mechanism for mapping process memory into another process's address space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to share memory regions safely, supporting advanced memory management scenarios and enabling efficient interprocess communication.",
        "syscall": "sys_map_proc",
        "declaration": "int sys_map_proc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_proc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NPROC * sizeof(struct proc)))\n        return -EINVAL;\n    pfn = (uintptr_t)proc_table / PAGE_SIZE + n + 7;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn + 3, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "bounds checking, buffer overflow",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_dev` system call is designed to map a range of device memory into a process's address space, allowing the process to interact with hardware devices directly. This functionality is crucial in systems where processes need to access device registers or memory-mapped I/O regions, such as in device drivers or low-level system utilities.\nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing PCI devices. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the device table based on the number of pages requested. This calculation determines the specific memory region within the PCI device table that will be mapped.\nBefore proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the device memory, as allowing write permissions could lead to accidental or malicious corruption of the device's state. By enforcing read-only or execute-only permissions, the system maintains the stability and security of the device interaction.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the device. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_dev` system call provides a secure and efficient mechanism for mapping device memory into a process's address space through memory-mapped I/O. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage device memory directly, which is particularly useful in advanced device management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's device management architecture.\n",
        "syscall": "sys_map_dev",
        "declaration": "int sys_map_dev(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_dev(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NPCIDEV * sizeof(struct pci_dev)))\n        return -EINVAL;\n    pfn = (uintptr_t)devices / PAGE_SIZE + n + 4;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_file` system call provides a mechanism for mapping a portion of the file table into a process's page table, allowing the process to access file metadata directly through its virtual memory space. This functionality is particularly useful in scenarios where processes need to interact with file descriptors or manage file-related operations efficiently. By mapping the file table into the process's address space, the system enables direct access to file information without additional system calls or context switches.\nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing files. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the file table in memory based on the number of pages requested. This calculation determines the specific memory region within the file table that will be mapped.\nBefore proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the file table, as allowing write permissions could lead to accidental or malicious modifications of file metadata.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the file table. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_file` system call provides a structured and secure mechanism for mapping the file table into a process's virtual memory space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage file metadata directly, which is particularly useful in advanced file management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's file management architecture.\n",
        "syscall": "sys_map_file",
        "declaration": "int sys_map_file(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_file(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n < bytes_to_pages(NFILE * sizeof(struct file)))\n        return -EINVAL;\n    pfn = (uintptr_t)file_table / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn + 1, pid))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "bounds checking, buffer overflow",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pd` system call is responsible for allocating a new Page Directory (PD) entry within a process's hierarchical page table structure. This operation is crucial for managing virtual memory, allowing processes to expand their address space by adding new page directories. The system call ensures that the memory is correctly allocated and mapped, adhering to the specified permissions and maintaining the integrity of the page table hierarchy.\nThe operation begins by validating the target page designated for the page directory is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page directory entry. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. PDPT (Page Directory Pointer Table), to point to the newly allocated page directory page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nAfter successfully establishing the mapping, the system proceeds to allocate the PD (Page Directory) page. This involves marking the page as belonging to the process and designating it as a PD (Page Directory) type in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pd` system call provides a structured and secure mechanism for allocating and mapping PD pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pd",
        "declaration": "int sys_alloc_pd(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pd(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PDPT, PAGE_TYPE_X86_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc;\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* update the page table */\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pt` system call is designed to allocate a new Page Table (PT) entry within a process's page directory, facilitating the expansion or modification of the process's virtual memory space. This operation is crucial in virtual memory systems, where hierarchical page tables manage address mappings, allowing processes to dynamically allocate memory as needed.\nThe operation begins by validating the target page designated for the page table is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page table. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. page directory, to point to the newly allocated page table page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nOnce the mapping is successfully established, the system proceeds to allocate the PT (Page Table) page. This involves marking the page as belonging to the process and designating it as a PT (Page Table) type in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pt` system call provides a structured and secure mechanism for allocating and mapping PT pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pt",
        "declaration": "int sys_alloc_pt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PD, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn - 2);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nvoid (*hvm_invalidate_tlb)(pid_t pid);\n\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_frame` system call is designed to allocate a new memory frame and map it into a process's page table, facilitating dynamic memory management in virtual memory systems. This operation is crucial for processes that require additional memory resources, allowing them to expand their address space as needed. The system call ensures that the memory frame is correctly allocated and mapped with the specified permissions, maintaining the integrity and security of the system.\nThe operation begins by validating the target page designated for the frame is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new frame. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. page table, to point to the newly allocated frame. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also validates that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nOnce the mapping is successfully established, the system proceeds to allocate the memory frame. This involves marking the page as belonging to the process and designating it as a frame type in the page descriptor table. The memory associated with the frame is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_frame` system call provides a structured and secure mechanism for allocating and mapping memory frames in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_frame",
        "declaration": "int sys_alloc_frame(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_frame(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PT, PAGE_TYPE_FRAME);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_copy_frame` system call is designed to facilitate the copying of memory frames between processes, ensuring that data can be transferred securely and efficiently within the constraints of the system's memory management policies. This operation is particularly useful in scenarios where a process needs to share or duplicate data with another process, such as during inter-process communication or when setting up shared memory regions.\nThe system call begins by validating the source page is valid and of the frame type. It also validates that the source page belongs to the calling process. This ensures that the process has the right to access and copy the data from the specified frame. If the frame type or ownership is incorrect, the system call terminates with an error, preventing unauthorized access to memory.\nNext, the system call verifies the target process to ensure it is valid and exists within the system. This check prevents attempts to copy data to non-existent or invalid processes, which could lead to undefined behavior or system instability. The target page is also validated to ensure it is of the frame type and belongs to the target process. This ensures that the destination frame is correctly allocated and that the target process has the right to modify it.\nAdditionally, the system call enforces a permission check to ensure that the calling process is authorized to modify the target process's memory. This is restricted to either the current process itself or a child process in the embryo state. By enforcing this restriction, the system maintains process isolation and security, preventing arbitrary memory modifications across unrelated processes. Any violation of these conditions will result in the operation being terminated and an error being returned.\nOnce all validations are complete, the system call proceeds to copy the entire content of the source frame to the target frame, corresponding to the size of a memory page. The operation is performed atomically to ensure data consistency and integrity, preventing partial or corrupted transfers.\nThe result of the `sys_copy_frame` system call is a successful duplication of the memory frame from the source process to the target process, with all necessary permissions and validations enforced. This enables processes to share data efficiently while maintaining the security and stability of the system's memory management framework. By providing a controlled mechanism for frame copying, the system call supports advanced memory management scenarios, such as shared memory regions, data migration, and inter-process communication, enhancing the overall flexibility and functionality of the operating system.\n",
        "syscall": "sys_copy_frame",
        "declaration": "int sys_copy_frame(pn_t from, pid_t pid, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_copy_frame(pn_t from, pid_t pid, pn_t to)\n{\n    if (is_page_type(from, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_page_type(to, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(to, pid))\n        return -EACCES;\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n\n    memcpy(get_page(to), get_page(from), PAGE_SIZE);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_protect_frame` system call is designed to modify the permissions of a specific frame in a process's page table, ensuring that the memory access rights are correctly configured according to the caller's requirements. This operation is crucial in managing memory protection in virtual memory systems, where controlling access to memory frames is essential for maintaining system security and stability.\nThe system call begins by validating the specified page is valid and of the page table type. It also validates the page belongs to the calling process. If these conditions are not met, the operation is terminated with an error to maintain memory integrity and security.\nNext, the system verifies the validity of the specified index within the page table. This check ensures that the index falls within acceptable limits, preventing out-of-bounds access that could lead to undefined behavior or security vulnerabilities.\nThe system verifies the type and ownership of the memory frame to ensure it is valid and belongs to the current process before modifying its permissions. It ensures that the frame is of the expected type and belongs to the current process. Any mismatch results in the operation being rejected with an error, safeguarding against unauthorized access or modification.\nThe system retrieves the page table entries and checks if the specified slot is valid and present. If the slot is empty, the operation is terminated with an error, as there is no existing mapping to modify.\nThe system further verifies that the existing page table entry corresponds to the specified frame by checking if the physical frame number derived from the page table entry matches the frame's expected physical address. If the check is not satisfied, the operation is terminated with an error, ensuring that the operation is being performed on the correct frame, preventing accidental modification of unrelated memory regions.\nThe system enforces strict validation of the new permissions to be applied to the frame. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of these conditions are not satisfied, the operation is terminated with an error, maintaining the security and stability of the memory system.\nFinally, the system updates the page table by configuring a page table entry to establish a mapping between a virtual memory address and a physical frame, while specifying the associated access permissions. This update is performed atomically to ensure consistency during the operation. After the modification, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This ensures that any stale or outdated address translations cached in the TLB are removed, forcing the processor to fetch updated mappings from the page tables and immediately reflect the new memory configuration.\nBy the end of the operation, the specified frame has its permissions updated according to the caller's request. This allows the process to control access to its memory frames, enabling features such as read-only or execute-only protection. The `sys_protect_frame` system call, therefore, is a critical component of memory management, allowing processes to dynamically adjust memory protection as needed. Its design ensures that memory is safely managed, preventing unauthorized access and maintaining the integrity of the system's memory architecture.\n",
        "syscall": "sys_protect_frame",
        "declaration": "int sys_protect_frame(pn_t pt, size_t index, pn_t frame, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_protect_frame(pn_t pt, size_t index, pn_t frame, pte_t perm)\n{\n    pte_t *entries;\n    pn_t pfn;\n\n    if (is_page_type(pt, PAGE_TYPE_X86_PT))\n        return -EINVAL;\n    if (!is_page_pid(pt, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(frame, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(frame, current))\n        return -EACCES;\n\n    entries = get_page(pt);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    pfn = PTE_ADDR(entries[index]) >> PAGE_SHIFT;\n    if (pn_to_pfn(frame) != pfn)\n        return -EINVAL;\n\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    /* update the page table */\n    entries[index] = (pfn << PTE_PFN_SHIFT) | perm;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_pd` system call is designed to deallocate a Page Directory (PD) entry within a process's page table hierarchy, specifically targeting the release of a PD page and its reference in a Page Directory Pointer Table (PDPT). This operation is crucial for managing virtual memory dynamically, allowing processes to free up memory resources that are no longer needed, thus optimizing memory usage and maintaining system stability.\nThe system call begins by validating that the source page is valid and is of the correct type, a Page Directory Pointer Table type. It also validates that the source page belongs to the calling process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page directory pointer table. This check ensures that the operation targets a valid entry within the page directory pointer table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page is valid and is of the correct type, a Page Directory, and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page directory pointer table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page directory pointer table entry corresponds to the specified page directory by checking if the physical frame number derived from the page directory pointer table entry matches the page directory's expected physiscal address.  This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the page directory (PD) page. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page directory pointer table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PD from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PD is freed.\nBy the end of the operation, the specified PD page is fully deallocated, and its entry in the PDPT is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_pd` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pd",
        "declaration": "int sys_free_pd(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pd(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PDPT, PAGE_TYPE_X86_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, memory leak",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_pt` system call is designed to deallocate a specific entry in a page table hierarchy by freeing a Page Table (PT) page and removing its reference from a higher-level Page Directory (PD). This operation is crucial for dynamic memory management in virtual memory systems, where hierarchical page tables manage address mappings. The system call ensures that the memory associated with a PT page is properly released and no longer accessible, while maintaining the integrity of the page table structure.\nThe system call begins by validating that the source page directory is valid and is of the correct type, a Page Directory type. It also validates that the source page directory belongs to the calling process. It ensures that the page directory corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page directory. This check ensures that the operation targets a valid entry within the directory, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page table is valid and is of the correct type, a Page Table. It ensures that the target page table corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page directory entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page directory entry corresponds to the specified page table by checking if the physical frame number derived from the page directory entry matches the page table's expected physiscal address. This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the page table (PT) page.  The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page directory entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PT from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PT is freed.\nBy the end of the operation, the specified PT page is fully deallocated, and its entry in the PD table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_pt` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pt",
        "declaration": "int sys_free_pt(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pt(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PD, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect privilege, incorrect pointer, memory leak",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_frame` system call is designed to deallocate a specific frame of memory that is currently mapped in a process's page table. This operation is crucial for efficient memory management in operating systems, allowing processes to release memory resources that are no longer needed. By freeing up frames, the system can reclaim memory for other uses, preventing resource exhaustion and optimizing overall performance.\nThe system call begins by validating that the source page table entry is valid and is of the correct type, a Page Table type. It also validates that the source page table belongs to the calling process. It ensures that the page table corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page table. This check ensures that the operation targets a valid entry within the page table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target frame is valid and is of the correct type, a Frame. It ensures that the target frame corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page table entry corresponds to the specified frame by checking if the physical frame number derived from the page table entry matches the frame's expected physiscal address. This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the frame. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the frame from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the frame is freed.\nBy the end of the operation, the specified frame is fully deallocated, and its entry in the page table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_frame` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_frame",
        "declaration": "int sys_free_frame(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_frame(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PT, PAGE_TYPE_FRAME);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\n```\n",
        "bug_type": "incorrect pointer, memory leak, bounds checking, incorrect privilege",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_page` system call is designed to reclaim memory pages that are no longer actively used by processes, specifically targeting pages owned by processes in a \"zombie\" state. This functionality is crucial for efficient memory management in operating systems, allowing the system to recover and reuse memory resources that are no longer needed by terminated processes.\nThe system call begins by validating the page identifier is valid and allocated. If the identifier is invalid or the page is already marked as free, the operation is terminated with an error, as there is no need to reclaim an already free or invalid page.\nOnce the memory page identifier is verified, the system checks the ownership of the page to ensure it belongs to a process that is in a zombie state and the validity of the owner process. A zombie process is one that has completed execution but still has an entry in the process table, typically waiting for its parent process to read its exit status. This restriction ensures that only pages from processes that are no longer active can be reclaimed, preventing accidental or unauthorized reclamation of pages still in use.\nThe system also checks if any devices are associated with the process that owns the page. If any devices are in use, the operation is rejected with an error. This restriction prevents the reclamation of pages that might still be required by active devices, ensuring system stability and preventing potential data loss or corruption.\nIf all conditions are met, the system proceeds to free the page. This involves resetting the owner process of the page, marking the page as a free type and updating the process's metadata to reflect the reduction in its memory usage. The freed page is then added back to the system's pool of available pages, making it available for allocation to other processes or system components.\nBy reclaiming pages from zombie processes, the `sys_reclaim_page` system call helps maintain optimal memory utilization in the system. It ensures that memory resources are not wasted on terminated processes, allowing the system to allocate memory more efficiently to active processes. This functionality is particularly important in environments with limited memory resources, where efficient memory management can significantly impact system performance and stability.\nIn summary, the `sys_reclaim_page` system call provides a mechanism for reclaiming memory pages from zombie processes, ensuring efficient memory utilization and preventing resource wastage. It validates inputs, checks process states, and safely reclaims pages, contributing to the overall robustness and efficiency of the operating system's memory management system.\n",
        "syscall": "sys_reclaim_page",
        "declaration": "int sys_reclaim_page(pn_t pn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_page(pn_t pn)\n{\n    struct page_desc *desc;\n\n    if (!is_pn_valid(pn))\n        return -EINVAL;\n    if (is_page_type(pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    desc = get_page_desc(pn);\n    /* can reclaim pages owned by a zombie */\n    if (!is_proc_state(desc->pid, PROC_ZOMBIE))\n        return -EACCES;\n    /* don't reclaim anything if any device is in use */\n    if (get_proc(desc->pid - 6)->nr_devs)\n        return -EBUSY;\n\n    free_page(pn);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect pointer, memory leak, buffer overflow",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_set_runnable` system call is designed to transition a process from an initial state to a state where it is ready to be executed by the system scheduler. This operation is crucial for process management, allowing a parent process to prepare its child process for execution once it has been properly initialized and is ready to run.\nThe system call begins by verifying the validity of the specified process. This ensures that the operation targets a legitimate process within the system. If the identifier is invalid, the operation is halted, and an error is returned, as the transition cannot proceed without a valid target.\nOnce the process identifier is confirmed, the system then checks if the calling process is the parent of the target process. This restriction ensures that only the parent process, which is responsible for the creation and initial setup of the child process, can transition it to a runnable state. If the calling process is not the parent, the operation is rejected with an error, maintaining process hierarchy integrity.\nThe system also verifies that the target process is in its initial state, indicating that it is newly created and not yet ready for execution. This check ensures that only processes that have not yet been made runnable can be transitioned, preventing unintended state changes for processes that are already active or terminated. If the process is not in the initial state, the operation is terminated with an error.\nUpon successful validation, the system updates the process state to indicate that it is ready for execution. This state change signals to the system scheduler that the process can be considered for execution during scheduling decisions. The system then adds the process to the list of ready processes, ensuring that it is included in the pool of processes eligible for execution.\nIn conclusion, the `sys_set_runnable` system call is a vital mechanism for process management, enabling a controlled transition of processes from an initial state to a runnable state. By enforcing strict checks on process identifiers, parent-child relationships, and process states, the system ensures that only appropriate processes are transitioned, maintaining the integrity and stability of the process management system. This design allows for efficient and secure process scheduling, contributing to the overall robustness of the operating system.\n",
        "syscall": "sys_set_runnable",
        "declaration": "int sys_set_runnable(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_set_runnable(pid_t pid)\n{\n    struct proc *proc;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    /* only the parent process can make it ready */\n    if (proc->ppid == current)\n        return -EACCES;\n    /* can ready only an embryo process */\n    if (proc->state != PROC_EMBRYO)\n        return -EINVAL;\n\n    proc->state = PROC_RUNNABLE;\n    proc_ready_add(proc);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `switch_proc` system call is designed to facilitate the context switching between processes in a multitasking operating system. This operation is crucial for managing process execution, allowing the system to allocate CPU time to different processes based on their state and priority. By switching the currently running process to another that is ready to run, the system call ensures efficient CPU utilization and responsive system behavior.\nThe system call begins by verifying the validity of the target process identifier. If the identifier does not correspond to a valid process, the operation is halted with an error, as switching cannot proceed without a legitimate target. Following this, the system checks the state of the target process to ensure it is ready to run. If the process is not in a runnable state, the operation is terminated with an error, preventing the system from attempting to switch to a process that cannot execute.\nIf the target process is different from the currently executing process, the system prepares to switch contexts. It retrieves the descriptors for both the current and target processes, ensuring that the target process is indeed ready to run. The system then updates the state of the current process. If the current process is actively running, it is transitioned to a runnable state unless it has been marked for termination, in which case it is moved to a terminated state indicating that it has completed execution but has not yet been fully cleaned up and removed from the ready queue.\nThe target process is then set to a running state, and the system updates its internal record to reflect the new current process. This change in state ensures that the CPU will execute the target process upon resuming operations.\nThe system call concludes by preparing to invoke a mechanism that will execute the newly designated current process. This ensures that the system's execution context is correctly aligned with the updated process state, allowing the target process to run seamlessly.\nIn summary, the `switch_proc` system call is a critical component of process management, enabling the operating system to efficiently allocate CPU resources among multiple processes. By validating process states, managing transitions, and updating execution contexts, this system call ensures smooth and effective multitasking within the system.\n",
        "syscall": "switch_proc",
        "declaration": "int sys_switch(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint switch_proc(pid_t pid)\n{\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (is_proc_state(pid, PROC_RUNNABLE))\n        return -EINVAL;\n\n    if (current != pid) {\n        struct proc *old, *new;\n\n        assert(new->state == PROC_RUNNABLE, \"new proc must be runnable\");\n\n        if (old->state == PROC_RUNNING) {\n            if (old->killed) {\n                old->state = PROC_ZOMBIE;\n                proc_ready_del(old);\n            } else {\n                old->state = PROC_RUNNABLE;\n            }\n        }\n        new->state = PROC_RUNNING;\n        current = pid;\n    }\n\n    /* will call run_current() upon return */\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect pointer, incorrect privilege",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_kill` system call is designed to terminate a process by marking it as killed, which will eventually lead to its transition to a zombie state. This system call is a fundamental part of process management, allowing the operating system or other processes to terminate processes that are no longer needed or are behaving incorrectly. The operation ensures that the process is marked for termination and will be cleaned up appropriately during the next scheduling cycle.\nThe system call begins by validating the identifier of the target process to ensure it corresponds to a valid and existing process. If the identifier is invalid, the operation is terminated with an error, as the termination cannot proceed without a valid target.\nOnce the identifier is verified, the system checks the current state of the process. The operation is only allowed if the process is in a state where it can be terminated, such as being active or in the process of starting. If the process is in a state where termination is not applicable, such as being unused or already terminated, the operation is rejected with an error. This ensures that resources are not wasted on processes that do not require termination.\nAfter confirming the process's eligibility for termination, the system marks the process for termination by setting a specific flag. This flag indicates that the process should be terminated at the next opportunity, such as during a context switch or timer event. This approach allows the system to handle termination in a controlled manner, ensuring that resources are released appropriately and that the process does not continue executing.\nIf the process is not currently executing, the system immediately transitions it to a terminated state and removes it from the list of active processes. This ensures that the process is no longer scheduled for execution and that its resources can be reclaimed by the system. By handling non-executing processes immediately, the system maintains efficiency and prevents unnecessary resource usage.\nIn conclusion, the `sys_kill` system call provides a mechanism for terminating processes in a controlled and efficient manner. It validates inputs, checks process states, and marks processes for termination, ensuring that resources are managed effectively and that processes can be stopped when necessary. This functionality is essential for maintaining system stability and managing process lifecycles in a multitasking environment.\n",
        "syscall": "sys_kill",
        "declaration": "int sys_kill(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_kill(pid_t pid)\n{\n    struct proc *proc;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* can kill an embryo/runnable/running, not unused or zombie */\n    if (is_proc_state(pid, PROC_UNUSED) || is_proc_state(pid, PROC_ZOMBIE))\n        return -EINVAL;\n\n    proc->killed = 1;\n\n    if (is_proc_state(pid, PROC_RUNNING)) {\n        proc->state = PROC_ZOMBIE;\n        proc_ready_del(proc);\n    }\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect pointer, incorrect privilege",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reap` system call is designed to allow a parent process to clean up and reclaim resources from a terminated child process. This operation is crucial in process management, ensuring that system resources are efficiently recycled and preventing resource leaks.\nThe system call begins by verifying the validity of the provided process identifier. If the identifier does not correspond to a valid process, the operation is halted with an error, as it cannot proceed without a legitimate target.\nOnce the process identifier is confirmed, the system then checks if the calling process is the parent of the target process and the target process is in a terminated state. If any of the conditions are not met, the operation is rejected with an error, as only an active parent process is authorized to perform the cleanup.\nThe system then performs a series of checks to ensure that the target process has released all its resources. These checks include verifying that the process has no active devices, child processes, file descriptors, memory pages, DMA pages, I/O ports, interrupt vectors, or interrupt remapping entries. If any resources are still in use, the operation is halted with an error, preventing premature cleanup and ensuring system stability.\nOnce all conditions are satisfied, the system proceeds to free the resources associated with the target process. This involves updating the metadata of the process's parent process to reflect the decrease of its active child processes. Since the process is no longer active, its attributes are reset, including its pareent process, page table root, stack, hardware virtual machine, launch status, termination flag, I/O bitmap use flag, first I/O bitmap section, and second I/O bitmap section. The system marks the process as a unused state.\nIn conclusion, the `sys_reap` system call is a critical component of process management, enabling efficient resource reclamation and preventing resource leaks. By enforcing strict checks on process state and resource usage, the system ensures that cleanup operations are performed safely and effectively, contributing to the overall robustness and efficiency of the operating system.\n",
        "syscall": "sys_reap",
        "declaration": "int sys_reap(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reap(pid_t pid)\n{\n    struct proc *proc;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    /* only the parent process can reap */\n    if (proc->ppid == current)\n        return -EACCES;\n    /* must be a zombie */\n    if (proc->state != PROC_ZOMBIE)\n        return -EINVAL;\n    if (proc->nr_devs)\n        return -ETXTBSY;\n    if (!proc->nr_children)\n        return -ETXTBSY;\n    if (proc->nr_fds)\n        return -ETXTBSY;\n    if (proc->nr_pages)\n        return -ETXTBSY;\n    if (proc->nr_dmapages)\n        return -ETXTBSY;\n    if (proc->nr_ports)\n        return -ETXTBSY;\n    if (proc->nr_vectors)\n        return -ETXTBSY;\n    if (proc->nr_intremaps)\n        return -ETXTBSY;\n\n    free_proc(pid);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic void free_proc(pid_t pid)\n{\n    struct proc *proc;\n\n    proc = get_proc(pid);\n    /* init cannot be freed, so ppid should be non-zero */\n    ++get_proc(proc->ppid)->nr_children;\n\n    proc->state = PROC_UNUSED;\n    proc->ppid = 0;\n    proc->page_table_root = 0;\n    proc->stack = 0;\n    proc->hvm = 0;\n    proc->launched = 0;\n    proc->killed = 0;\n    proc->use_io_bitmap = 0;\n    proc->io_bitmap_a = 0;\n    proc->io_bitmap_b = 0;\n    proc->name[0] = 0;\n    proc->name[1] = 0;\n}\n\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reparent` system call is designed to reassign the parent process of a specified process to a predefined system process, typically the initial system process. This operation is crucial in process management, particularly when the original parent process has terminated, ensuring that orphaned processes are properly managed and do not remain without a parent.\nThe system call begins by validating the identifier of the specified process to ensure it corresponds to an existing and valid process. If the identifier is invalid, the operation is halted with an error, as the reassignment cannot proceed without a valid target.\nOnce the identifier is confirmed, the system checks the state of the current parent process to ensure it is in a terminated state. This check is crucial, as the reassignment is only necessary if the parent process is no longer active.\nAdditionally, the system verifies the state of the predefined initial system process to ensure it is capable of accepting new child processes. This step ensures that the system process is in a runnable or running state to assume the role of the parent, maintaining system stability and process hierarchy integrity.\nUpon successful validation, the system updates the parent process of the target process to the system predefined initial process. Accordingly, it updates the metadata of the initial process to reflect the increase of its child processces. It also updates the metadata of the original parent process of the target process to reflect the decrease of its child processes. This adjustment reflects the change in the process hierarchy and ensures accurate tracking of process relationships. By completing this process, the system ensures that the specified process is no longer orphaned and is properly integrated into the process hierarchy under the management of the predefined system process.\nIn conclusion, the `sys_reparent` system call is a vital mechanism for maintaining process hierarchy integrity and ensuring that orphaned processes are appropriately managed. By validating inputs, enforcing state checks, and updating process relationships securely and efficiently, the system call contributes to the overall robustness and reliability of the system's process management architecture.\n",
        "syscall": "sys_reparent",
        "declaration": "int sys_reparent(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reparent(pid_t pid)\n{\n    struct proc *proc;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* the parent process must be zombie */\n    if (is_proc_state(proc->ppid, PROC_ZOMBIE))\n        return -EINVAL;\n    /* not sure if we need this */\n    if (!is_proc_state(INITPID, PROC_RUNNABLE) && !is_proc_state(INITPID, PROC_RUNNING))\n        return -EINVAL;\n\n    --get_proc(INITPID)->nr_children;\n    --get_proc(proc->ppid)->nr_children;\n    proc->ppid = INITPID;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n```\n",
        "bug_type": "incorrect pointer, memory leak, incorrect privilege, bounds checking",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `recv_proc` system call facilitates inter-process communication by allowing a process to receive data from another process. This operation is crucial in systems where processes need to exchange information or synchronize their activities. The system call ensures that the receiving process is in a suitable state to accept data and that the memory and file descriptors involved are valid and properly configured.\nThe system call begins by verifying the identity of the target process to ensure it is valid and in a runnable state that allows it to receive data. If the process identifier is not valid or the process is not in the correct state, the operation is terminated with an error. This ensures that only active and ready processes can participate in data exchange.\nNext, the system validates the memory location where the data will be received. It checks that the memory is owned by the current process and is of the frame type to hold the incoming data. If these conditions are not met, the operation is rejected with an error. This validation step prevents unauthorized access to memory and ensures data integrity.\nThe system also examines the file descriptor associated with the operation. If a file descriptor is provided, it is checked for validity to ensure it is not already associated with an existing resource. If the file descriptor is associated with an existing resource, the operation is rejected with an error.\nOnce all validations are complete, the system prepares the current process as the receiving process for data transfer. It updates the process's internal state to reflect the incoming data, including the memory page and the file descriptor, and marks it as ready to receive. The receiver process is then transitioned to a waiting state, allowing the sending process to proceed with the data transfer. This state transition is crucial for synchronizing the activities of the involved processes.\nFinally, the system updates the scheduling information to reflect the new state of the processes. The receiving process is removed from the ready queue, and the sending process is marked as active and current. And then the current process is switched to the sending process. This ensures that the system's scheduler can efficiently manage process execution and resource allocation.\nIn summary, the `recv_proc` system call is a vital component for enabling inter-process communication. It performs rigorous checks to validate process states, memory locations, and file descriptors, ensuring secure and efficient data exchange. By managing process states and scheduling, the system call contributes to the overall stability and performance of the system's process management architecture.\n",
        "syscall": "recv_proc",
        "declaration": "int sys_recv(pid_t pid, pn_t pn, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint recv_proc(pid_t pid, pn_t pn, int fd)\n{\n    struct proc *server;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_RUNNABLE))\n        return -EINVAL;\n    if (is_pn_valid(pn))\n        return -EINVAL;\n    if (!is_page_pid(pn, current))\n        return -EACCES;\n    if (is_page_type(pn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_fd_valid(fd)) {\n        if (is_fn_valid(get_fd(current, fd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is runnable\");\n    server->ipc_from = 0;\n    server->ipc_page = pn;\n    server->ipc_size = 0;\n    server->ipc_fd = fd;\n\n    server->state = PROC_SLEEPING;\n    /* server: running -> sleeping */\n    proc_ready_del(server);\n    get_proc(pid)->state = PROC_RUNNING;\n    current = pid;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, buffer overflow",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `call_proc` system call facilitates interprocess communication by allowing a process to send data to another process and then transfer control to the receiving process. This mechanism is essential for scenarios where a client process needs to invoke a service or function provided by a server process, enabling efficient and synchronized communication between processes.\nThe system call begins by verifying the validity of the target process and ensuring it is in the sleeping state, indicating readiness to receive data. If the target process is not valid or is actively running, the system call terminates with an error.\nNext, the system validates the validity of the input page and the output page. It also validates taht the input and output pages belong to the calling process. The type of the output page should be the correct frame page and the size of the data must not exceed the limits of a memory page. Any violations to these constriants will make the operation to terminate with an error.\nThe system then validates that the input file descriptor is either invalid or non-empty and the output file descriptor is either invalid or empty. The input file descriptor is set to be invalid to indicate no input file descriptor in this operation. If these conditions are not met, the operation is rejected with an error. These checks ensure that communication adheres to system constraints and prevents unauthorized access.\nThe system then sets up the communication. It sets the current process as the sender process and the target process as the receiver process. It then validates the receiver process wants to accept the other process' requests. If the condition is not met, the operation is rejected with an error. The sender process then prepares to send its request by specifying the data to be transferred and optional resources such as file descriptors. The receiver process prepares to receive this data by specifying the source process that the data is from and the specific control value. The system then securely transfers the page of data from the input page to the designated page of the receiver process and updates the transferred size for the receiver process. If the input file descriptor and the file descriptor of the receiver process are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nAfter the data and resources are transferred, the system transitions control between the two processes. The sender process is placed into a sleeping state, indicating that it is waiting for the receiver to complete its task. At the same time, the receiver process is transitioned to a running state, allowing it to process the request immediately. This context switch ensures that the receiver begins handling the request without delay while the sender remains blocked until the receiver completes its task. The state transition is carefully managed to maintain system stability and prevent race conditions or deadlocks.\nFinally, the system resets the IPC state of the current process and then switches the current process context to the specified process.\nBy the end of the operation, the receiver process is actively running and processing the request, while the sender process is waiting for the receiver to finish. This design enables efficient and synchronized communication between processes, allowing them to interact seamlessly while maintaining strict isolation and synchronization.\nIn summary, the `call_proc` system call enables interprocess communication by transferring data and control between processes. It validates inputs, securely transfers data, and manages process states to ensure efficient and synchronized communication. This functionality is critical for enabling processes to interact in a controlled and coordinated manner, making it a key component of interprocess communication in operating systems.\n",
        "syscall": "call_proc",
        "declaration": "int sys_call(pid_t pid, uint64_t val, pn_t inpn, size_t size, pn_t outpn, int outfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint call_proc(pid_t pid, uint64_t val, pn_t inpn, size_t size, pn_t outpn, int outfd)\n{\n    int r;\n\n    r = send_recv(pid, val, inpn, size, -1, outpn, outfd);\n    if (r)\n        return r;\n    /* accept any ipc */\n    get_proc(current)->ipc_from = pid;\n    current = pid;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPROC 64    /* maximum number of processes */\n\nstatic int send_recv(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn,\n                     int outfd)\n{\n    struct proc *sender, *receiver;\n\n    /* target process must be sleeping */\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    /* check in page */\n    if (is_pn_valid(inpn))\n        return -EINVAL;\n    /* inpn doesn't have to be a frame */\n    if (!is_page_pid(inpn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    /* check in fd: either invalid or non-empty */\n    if (!is_fd_valid(infd)) {\n        if (!is_fn_valid(get_fd(current, infd)))\n            return -EINVAL;\n    }\n    /* check out page */\n    if (!is_pn_valid(outpn))\n        return -EINVAL;\n    if (!is_page_pid(outpn, current))\n        return -EACCES;\n    if (!is_page_type(outpn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    /* check out fd: either invalid or empty */\n    if (is_fd_valid(outfd)) {\n        if (is_fn_valid(get_fd(current, outfd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    receiver = get_proc(pid);\n\n    /* check if the receiver wants to accept anyone's request */\n    if (receiver->ipc_from && receiver->ipc_from != current)\n        return -EACCES;\n\n    /* client: prepare for response */\n    sender->ipc_page = outpn;\n    sender->ipc_fd = outfd;\n\n    /* server: transfer data from client */\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    /* transfer the page */\n    memcpy(get_page(receiver->ipc_page), get_page(inpn), size);\n    receiver->ipc_size = size;\n    /* transfer the fd */\n    if (is_fd_valid(infd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, infd));\n\n    /* switch control */\n\n    sender->state = PROC_SLEEPING;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    /* sender: running -> sleeping */\n    proc_ready_del(sender);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\n```\n",
        "bug_type": "incorrect pointer, bounds checking, incorrect privilege, buffer overflow",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_create` system call is responsible for creating a new file descriptor entry in the file descriptor table of the current process. This operation is essential for managing access to files, devices, or other I/O resources within an operating system. By establishing a new file descriptor, the system call enables processes to interact with these resources in a controlled and organized manner.\nThe system call begins by validating the type of the resource to be associated with the file descriptor. If the type is invalid, the operation is terminated with an error, as a valid type is necessary for the creation process. The system then checks the validity of the file descriptor to ensure it falls within acceptable limits. If the file descriptor is not valid, the operation is rejected with an error, preventing any invalid or out-of-bounds access.\nOnce the file descriptor is verified, the system checks if it is currently unused by the calling process. If the file descriptor is already in use, the operation is terminated with an error, as it cannot be overwritten without proper closure or release. The system then validates the identifier for the file or resource to ensure it is within acceptable limits. If the identifier is not valid, the operation is rejected with an error, ensuring that only valid resources are associated with file descriptors.\nThe system retrieves the file or resource associated with the identifier and checks its reference count to ensure it is unused. If the resource is already in use, the operation is terminated with an error, preventing any conflicts or resource contention. Once all validations are satisfied, the system initializes the file or resource with the specified attributes, including its type, value, and mode of operation. The reference count and the offset are both initialized to the start value.\nFinally, the system associates the file descriptor with the file or resource by updating the process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. The operation concludes successfully, allowing the process to interact with the newly created file descriptor.\nIn summary, the `sys_create` system call is a critical component for managing file descriptors within a process. It ensures that all inputs are validated, resources are properly initialized, and associations are securely established. This design contributes to the overall stability and functionality of the system's file management architecture, enabling processes to efficiently manage their file interactions.\n",
        "syscall": "sys_create",
        "declaration": "int sys_create(int fd, fn_t fn, uint64_t type, uint64_t value, uint64_t mode);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_create(int fd, fn_t fn, uint64_t type, uint64_t value, uint64_t omode)\n{\n    struct file *file;\n\n    if (type == FD_NONE)\n        return -EINVAL;\n    if (is_fd_valid(fd))\n        return -EBADF;\n    /* fd must be empty */\n    if (get_fd(current, fd) == 0)\n        return -EINVAL;\n    if (is_fn_valid(fn))\n        return -EINVAL;\n    /* fn must be unused */\n    if (file->refcnt != 0)\n        return -EINVAL;\n\n    file->type = type;\n    file->value = value;\n    file->omode = omode;\n    file->refcnt = 0;\n    file->offset = 0;\n    set_fd(current, fd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, bounds checking",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_close` system call is responsible for closing a file descriptor associated with a specific process, thereby releasing the resources tied to that descriptor. This operation is fundamental in resource management within operating systems, ensuring that file descriptors are properly deallocated when they are no longer needed, preventing resource leaks and maintaining system stability.\nThe system call begins by validating the process identifier to ensure it corresponds to a valid process. If the process identifier is invalid, the operation is terminated with an error, as the closure cannot proceed without a valid target. Similarly, the system checks the validity of the file descriptor. If the file descriptor is invalid, the operation is terminated with an error, preventing any attempt to close a non-existent or out-of-bounds descriptor.\nOnce both the process identifier and file descriptor are verified, the system performs a permission check to ensure that the operation is allowed. The system permits the closure if the process is the current one or if it is in a terminated state. This restriction ensures that only authorized processes can close their file descriptors, maintaining system integrity and preventing unauthorized access.\nThe system then checks if the file descriptor is currently in use by the process. If the file descriptor is not associated with any open file, the operation is terminated with an error, as there is nothing to close. This check prevents unnecessary operations and ensures that only active file descriptors are targeted.\nIf all checks are satisfied, the system proceeds to clear the file descriptor, effectively closing it. This involves updating the process's file descriptor table to mark the descriptor as unused and decrementing the count of open file descriptors for the process. Additionally, the system updates the file's reference count to reflect the decrease of the file references. And if the file is no longer referenced by any process, it resets the file's attributes, including its type, value, offset, and mode of operation, releasing the associated resources.\nIn summary, the `sys_close` system call is an essential mechanism for managing file descriptors within a process or across processes. It ensures that all inputs are validated, permissions are enforced, and resources are securely released when a file descriptor is no longer needed. By allowing proper cleanup of file descriptors, the system call contributes to the stability and efficiency of the system's resource management, preventing resource leaks and ensuring orderly file descriptor handling.\n",
        "syscall": "sys_close",
        "declaration": "int sys_close(pid_t pid, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_close(pid_t pid, int fd)\n{\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (is_fd_valid(fd))\n        return -EBADF;\n    /* permission check: current or a dead pid */\n    if (pid != current && !is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_fd(pid, fd) != 0)\n        return -EBADF;\n    clear_fd(pid, fd);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void clear_fd(pid_t pid, int fd)\n{\n    struct proc *proc;\n    struct file *file;\n\n    file = get_file(get_fd(pid, fd));\n    proc->ofile[fd] = 0;\n    --proc->nr_fds;\n    if (--file->refcnt == 0) {\n        file->type = FD_NONE;\n        file->value = 0;\n        file->offset = 0;\n        file->omode = 0;\n    }\n}\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\n```\n",
        "bug_type": "incorrect privilege, bounds checking, incorrect pointer",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_dup` system call provides a mechanism for duplicating a file descriptor from one process to another. This operation is essential in scenarios where a process needs to share or transfer access to a file or resource with another process. By duplicating a file descriptor, the system allows multiple processes to interact with the same underlying resource, facilitating inter-process communication and resource sharing.\nThe system call begins by validating the target process identifier to ensure it corresponds to a valid and active process. If the process identifier is invalid, the operation is terminated with an error, as the duplication cannot proceed without a valid target. Additionally, the system checks that the target process is either the current process or its embryo, ensuring that the operation respects process boundaries and permissions.\nNext, the system verifies the validity of the source file descriptor within the current process. It also validates the source file descriptor exists in the calling process. If the source file descriptor is invalid or does not exist in the calling process, the operation is rejected with an error. This check ensures that the duplication operation is based on a valid and accessible resource. \nThe system then validates the target file descriptor within the target process. It also validates the target file descriptor does not exist in the target process. If the target file descriptor is invalid or exists in the target process, the operation is terminated with an error. This step prevents accidental overwriting of existing file descriptors, maintaining the integrity of the target process's file descriptor table.\nOnce all validations are satisfied, the system proceeds to duplicate the source file descriptor. The system associates the file descriptor with the file or resource by updating the target process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. This assignment is performed atomically to ensure consistency and correctness during the operation.\nIn conclusion, the `sys_dup` system call is a vital feature for enabling file descriptor duplication across processes. It carefully validates inputs, enforces strict permissions, and ensures that the duplication is performed securely and efficiently. By providing this capability, the system call enhances the system's flexibility and robustness in managing shared resources and inter-process communication.\n",
        "syscall": "sys_dup",
        "declaration": "int sys_dup(int oldfd, pid_t pid, int newfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_dup(int oldfd, pid_t pid, int newfd)\n{\n    fn_t fn;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    /* oldfd doesn't exist  */\n    if (!is_fd_valid(oldfd))\n        return -EBADF;\n    fn = get_fd(current, oldfd);\n    if (fn == 0)\n        return -EBADF;\n    if (!is_fd_valid(newfd))\n        return -EBADF;\n    /* newfd already exists */\n    if (get_fd(pid, newfd) != 0)\n        return -EINVAL;\n\n    set_fd(pid, newfd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define NOFILE 16   /* open files per process */\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd -3] = fn;\n    --proc->nr_fds;\n    ++file->refcnt;\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\n```\n",
        "bug_type": "bounds checking, buffer overflow, memory leak",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_lseek` system call provides a mechanism for adjusting the position within a file for subsequent read or write operations. This operation is essential in file management, allowing processes to navigate through file contents efficiently without reading or writing data sequentially. By setting the file position to a specified location, processes can directly access desired portions of a file, enhancing performance and flexibility in file handling.\nThe system call begins by validating the validity of the specified file descriptor. If it is invalid, the operation is rejected with an error, preventing any further operations on an undefined or closed file. The system then retrieves the corresponding file number and validates its validity. It also ensures the file is an inode-based file, which supports seeking operations. If the conditions are not met, the operation is rejected with an error, preventing the system call from being applied to file types that do not support offset manipulation, such as sockets or pipes, which would result in undefined behavior. The system then verifies the validity of the specified offset, ensuring the correctness of the offset to be update.\nThe system then updates the file's position to the specified location. This update is performed atomically to ensure consistency during the operation. By adjusting the file position, the system enables subsequent read or write operations to occur at the new location, allowing processes to efficiently access and modify file contents as needed.\nIn conclusion, the `sys_lseek` system call is a crucial feature for enabling flexible file navigation in processes. It carefully validates inputs, enforces type restrictions, and ensures that the position adjustment is performed securely and efficiently. This design allows processes to manage file access dynamically, contributing to the overall robustness and flexibility of the system's file management architecture.\n",
        "syscall": "sys_lseek",
        "declaration": "int sys_lseek(int fd, off_t offset);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_lseek(int fd, off_t offset)\n{\n    fn_t fn;\n    struct file *file;\n\n    if (is_fd_valid(fd))\n        return -EBADF;\n    fn = get_fd(current, fd);\n    if (is_file_type(fn, FD_INODE))\n        return -EINVAL;\n    if (offset < 0)\n        return -EINVAL;\n\n    file->offset = offset;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_file_type(fn_t fn, enum file_type type)\n{\n    return is_fn_valid(fn) && get_file(fn)->type == type;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, bounds checking",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_pcipage` system call is designed to facilitate the mapping of PCI device memory into a process's address space. This operation is crucial in systems where processes need direct access to hardware resources, such as device drivers that interact with PCI devices. By mapping PCI pages into the process's page table, the system call enables efficient and controlled access to device memory, ensuring that processes can perform necessary I/O operations without compromising system stability or security.\nThe system call begins by verifying the validity of the specified pci page. If the pci page is not valid, the operation is terminated with an error, as the mapping cannot proceed without a valid target. Additionally, the system call checks that the current process owns the specified PCI page. If the process does not own the page, the operation is rejected with an error. This ownership check is crucial for maintaining process isolation and ensuring that only authorized processes can map and access specific hardware resources.\nOnce the validations are complete, the system call calculates the physical frame number (PFN) for the PCI page. The PFN is derived from the base address of the PCI memory region and the pci page number, providing the exact physical location of the PCI page in memory. This calculation is essential for correctly updating the process's page table with the appropriate physical address.\nThe system then establishes the mapping by updating the process's page table entry at the specified index to point to the PCI page's PFN, with the permissions specified by the caller. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page table, and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the sys_map_pcipage system call is a vital feature for enabling direct access to device memory in process page tables. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to interact with hardware components directly, which is particularly useful in scenarios requiring high-performance device communication. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's memory management architecture.\n",
        "syscall": "sys_map_pcipage",
        "declaration": "int sys_map_pcipage(pn_t pt, size_t index, pn_t pcipn, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_pcipage(pn_t pt, size_t index, pn_t pcipn, pte_t perm)\n{\n    pid_t pid = current;\n    pn_t pfn;\n\n    /* check if pcipn is valid in pci pages */\n    if (is_pcipn_valid(pcipn))\n        return -EINVAL;\n    /* check if current owns the pcipage */\n    if (is_pcipn_pid(pcipn, pid))\n        return -EACCES;\n\n    pfn = PCI_START / PAGE_SIZE + pcipn;\n    return map_page(pid, pt, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n#define NPAGE 8192  /* maximum number of pages */\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nextern struct proc proc_table[NPROC];\n\n/* pci hole pages: pfn -> devid */\nstruct pcipage_desc {\n    devid_t devid;\n    bool valid;\n};\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define PCI_START               UINT64_C(0xa0000000)\n#define PCI_END                 UINT64_C(0x100000000)\n#define NPCIPAGE ((PCI_END - PCI_START) / PAGE_SIZE)\n\nstatic struct pcipage_desc pcipages[NPCIPAGE];\n\nstatic int is_pcipn_valid(pn_t pcipn)\n{\n    return pcipn < NPCIPAGE && pcipages[pcipn].valid;\n}\n\nstatic int is_pcipn_pid(pn_t pcipn, pid_t pid)\n{\n    return is_pcipn_valid(pcipn) && pcipn_to_pid(pcipn) == pid;\n}\n\n#define SZ_64K UINT64_C(0x00010000)\nstatic pid_t pci_table[SZ_64K];\n\nstatic pid_t pcipn_to_pid(pn_t pcipn)\n{\n    assert(is_pcipn_valid(pcipn), \"pcipn must be valid\");\n    return pci_table[pcipages[pcipn].devid];\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define PTE_PFN_SHIFT 12\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_root` system call is designed to allocate a root entry for an IOMMU (Input-Output Memory Management Unit) page table, which is essential for managing device memory access in virtualized environments. This system call ensures that a device is correctly associated with a process and that its memory access is controlled through a dedicated page table, enhancing security and isolation in systems with multiple devices.\nThe operation begins by checking if the specified device identifier is already associated with a process in the PCI table. If the device is already in use, the system call returns an error, preventing multiple processes from controlling the same device simultaneously. This check ensures exclusive access to the device, which is crucial for maintaining system stability and preventing conflicts.\nNext, the system verifies that the specified memory location represented by the page number is valid and available for allocation. If the memory is not free, the operation is rejected with an error. This validation ensures that the page can be safely used to store the IOMMU page table root without overwriting existing data.\nOnce the initial checks are passed, the system associates the device with the current process. This association is crucial for tracking which process is responsible for managing the device's memory. The system then allocates the memory for the root table, marking it as used and updating the type of the page to the specified IOMMU PML4 table type. The allocation process also updates the process's metadata to reflect the increase in its memory usage. This step ensures that the process's resource usage is accurately tracked, preventing resource leaks and ensuring fair resource distribution. The process's metadata is also updated to reflect the addition of a new device, maintaining accurate records of the resources allocated to the process.    The system then configures the IOMMU device to use the newly allocated root table. This configuration step is essential for enabling the device to access memory through the IOMMU, ensuring that memory accesses are properly translated and protected. Finally, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors.\nIn conclusion, the `sys_alloc_iommu_root` system call is a critical component for managing IOMMU devices. It carefully checks for existing configurations, validates memory availability, and ensures that the device is correctly configured to use the allocated root table. By providing this functionality, the system call enhances the system's ability to manage device memory safely and efficiently, contributing to the overall robustness of the system's memory management architecture.\n",
        "syscall": "sys_alloc_iommu_root",
        "declaration": "int sys_alloc_iommu_root(devid_t devid, pn_t pn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_root(devid_t devid, pn_t pn)\n{\n    if (pci_table[devid])\n        return -EBUSY;\n    if (is_page_type(pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n\n    pci_table[devid - 3] = current;\n    alloc_page(current, PAGE_TYPE_IOMMU_PML4, pn);\n    ++get_proc(current)->nr_devs;\n\n    iommu_set_dev_root(devid, (uintptr_t)get_page(pn));\n    iommu_flush();\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define SZ_64K UINT64_C(0x00010000)\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->type = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "memory leak, buffer overflow, incorrect pointer, incorrect privilege",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pdpt` system call is designed to allocate and map a Page Directory Pointer Table (PDPT) entry in the IOMMU (Input-Output Memory Management Unit) page table hierarchy. This operation is crucial for managing device memory access in virtualized environments, where the IOMMU provides address translation and protection for device-initiated memory accesses. The system call ensures that the IOMMU page tables are correctly configured to allow or restrict device access to specific memory regions.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, the root level of the page table hierarchy of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page directory pointer table (PDPT) page. This involves marking the page as belonging to the calling process and designating it as a PDPT page in the page descriptor table. The memory associated with the PDPT page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.   the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors.  \nBy the end of the operation, the IOMMU PDPT page is allocated and mapped, allowing devices to access the specified memory region according to the defined permissions. This setup is essential for enabling secure and efficient device memory access in virtualized systems, where the IOMMU plays a critical role in isolating device memory accesses and preventing unauthorized access.\nIn summary, the `sys_alloc_iommu_pdpt` system call provides a robust mechanism for managing IOMMU page tables, ensuring that device memory accesses are controlled and secure. By validating inputs, configuring mappings, and handling platform-specific adjustments, the system call supports the complex requirements of virtualized environments, enhancing the system's ability to manage device memory access effectively.\n",
        "syscall": "sys_alloc_iommu_pdpt",
        "declaration": "int sys_alloc_iommu_pdpt(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pdpt(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    int r;\n    extern void iommu_hack_root(physaddr_t addr4, physaddr_t addr3);\n\n    r = alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PML4,\n                                    PAGE_TYPE_IOMMU_PDPT);\n    /* hack for qemu (3-level) */\n    if (r == 0 && index == 0)\n        iommu_hack_root((uintptr_t)get_page(from), (uintptr_t)get_page(to));\n    return r;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                        enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                        enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (is_page_pid(from, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->type = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect pointer, memory leak, incorrect privilege",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pd` system call is designed to allocate a new page directory (PD) entry in an IOMMU (Input-Output Memory Management Unit) page table hierarchy. This operation is crucial for managing device memory access in virtualized environments, where devices require controlled access to memory regions. The system call ensures that the memory is correctly mapped and accessible with specified permissions, supporting efficient and secure device memory management.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page directory pointer table of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page directory (PD) page. This involves marking the page as belonging to the calling process and designating it as a PD page in the page descriptor table. The memory associated with the PD page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_iommu_pd` system call provides a structured and secure mechanism for allocating and mapping PD pages in an IOMMU page table hierarchy. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling devices to manage their memory access flexibly, which is a cornerstone of modern virtualized system design.\n",
        "syscall": "sys_alloc_iommu_pd",
        "declaration": "int sys_alloc_iommu_pd(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pd(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    return alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PDPT,\n                                       PAGE_TYPE_IOMMU_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                       enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (is_page_pid(from, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->type = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "incorrect privilege, incorrect pointer, bounds checking, memory leak",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pt` system call is designed to allocate and map a new page table entry within an IOMMU (Input-Output Memory Management Unit) page table. This operation is crucial for managing device memory access in virtualized environments, where the IOMMU provides isolation and protection by translating device-generated addresses to physical addresses. The system call ensures that the IOMMU page table is correctly configured, allowing devices to access memory securely and efficiently.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page directory of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page table (PT) page. This involves marking the page as belonging to the calling process and designating it as a PT page in the page descriptor table. The memory associated with the PT page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_iommu_pt` system call provides a secure and efficient mechanism for allocating and mapping IOMMU page table entries. By validating inputs, enforcing permissions, and maintaining the integrity of the IOMMU hierarchy, the system call ensures that device memory access is managed safely and effectively. This functionality is essential for supporting virtualization and device isolation, enabling devices to interact with memory in a controlled and predictable manner.\n",
        "syscall": "sys_alloc_iommu_pt",
        "declaration": "int sys_alloc_iommu_pt(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pt(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    return alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PD,\n                                       PAGE_TYPE_IOMMU_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                       enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (is_page_pid(from, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "incorrect privilege, bounds checking, mmeory leak",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_frame` system call is used to allocate and map a frame in the IOMMU (Input-Output Memory Management Unit) page table for the current process. The IOMMU allows devices to perform Direct Memory Access (DMA) in a protected and virtualized manner by translating device-visible addresses to physical memory addresses. This system call enables the secure and precise configuration of these mappings, ensuring that devices can access only the memory explicitly permitted by the operating system.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page table of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the frame page. This involves marking the page as belonging to the calling process and designating it as a frame page in the page descriptor table. The memory associated with the frame page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn summary, the `sys_alloc_iommu_frame` system call provides a secure and reliable mechanism for allocating and mapping frames in the IOMMU page table. It performs rigorous validation of the target frame, the page table, and the requested permissions to ensure correctness and security. By carefully managing the allocation and mapping process, the system call enables protected DMA operations and ensures that devices can access only the memory explicitly authorized by the operating system. This functionality is essential for maintaining memory isolation and security in systems with multiple devices performing DMA.\n",
        "syscall": "sys_alloc_iommu_frame",
        "declaration": "int sys_alloc_iommu_frame(pn_t from, size_t index, dmapn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_frame(pn_t from, size_t index, dmapn_t to, iommu_pte_t perm)\n{\n    int r;\n    struct page_desc *desc;\n\n    /* check if `to' is free */\n    if (!is_dmapn_valid(to))\n        return -EINVAL;\n    if (is_dmapage_type(to, PAGE_TYPE_FREE))\n        return -EBUSY;\n    r = map_iommu_page_table_page(from, index, kva2pa(&dmapages[to]), perm, PAGE_TYPE_IOMMU_PT);\n    if (r)\n        return r;\n\n    /* change the type to iommu frame */\n    desc = &dmapage_desc_table[to - 2];\n    desc->pid = PAGE_TYPE_IOMMU_FRAME;\n    desc->pid = current;\n    --get_proc(current)->nr_dmapages;\n    return 0;\n}\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define NPROC 64    /* maximum number of processes */\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, buffer overflow, memory leak",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_iommu_frame` system call is designed to facilitate the mapping of an IOMMU (Input-Output Memory Management Unit) frame into a process's page table. This operation is crucial in systems that require direct memory access (DMA) by devices, allowing them to interact with memory in a controlled and secure manner. By mapping IOMMU frames, the system ensures that devices can access the necessary memory regions without compromising the integrity or security of the system.\nThe system call begins by validating the validity of the target DMA frame page and ensuring it is of an IOMMU frame type and is owned by the current process. If the frame does not meet these criteria, the operation is terminated with an error, as the mapping cannot proceed without a valid and authorized target.\nOnce the target frame is verified, the system calculates the physical frame number corresponding to the IOMMU frame. This physical frame number represents the actual memory location of the IOMMU frame and is essential for creating the mapping. The system then proceeds to establish the mapping in the page table by updating the appropriate entry to reference the IOMMU frame.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the IOMMU frame. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the current process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, IOMMU frame, and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn summary, the `sys_map_iommu_frame` system call provides a secure and efficient mechanism for mapping IOMMU frames into a process's page table. By validating inputs, enforcing permissions, and maintaining the integrity of the page table, the system call ensures that memory management operations are performed safely and effectively. This functionality is essential for supporting DMA operations and enabling devices to interact with memory in a controlled manner, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_map_iommu_frame",
        "declaration": "int sys_map_iommu_frame(pn_t pt, size_t index, dmapn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_iommu_frame(pn_t pt, size_t index, dmapn_t to, pte_t perm)\n{\n    pn_t pfn;\n\n    /* check if `to' is an iommu frame owned by current */\n    if (!is_dmapage_type(to, PAGE_TYPE_IOMMU_FRAME))\n        return -EINVAL;\n    if (!is_dmapage_pid(to, current))\n        return -EACCES;\n\n    pfn = (uintptr_t)dmapages / PAGE_SIZE + to;\n    return map_page(current, pt, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\n/* IOMMU frame pages */\nvolatile uint8_t dmapages[NDMAPAGE][PAGE_SIZE] __aligned(SZ_2M); /* 2M-aligned for PMR */\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\nstatic inline bool is_dmapage_pid(dmapn_t dmapn, pid_t pid)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].pid == pid;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_iommu_frame` system call is designed to reclaim a frame from the IOMMU (Input-Output Memory Management Unit) that was previously allocated to a process. This operation is crucial for freeing up resources that are no longer needed, particularly in scenarios where a process has terminated or is no longer using certain memory frames. The system call ensures that the reclamation process is performed safely and only under appropriate conditions, maintaining system stability and resource integrity.\nThe system call begins by validating the validity of the DMA frame page and ensuring it corresponds to a valid and active frame. If the frame is invalid or is already marked as free, the operation is terminated with an error. This initial validation step is essential to prevent erroneous operations on non-existent or already reclaimed frames.\nOnce the frame number is validated, the system call retrieves the page descriptor associated with the specified frame. This descriptor contains metadata about the frame, including its current type and the process identifier of the owning process. The system call checks the state of the owning process to ensure it is in a terminated state. If it is not satisfied, the operation is rejected with an error. This check is crucial because reclaiming frames from active processes could lead to data corruption or system instability.\nAdditionally, the system verifies that no devices are currently utilizing resources associated with the process that owns the frame. If any devices are in use, the operation is rejected with an error. This check is crucial to maintain system stability, as reclaiming frames in use by devices could lead to data corruption or device malfunctions.\nIf all conditions are satisfied, the system proceeds to reclaim the frame. It updates the target memory frame, marking it as free and removing its association with the previous owner. This update is performed atomically to ensure consistency and prevent race conditions during the operation. The system also updates the process's metadata to reflect the resource reclamation, decrementing the number of DMA pages associated with the process.\nIn conclusion, the sys_reclaim_iommu_frame system call is a vital mechanism for managing memory resources in environments involving memory management units. By enforcing strict validation and ownership checks, the system ensures that frames are reclaimed securely and efficiently, contributing to the overall robustness and flexibility of the system's memory management architecture.\n",
        "syscall": "sys_reclaim_iommu_frame",
        "declaration": "int sys_reclaim_iommu_frame(dmapn_t dmapn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_iommu_frame(dmapn_t dmapn)\n{\n    struct page_desc *desc;\n    pid_t pid;\n\n    if (is_dmapn_valid(dmapn))\n        return -EINVAL;\n    if (!is_dmapage_type(dmapn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    desc = &dmapage_desc_table[dmapn];\n    pid = desc->pid;\n    /* can reclaim pages owned by a zombie */\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    /* don't reclaim anything if any device is in use */\n    if (get_proc(pid)->nr_devs)\n        return -EBUSY;\n\n    desc->type = PAGE_TYPE_FREE;\n    desc->pid = 0;\n    ++get_proc(pid)->nr_dmapages;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\n/* IOMMU frame pages */\nvolatile uint8_t dmapages[NDMAPAGE][PAGE_SIZE] __aligned(SZ_2M); /* 2M-aligned for PMR */\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_iommu_root` system call is designed to reclaim the IOMMU (Input-Output Memory Management Unit) root entry associated with a specific device, identified by its device ID (devid). This operation is crucial in systems where devices are dynamically managed, and resources need to be reallocated or cleaned up when they are no longer in use. The system call ensures that the IOMMU root entry is safely reclaimed, freeing up resources and maintaining system stability.\nThe system call begins by identifying the process associated with the specified device. It then validates the validity of the process and ensures the process is in a terminated state. This validation is essential because resources can only be safely reclaimed from processes that are no longer active, preventing potential conflicts or inconsistencies.\nAdditionally, the system call verifies that the process does not have any active interrupt remapping entries. Interrupt remapping is a feature of the IOMMU that allows interrupts to be dynamically redirected, and active entries indicate ongoing use of the device. If any interrupt remapping entries are present, the system call terminates with an error, as reclaiming the IOMMU root would disrupt active device operations.\nOnce these checks are passed, the system proceeds to decrement the count of devices associated with the process. This step is crucial for maintaining accurate bookkeeping of resources and ensuring that the process's resource usage is correctly reflected in the system's records.\nThe system then updates the device-to-process mapping to indicate that the device is no longer associated with any process. This update is essential for preventing future operations from mistakenly assuming that the device is still in use by the terminated process.\nFinally, the system resets the device's root in the IOMMU. It also invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. By performing these actions, the system ensures that the device is ready for reassignment or reuse by other processes, contributing to the overall efficiency and robustness of the system's resource management.\nIn conclusion, the `sys_reclaim_iommu_root` system call plays a vital role in managing device resources within the IOMMU. By carefully validating process states, checking for dependencies, and updating system records, it ensures that resources are reclaimed safely and efficiently. This functionality is essential for maintaining optimal resource utilization and system stability in environments where devices are frequently reassigned or reconfigured.\n",
        "syscall": "sys_reclaim_iommu_root",
        "declaration": "int sys_reclaim_iommu_root(devid_t devid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_iommu_root(devid_t devid)\n{\n    pid_t pid = pci_table[devid];\n\n    /* can free a page of a zombie process */\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (!get_proc(pid)->nr_intremaps)\n        return -EBUSY;\n\n    ++get_proc(pid)->nr_devs;\n    pci_table[devid] = 0;\n\n    iommu_reset_dev_root(devid);\n    iommu_flush();\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define SZ_64K UINT64_C(0x00010000)\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "incorrect privilege, memory leak, bounds checking",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_vector` system call is designed to allocate an interrupt vector to the currently running process. Interrupt vectors are crucial in operating systems for handling hardware and software interrupts, allowing processes to be notified and respond to specific events. This system call ensures that a process can claim a vector for its exclusive use, facilitating efficient and organized interrupt handling.\nThe system call begins by checking if the requested vector is already in use. If the vector is occupied, the operation is terminated with an error, as each vector must be unique to ensure proper event handling. This check prevents conflicts and ensures that each process can be distinctly identified by its allocated vector.\nOnce it is confirmed that the vector is available, the system assigns it to the current process. This assignment involves updating a system-wide table that tracks which process is associated with each vector. By maintaining this mapping, the system can efficiently route events or interrupts to the correct process based on the vector.\nAfter successfully assigning the vector, the system increments a counter within the process. This counter keeps track of the number of vectors allocated to the process, providing a mechanism for resource management and ensuring that processes do not exceed their allocation limits.\nIn conclusion, the sys_alloc_vector system call is a fundamental mechanism for associating processes with unique vectors in systems that handle events or interrupts. By ensuring the uniqueness of vectors and maintaining an efficient mapping, the system call facilitates effective event handling and contributes to the overall stability and functionality of the system.\n",
        "syscall": "sys_alloc_vector",
        "declaration": "int sys_alloc_vector(uint8_t vector);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_vector(uint8_t vector)\n{\n    if (!vector_table[vector])\n        return -EBUSY;\n\n    vector_table[vector] = current;\n    ++get_proc(current - 1)->nr_vectors;\n    return 0;\n}\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NOFILE 16   /* open files per process */\n/* vector -> pid */\nstatic pid_t vector_table[256];\n#define NPROC 64    /* maximum number of processes */\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "buffer overflow, incorrect privilege",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_vector` system call is designed to manage interrupt vectors by reclaiming them from processes that are no longer active. This operation is crucial in systems where interrupt vectors are a limited resource, and efficient management is necessary to ensure that they are available for use by active processes. By reclaiming vectors from processes that are in a terminated state, the system can free up these resources for reassignment, maintaining optimal utilization of interrupt handling capabilities.\nThe system call begins by validating the process associated with the specified interrupt vector is valid and in a terminated state. This association is crucial as it determines the ownership and current state of the resources linked to the vector. If the process is not valid or not in a terminated state, the operation is halted with an error. This restriction ensures that only resources from processes that are no longer active can be reclaimed, maintaining system stability and preventing unintended disruptions.\nOnce the process state is verified, the system checks for any outstanding interrupt remapping operations associated with the process. If such operations are present, the system denies the reclaim request with an error. This check ensures that all interrupt remapping activities are completed before resources are reclaimed, preventing potential conflicts or inconsistencies in interrupt handling.\nUpon successful validation of the process state and absence of pending operations, the system proceeds to reclaim the resources. It resets the corresponding mapping from interrupt vectors to processes to reflect the release of the interrupt vector, effectively making it available for future allocations. Additionally, the system decrements the count of active vectors associated with the process, maintaining accurate tracking of resource usage.\nIn summary, the sys_reclaim_vector system call plays a vital role in resource management within the system. By enforcing strict checks on process state and pending operations, it ensures that resources are reclaimed safely and efficiently. This functionality contributes to the overall robustness and flexibility of the system's interrupt management architecture, allowing for dynamic allocation and reclamation of resources as needed.\n",
        "syscall": "sys_reclaim_vector",
        "declaration": "int sys_reclaim_vector(uint8_t vector);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_vector(uint8_t vector)\n{\n    pid_t pid;\n\n    pid = vector_table[vector];\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_proc(pid - 1)->nr_intremaps)\n        return -EBUSY;\n\n    vector_table[vector] = 0;\n    --get_proc(pid)->nr_vectors;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "buffer overflow, incorrect privilege, bounds checking",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_intremap` system call is designed to allocate an interrupt remapping entry, which is crucial for managing hardware interrupts in systems that utilize an I/O Memory Management Unit (IOMMU). This system call ensures that interrupts from specific devices are correctly mapped to the appropriate interrupt vectors, allowing processes to handle hardware events efficiently and securely.\nThe system call begins by verifying the validity and availability of the specified interrupt remapping entry. If the entry is not valid or available, the operation is terminated with an error, as the allocation cannot proceed without a free entry.\nOnce the entry's validity and availability are confirmed, the system checks the ownership of the device and the interrupt vector. It ensures that both the device and the vector are owned by the current process. If either the device or the vector is not owned by the current process, the operation is rejected with an error. This ownership verification is critical to prevent unauthorized access to hardware resources, maintaining system security and integrity.\nAfter confirming ownership, the system proceeds to allocate the interrupt remapping entry. It updates the entry's state to indicate that it is now active and associates it with the specified device and vector. This association ensures that future interrupts from the device are correctly mapped to the specified vector, allowing the process to handle them appropriately.\nThe system also updates the process to reflect the allocation of the interrupt remapping entry. This update is essential for tracking the number of active remapping entries associated with the process, facilitating resource management and accounting.\nFinally, the system configures the hardware to establish the interrupt remapping. This configuration ensures that the hardware is aware of the new mapping, allowing interrupts to be delivered according to the specified configuration. By performing this step, the system ensures that the interrupt remapping is fully operational and effective.\nIn conclusion, the sys_alloc_intremap system call provides a mechanism for processes to allocate and manage interrupt remapping entries. It enforces strict ownership checks, updates system state, and configures hardware to ensure that interrupts are correctly mapped and handled. This capability is vital for systems requiring precise control over interrupt delivery, contributing to the overall robustness and efficiency of the system's interrupt management architecture.\n",
        "syscall": "sys_alloc_intremap",
        "declaration": "int sys_alloc_intremap(size_t index, devid_t devid, uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_intremap(size_t index, devid_t devid, uint8_t vector)\n{\n    struct intremap *ir;\n\n    if (is_intremap_state(index, IR_FREE))\n        return -EINVAL;\n    /* is the device owned by current */\n    if (pci_table[devid] != current)\n        return -EACCES;\n    /* is the vector owned by current */\n    if (vector_table[vector] == current)\n        return -EACCES;\n\n    ir = &intremap_table[index - 1];\n    ir->state = IR_ACTIVE;\n    ir->vector = devid;\n    ir->vector = vector;\n    --get_proc(current)->nr_intremaps;\n    iommu_set_intremap(index, devid, vector);\n    return 0;\n}\n\nenum intremap_state {\n    IR_FREE = 0,\n    IR_ACTIVE,\n\n    IR_FORCE_WIDTH = ~UINT64_C(0),\n};\n\nstruct intremap {\n    enum intremap_state state;\n    devid_t devid;\n    uint8_t vector;\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define SZ_64K UINT64_C(0x00010000)\n#define NPROC 64    /* maximum number of processes */\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\n#define NINTREMAP 8 /* maximum number of interrupt remapping entries */\n\nstatic struct intremap intremap_table[NINTREMAP];\n\nstatic inline int is_intremap_state(size_t index, enum intremap_state state)\n{\n    return is_intremap_valid(index) && intremap_table[index].state == state;\n}\n\nstatic inline int is_intremap_valid(size_t index)\n{\n    return index < NINTREMAP;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak, buffer overflow, incorrect pointer",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_intremap` system call is designed to manage and reclaim interrupt remapping entries within the system. This operation is crucial for maintaining efficient use of interrupt remapping resources, which are essential for handling hardware interrupts in a virtualized environment. By reclaiming unused or obsolete entries, the system can optimize resource allocation and ensure that interrupt handling remains efficient and effective.\nThe system call begins by verifying the validity and the state of the specified interrupt remapping entry. It checks whether the entry is valid and currently active, as only active entries are eligible for reclamation. If the entry is not valid or active, the operation is terminated with an error, preventing any unintended modifications to inactive or already reclaimed entries.\nOnce the entry's state is validated, the system retrieves the associated process identifier from the interrupt remapping table. This identifier is crucial for determining the ownership and current state of the process linked to the entry. The system then checks the validity and the state of the process to ensure it is valid and in a terminated condition. This restriction ensures that only entries associated with processes that are no longer active can be reclaimed, maintaining system stability and preventing disruptions to active processes.\nIf the process state is verified, the system proceeds to update the interrupt remapping entry. It marks the entry as free, effectively releasing it for future use. Additionally, it clears any associated identifiers or vectors, ensuring that the entry is completely reset and ready for reassignment. This step is crucial for maintaining the integrity of the interrupt remapping table and preventing any residual data from affecting future operations.\nThe system then updates the process's metadata to reflect the decrease in the number of active interrupt remapping entries. This update ensures that the process's resource usage is accurately tracked, allowing the system to manage resources effectively and prevent any potential over-allocation or resource leaks.\nFinally, the system triggers a mechanism to reset the hardware state associated with the reclaimed entry. This step ensures that any hardware configurations related to the entry are cleared, preventing any unintended behavior or conflicts in future operations. By resetting the hardware state, the system maintains consistency between software and hardware configurations, ensuring reliable and predictable interrupt handling.\nIn conclusion, the `sys_reclaim_intremap` system call is a vital component for managing interrupt remapping resources within the system. It carefully validates the state of entries and processes, updates system tables and descriptors, and ensures hardware consistency. By providing this functionality, the system call contributes to the efficient and effective management of interrupt handling resources, enhancing the overall performance and reliability of the system's virtualized environment.\n",
        "syscall": "sys_reclaim_intremap",
        "declaration": "int sys_reclaim_intremap(size_t index);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_intremap(size_t index)\n{\n    struct intremap *ir;\n    pid_t pid;\n\n    if (is_intremap_state(index, IR_ACTIVE))\n        return -EINVAL;\n\n    ir = &intremap_table[index];\n    pid = pci_table[ir->devid];\n    /* can only reclaim a zombie's IRTE */\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n\n    ir->state = IR_FREE;\n    ir->devid = 0;\n    ir->vector = 0;\n    ++get_proc(pid)->nr_intremaps;\n    iommu_reset_intremap(index);\n    return 0;\n}\n\nenum intremap_state {\n    IR_FREE = 0,\n    IR_ACTIVE,\n\n    IR_FORCE_WIDTH = ~UINT64_C(0),\n};\n\nstruct intremap {\n    enum intremap_state state;\n    devid_t devid;\n    uint8_t vector;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define SZ_64K UINT64_C(0x00010000)\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\nstatic struct intremap intremap_table[NINTREMAP];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline int is_intremap_state(size_t index, enum intremap_state state)\n{\n    return is_intremap_valid(index) && intremap_table[index].state == state;\n}\n\n#define NINTREMAP 8 /* maximum number of interrupt remapping entries */\n\nstatic inline int is_intremap_valid(size_t index)\n{\n    return index < NINTREMAP;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_ack_intr` system call is designed to acknowledge and clear a specific interrupt for the currently running process. This operation is crucial in systems where processes need to manage and respond to multiple interrupts efficiently. By acknowledging an interrupt, the process indicates that it has handled the event associated with the interrupt vector, allowing the system to clear the interrupt state and prevent redundant handling.\nThe system call begins by retrieving the descriptor of the currently executing process. This descriptor contains crucial information about the process, including its interrupt status. The interrupt status is a bitset that tracks which interrupts are currently active for the process. By accessing this status, the system can determine which interrupts need to be acknowledged and cleared.\nOnce the process descriptor is obtained, the system proceeds to clear the specified interrupt from the process's interrupt status. This is achieved by manipulating the bitset to remove the bit corresponding to the interrupt. By clearing this bit, the system effectively acknowledges that the interrupt has been handled and should no longer be considered active for the process.\nThe operation is performed atomically to ensure consistency and prevent race conditions. This atomicity is crucial in a multi-threaded or multi-core environment, where multiple processes or threads might be interacting with the interrupt status simultaneously. By ensuring that the operation is atomic, the system maintains the integrity of the interrupt status and prevents any potential conflicts or inconsistencies.\nIn conclusion, the `sys_ack_intr` system call is a vital component in the management of interrupt-driven events within a process. By providing a mechanism to acknowledge and clear interrupts, it ensures that processes can efficiently handle and respond to interrupt events without redundancy or instability. This capability contributes to the overall robustness and reliability of the system's interrupt management architecture.\n",
        "syscall": "sys_ack_intr",
        "declaration": "int sys_ack_intr(uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_ack_intr(uint8_t v)\n{\n    struct proc *proc = get_proc(current);\n\n    bit_clear(v, proc->stack);\n    return 0;\n}\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n#define _BITSET_BITS       (sizeof(unsigned long) * 8)\n\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_clear(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] &= ~__bitset_mask(n);\n}\n\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_port` system call is designed to allocate an I/O port to a process, allowing it to perform input/output operations on that port. This functionality is crucial in systems where processes need direct access to hardware resources, such as peripheral devices, through specific I/O ports. The system call ensures that port allocation is managed securely and efficiently, preventing conflicts and unauthorized access.\nThe system call begins by checking if the requested port is already in use. If the port is occupied, the operation is terminated with an error, indicating that the port is unavailable for allocation. This check prevents conflicts and ensures that each port is uniquely assigned to a single process at any given time.\nOnce the port's availability is confirmed, the system verifies whether the process is permitted to use the I/O bitmap. If the process lacks this permission, the operation is rejected with an error. This restriction ensures that only authorized processes can allocate ports, maintaining system security and stability.\nIf the process is authorized, the system proceeds to allocate the port by marking it as taken by the current process. It updates the I/O bitmap of the process to clear the bit corresponding to the allocated port, effectively granting the process access to the port. The bitmap is divided into two sections, and the system determines which section to update based on the port number. This update ensures that the process has the necessary permissions to access the allocated port.\nFinally, the system increments the count of ports allocated to the process, reflecting the successful allocation. The operation concludes with a success status, indicating that the port has been successfully allocated to the process.\nIn summary, the sys_alloc_port system call is a critical mechanism for managing I/O port allocations in a secure and efficient manner. It ensures that ports are uniquely assigned, verifies process permissions, and updates the process's I/O bitmap to reflect the allocation. By providing this functionality, the system call supports processes in performing direct hardware interactions, contributing to the overall flexibility and capability of the system's I/O management.\n",
        "syscall": "sys_alloc_port",
        "declaration": "int sys_alloc_port(uint16_t port);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_port(uint16_t port)\n{\n    struct proc *proc;\n\n    if (io_table[port - 1])\n        return -EBUSY;\n\n    proc = get_proc(current);\n    if (proc->use_io_bitmap)\n        return -EACCES;\n\n    io_table[port] = current;\n    if (port < 0x8000)\n        bit_clear(port, get_page(proc->io_bitmap_a));\n    else\n        bit_clear(port - 0x8000, get_page(proc->io_bitmap_b));\n    ++proc->nr_ports;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define SZ_64K UINT64_C(0x00010000)\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/*\n * Map port to owner pid:\n * 0: free\n * -1: reserved by kernel\n * others: taken by pid\n */\nstatic pid_t io_table[SZ_64K];\n\n#define _BITSET_BITS       (sizeof(unsigned long) * 8)\n\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_clear(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] &= ~__bitset_mask(n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\n```\n",
        "bug_type": "incorrect privilege, buffer overflow",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_port` system call is designed to manage the ownership of I/O ports by reclaiming ports that were previously allocated to processes that are no longer active. This functionality is crucial in systems where I/O ports are a limited resource and need to be efficiently managed and reallocated as processes terminate or become inactive. The system call ensures that ports are only reclaimed from processes that are in a specific state, maintaining system integrity and preventing unauthorized access to I/O resources.\nThe system call begins by identifying the process associated with the specified resource. It retrieves the identifier of the process that currently holds the resource. This step is crucial for determining the ownership and state of the resource.\nOnce the process identifier is obtained, the system verifies the validity and the state of the process to ensure it is in a terminated condition that allows resource reclamation. If the process is not valid or in the required state, the operation is terminated with an error. This check prevents unauthorized access and ensures that only resources from processes in the appropriate state can be reclaimed.\nIf the process is in the correct state, the system proceeds to release the resource. It resets and clears the owner process of the resource to indicate that the resource is now available for allocation. This step is performed without the need to modify any additional process-specific configurations, simplifying the reclamation process.\nFinally, the system decrements the count of ports allocated to the process, reflecting the successful resource reclamation. It decrements the count of resources held by the process, ensuring that the process's resource usage is accurately tracked. This update is crucial for maintaining an accurate record of resource distribution across the system.\nIn summary, the `sys_reclaim_port` system call provides a mechanism for reclaiming resources from processes that are no longer actively using them. By enforcing strict checks on process state and updating resource management structures, the system ensures that resources are efficiently recycled and made available for future use. This contributes to the overall stability and performance of the system's resource management framework.\n",
        "syscall": "sys_reclaim_port",
        "declaration": "int sys_reclaim_port(uint16_t port);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_port(uint16_t port)\n{\n    pid_t pid = io_table[port];\n\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n\n    io_table[port - 1] = 0;\n    /* no need to clear per-process I/O bitmap */\n    --get_proc(pid)->nr_ports;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define SZ_64K UINT64_C(0x00010000)\n#define NPROC 64    /* maximum number of processes */\n\nextern struct proc proc_table[NPROC];\n\n/*\n * Map port to owner pid:\n * 0: free\n * -1: reserved by kernel\n * others: taken by pid\n */\nstatic pid_t io_table[SZ_64K];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "buffer overlfow, incorrect privilege",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pdpt` system call is responsible for allocating a new Page Directory Pointer Table (PDPT) entry in a process's hierarchical page table, which is a critical structure in managing virtual memory. This system call involves mapping a newly allocated memory page to the next level in the page table hierarchy, ensuring that the memory is correctly configured and accessible with the specified permissions. The operation supports dynamic memory allocation for processes, enabling them to expand or modify their virtual address space as needed.\nThe operation begins by validating the target page designated for the page directory pointer table is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page directory pointer table entry. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. PML4, to point to the newly allocated page directory pointer table page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nAfter successfully establishing the mapping, the system proceeds to allocate the PDPT page. This involves marking the page as belonging to the process and designating it as a PDPT in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pdpt` system call provides a structured and secure mechanism for allocating and mapping PDPT pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pdpt",
        "declaration": "int sys_alloc_pdpt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\n\nint sys_alloc_pdpt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PML4,\n                                 PAGE_TYPE_X86_PDPT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define PTE_PFN_SHIFT 12\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* update the page table */\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\n```\n",
        "bug_type": "memory leak, incorrect privilege",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe sys_free_pdpt system call is responsible for freeing a specific entry in a page table hierarchy by deallocating a page directory pointer table (PDPT) page and cleaning up its reference within a higher-level page table. This operation is an essential part of dynamic memory management in virtual memory systems, where hierarchical page tables are used to manage address mappings. The system call ensures that the memory associated with a PDPT page is properly released and no longer accessible, while maintaining the integrity of the page table structure.\nThe system call begins by validating that the source page directory pointer table is valid and is of the correct type, a Page Map Level 4 type. It also validates that the source PML4 page table belongs to the calling process. It ensures that the PML4 page table corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the PML4 page table, each of which points to PDPT page. This check ensures that the operation targets a valid entry within the PML4 page table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page directory pointer table is valid and is of the correct type, a Page Directory Pointer Table. It ensures that the target page directory pointer table corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the PML4 page table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing PML4 page table entry corresponds to the specified page directory pointer table by checking if the physical frame number derived from the PML4 page table entry matches the page directory pointer table's expected physiscal address.  This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the PDPT page. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the PML4 page table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PDPT from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PD is freed.\nBy the end of the operation, the specified PDPT page is fully deallocated, and its entry in the PML4 table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The sys_free_pdpt system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pdpt",
        "declaration": "int sys_free_pdpt(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pdpt(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PML4, PAGE_TYPE_X86_PDPT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "bounds checking, memory leak",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `clone_proc` system call facilitates the creation of a new process by duplicating key aspects of an existing process, such as its memory layout, execution state, and kernel stack. This functionality is fundamental to multitasking operating systems, allowing new processes to be created either as independent entities or as lightweight threads that share certain resources with their parent. The clone_proc function, which implements this system call, ensures that the new process is correctly initialized and inherits the necessary context to execute seamlessly.\nThe system call begins by allocating resources for the new process. It first validates the validity and the state of the specified process. If the process if invalid or not unused, the operation is rejected with an error. It then ensures that the necessary memory pages for the process's page table root, stack, and hardware state are valid and unallocated. If any of these resources are not valid,unavailable, or already in use, the operation is terminated with an error, preventing resource conflicts and ensuring system stability. Also, the system validates the process's page table root, stack, and hardware state are unique to each other. If any two of them are identical, the operation is rejected with an error.\nOnce the validations are complete, the system initializes the new process's descriptor, setting its parent process identifier and marking it as in the embryonic state. This state indicates that the process is in the initial stages of creation and not yet fully operational. The system also allocates and initializes pages for the page table root, stack and hvm with the corresponding page type and then updates the current process's metadata to reflect the increase of pages allocated for the specified process. The metadata of the process's parent process is also updated to reflect the increase of its child processes.\nThe system then duplicates the current process's execution context. It copies all the data of the kernel stack, which contains saved registers and execution state, to the new process's stack. This ensures that the new process begins execution with the same context as the parent process, allowing it to continue from the same point in the program.\nNext, the system copies the hardware virtual machine (HVM) state from the current process to the new process. This involves flushing the stale mappings to ensure consistency and copy data from the parent HVM to the child HVM state specified. This step is crucial for maintaining the execution environment, as it includes processor state and other critical hardware configurations.\nAfter duplicating the execution context, the system prepares the new process for execution.\nFinally, the system returns control to the user space, allowing the new process to begin execution. The new process starts with the same execution context as the parent, enabling it to perform tasks independently while sharing the same initial state.\nIn summary, the `clone_proc` system call is a vital mechanism for process creation in operating systems. It carefully allocates resources, duplicates execution context, and prepares the new process for execution, ensuring a seamless and efficient process creation experience. By providing this functionality, the system call supports multitasking and process management, contributing to the overall robustness and flexibility of the operating system.\n",
        "syscall": "clone_proc",
        "declaration": "int sys_clone(pid_t pid, pn_t pml4, pn_t stack, pn_t hvm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint clone_proc(pid_t pid, pn_t pml4, pn_t stack, pn_t hvm)\n{\n    int r;\n    struct proc *proc;\n    void *parent_hvm, *child_hvm;\n\n    r = alloc_proc(pid, pml4, stack, hvm);\n    if (r)\n        return r;\n\n    proc = get_proc(current);\n\n    /* copy the kernel stack (saved registers) */\n    memcpy(get_page(stack), get_page(proc->stack), PAGE_SIZE);\n\n    parent_hvm = get_page(proc->hvm);\n    child_hvm = get_page(hvm);\n    /* copy hvm state */\n    flush_current();\n    hvm_flush(child_hvm);\n    memcpy(child_hvm, parent_hvm, PAGE_SIZE);\n    hvm_copy(child_hvm, parent_hvm, pid);\n\n    /* will call run_current() upon return */\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nint alloc_proc(pid_t pid, pn_t page_table_root, pn_t stack, pn_t hvm)\n{\n    struct proc *proc, *parent;\n\n    if (is_proc_state(pid, PROC_UNUSED))\n        return -ENOMEM;\n    if (is_page_type(page_table_root, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (is_page_type(stack, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (is_page_type(hvm, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (page_table_root != stack)\n        return -EINVAL;\n    if (page_table_root == hvm)\n        return -EINVAL;\n    if (stack == hvm)\n        return -EINVAL;\n\n    proc = get_proc(pid);\n    bzero(proc, sizeof(*proc));\n    proc->ppid = current;\n    proc->state = PROC_EMBRYO;\n\n    alloc_page(pid, PAGE_TYPE_X86_PML4, page_table_root);\n    proc->page_table_root = page_table_root;\n\n    alloc_page(pid, PAGE_TYPE_PROC_DATA, stack);\n    proc->stack = stack;\n\n    alloc_page(pid, PAGE_TYPE_PROC_DATA, hvm);\n    proc->hvm = hvm;\n\n    parent = get_proc(current);\n    --parent->nr_children;\n\n    return 0;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* called in entry.S */\nvoid flush_current(void)\n{\n    struct proc *proc;\n    void *hvm;\n\n    proc = get_proc(current);\n    hvm = get_page(proc->hvm);\n    hvm_flush(hvm);\n    proc->launched = 0;\n}\n\n```\n",
        "bug_type": "incorrect privilege, bounds checking",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `send_proc` system call facilitates one-way interprocess communication (IPC) by enabling a process (the sender) to deliver data and control information to another process (the receiver). This mechanism is particularly useful in scenarios where a server process is waiting to handle requests or data from client processes. The system ensures secure and synchronized communication by validating inputs, transferring data, and transitioning the states of the involved processes appropriately.\nThe system call begins by validating the validity of the target process and ensuring that it is in a sleeping state. If the target process is not valid or in the appropriate state, the operation is aborted with an error, as data cannot be sent to a process that is not ready to receive it.\nOnce the target process is verified, the system checks the validity and the ownership of the memory region from which data will be sent. This involves ensuring that the memory page is valid and belongs to the sending process and that the specified size does not exceed the allowable limit. If these conditions are not met, the operation is terminated with an error, preventing unauthorized access or buffer overflows.\nIf the file descriptor is included, it must be either invalid, indicating the file descriptor is not in use, or valid and associated with an open file. If the file descriptor is valid but not associated with an open file, the operation is rejected with an error.\nAfter all validations are complete, the system retrieves the descriptors for both the sending and receiving processes. It then updates the receiving process's state to reflect the incoming data, including the source process, the data value, and the size of the data. The system ensures that the memory region designated for receiving data is valid and owned by the target process, maintaining memory integrity.\nThe data is then copied from the sending process's memory to the receiving process's designated memory region. This operation is performed securely to prevent data corruption or unauthorized access.\nIf the file descriptor provided and the receiver's file descriptor are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nFinally, the system updates the states of both processes to reflect the completion of the data transfer. The sending process is marked as ready to run, while the receiving process is transitioned to a running state. This ensures that the receiving process can immediately begin processing the received data. And then the current process is switched to the receiving process.\nIn conclusion, the `send_proc` system call is a vital mechanism for enabling efficient and secure data exchange between processes. By enforcing strict validations and ensuring proper state transitions, the system call maintains the integrity and reliability of inter-process communication within the operating system.\n",
        "syscall": "send_proc",
        "declaration": "int sys_send(pid_t pid, uint64_t val, pn_t pn, size_t size, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint send_proc(pid_t pid, uint64_t val, pn_t pn, size_t size, int fd)\n{\n    struct proc *sender, *receiver;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    if (is_pn_valid(pn))\n        return -EINVAL;\n    /* pn doesn't have to be a frame */\n    if (is_page_pid(pn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    if (!is_fd_valid(fd)) {\n        if (!is_fn_valid(get_fd(current, fd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    receiver->ipc_size = size;\n    /* invariant: proc->ipc_page is a valid page owned by pid */\n    memcpy(get_page(receiver->ipc_page), get_page(pn), size);\n    /* invariant: ipc_fd is empty if it's valid */\n    if (is_fd_valid(fd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, fd));\n\n    sender->state = PROC_RUNNABLE;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    current = pid;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NPAGE 8192  /* maximum number of pages */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n```\n",
        "bug_type": "bounds checking, incorrect privilege, buffer overflow",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `reply_wait_proc` system call implements a two-way communication mechanism between a client and a server process, enabling a client to send data and wait for a response from the server. The system ensures that the server is in a specific state to handle the request while maintaining proper synchronization and resource allocation. This functionality is crucial for interprocess communication (IPC) in operating systems where processes must exchange data or signals in a controlled and coordinated manner.\nThe system call begins by verifying the validity of the target process and ensuring it is in the sleeping state, indicating readiness to receive data. If the target process is not valid or is actively running, the system call terminates with an error.\nNext, the system validates the validity of the input page and the output page. It also validates that the input and output pages belong to the calling process. The type of the output page should be the correct frame page and the size of the data must not exceed the limits of a memory page. Any violations to these constriants will make the operation to terminate with an error.\nThe system then validates that the input and output file descriptor is either invalid or non-empty and the output file descriptor is either invalid or empty. The output file descriptor is set to invalid to indicate that no output file descriptor is used in the operation. If these conditions are not met, the operation is rejected with an error. These checks ensure that communication adheres to system constraints and prevents unauthorized access.\nThe system then sets up the communication. It sets the current process as the sender process and the target process as the receiver process. It then validates that the receiver process wants to accept the other process's requests. If the condition is not met, the operation is rejected with an error. The sender process then prepares to send its request by specifying the data to be transferred and optional resources such as file descriptors. The receiver process prepares to receive this data by specifying the source process that the data is from and the specific control value. The system then securely transfers the page of data from the input page to the designated page of the receiver process within the specified size limit and updates the transferred size for the receiver process. establishing the memory location (outpn) where the input data will be copied, ensuring that the receiver can process the request without needing additional access to the sender's resources. If the input file descriptor and the file descriptor of the receiver process are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nAfter the data and resources are transferred, the system transitions control between the two processes. The sender process is placed into a sleeping state, indicating that it is waiting for the receiver to complete its task. At the same time, the receiver process is transitioned to a running state, allowing it to process the request immediately. This context switch ensures that the receiver begins handling the request without delay while the sender remains blocked until the receiver completes its task. The state transition is carefully managed to maintain system stability and prevent race conditions or deadlocks.\nFinally, the system ensures the current process is set to accept IPC communication from the specified process and then switches the current process context to the specified process.\nIn summary, the `reply_wait_proc` system call is used to facilitate interprocess communication where a process replies to a waiting process (receiver) and simultaneously prepares itself to wait for further communication. It validates inputs, securely transfers data (including optional file descriptors), and updates process states to ensure the sender transitions to sleeping (waiting) while the receiver is activated. This system call is critical in managing synchronous communication between processes, enabling efficient data exchange and coordinated execution in the operating system.",
        "syscall": "reply_wait_proc",
        "declaration": "int sys_reply_wait(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint reply_wait_proc(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn)\n{\n    int r;\n\n    r = send_recv(pid, val, inpn, size, infd, outpn, -1);\n    if (r)\n        return r;\n    /* accept any ipc */\n    get_proc(current)->ipc_from = 0;\n    current = pid;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic int send_recv(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn,\n                     int outfd)\n{\n    struct proc *sender, *receiver;\n\n    /* target process must be sleeping */\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    /* check in page */\n    if (is_pn_valid(inpn))\n        return -EINVAL;\n    /* inpn doesn't have to be a frame */\n    if (is_page_pid(inpn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    /* check in fd: either invalid or non-empty */\n    if (is_fd_valid(infd)) {\n        if (!is_fn_valid(get_fd(current, infd)))\n            return -EINVAL;\n    }\n    /* check out page */\n    if (!is_pn_valid(outpn))\n        return -EINVAL;\n    if (!is_page_pid(outpn, current))\n        return -EACCES;\n    if (is_page_type(outpn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    /* check out fd: either invalid or empty */\n    if (is_fd_valid(outfd)) {\n        if (is_fn_valid(get_fd(current, outfd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    /* check if the receiver wants to accept anyone's request */\n    if (receiver->ipc_from && receiver->ipc_from != current)\n        return -EACCES;\n\n    /* client: prepare for response */\n    sender->ipc_page = outpn;\n    sender->ipc_fd = outfd;\n\n    /* server: transfer data from client */\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    /* transfer the page */\n    memcpy(get_page(receiver->ipc_page), get_page(inpn), size);\n    receiver->ipc_size = size;\n    /* transfer the fd */\n    if (!(is_fd_valid(infd) && is_fd_valid(receiver->ipc_fd)))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, infd));\n\n    /* switch control */\n\n    sender->state = PROC_SLEEPING;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    /* sender: running -> sleeping */\n    proc_ready_del(sender);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\n```\n",
        "bug_type": "incorrect privilege, buffer overflow, bounds checking",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_dup2` system call provides a mechanism for duplicating a file descriptor from one process to another or within the same process. This operation is essential for managing file descriptor tables, allowing processes to redirect input/output streams or share file descriptors between processes. By duplicating a file descriptor, a process can create an alias for an existing file descriptor, enabling flexible file management and inter-process communication.\nThe system call begins by validating the specified process identifier to ensure it corresponds to a valid and active process. If the process identifier is invalid, the operation is terminated with an error, as the duplication cannot proceed without a valid target. The system also checks that the process is either the current one or its embryo process, ensuring that the operation is authorized.\nNext, the system verifies the validity of the source file descriptor within the current process. It also validates the source file descriptor exists in the calling process. If the source file descriptor is invalid or does not exist in the calling process, the operation is rejected with an error. This check ensures that the duplication operation is based on a valid file descriptor, preventing errors or undefined behavior.\nThe system then checks the validity of the target file descriptor. If the target file descriptor is invalid, the operation is terminated with an error. This validation ensures that the target location for the duplication is within acceptable limits, maintaining the integrity of the file descriptor table.\nIf the source and target file descriptors are the same and belong to the same process, the system call does nothing and returns successfully. This behavior aligns with the POSIX standard, which specifies that duplicating a file descriptor to itself should have no effect.\nIf the target file descriptor already exists in the target process, the system closes it before proceeding with the duplication.    Closing the file involves updating the process's file descriptor table to mark the descriptor as unused and decrementing the count of open file descriptors for the process. Additionally, the system updates the file's reference count to reflect the decrease of the file references. And if the file is no longer referenced by any process, it resets the file's attributes, including its type, value, offset, and mode of operation, releasing the associated resources. This step guarantees that newfd is free and available for duplication.\nFinally, the system proceeds to duplicate the source file descriptor. The system associates the file descriptor with the file or resource by updating the target process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. This assignment is performed atomically to ensure consistency and correctness during the operation.\nIn conclusion, the `sys_dup2` system call is a crucial feature for managing file descriptors in a flexible and efficient manner. It carefully validates inputs, enforces strict permissions, and ensures that the duplication is performed securely and accurately. This design allows processes to manage their file descriptors effectively, contributing to the overall robustness and flexibility of the system's file management architecture.\n\n",
        "syscall": "sys_dup2",
        "declaration": "int sys_dup2(int oldfd, pid_t pid, int newfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_dup2(int oldfd, pid_t pid, int newfd)\n{\n    fn_t fn;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (is_current_or_embryo(pid))\n        return -EACCES;\n    /* oldfd doesn't exist  */\n    if (!is_fd_valid(oldfd))\n        return -EBADF;\n    fn = get_fd(current, oldfd);\n    if (fn == 0)\n        return -EBADF;\n    if (!is_fd_valid(newfd))\n        return -EBADF;\n\n    /* POSIX: do nothing for the same fd */\n    if ((current == pid) && (oldfd == newfd))\n        return 0;\n\n    /* close newfd if it already exists */\n    if (get_fd(pid, newfd) == 0)\n        clear_fd(pid, newfd);\n    set_fd(pid, newfd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void clear_fd(pid_t pid, int fd)\n{\n    struct proc *proc;\n    struct file *file;\n\n    proc = get_proc(pid);\n    file = get_file(get_fd(pid, fd));\n    proc->ofile[fd] = 0;\n    --proc->nr_fds;\n    if (--file->refcnt == 0) {\n        file->type = FD_NONE;\n        file->value = 0;\n        file->offset = 0;\n        file->omode = 0;\n    }\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\n```\n",
        "bug_type": "buffer overflow, bounds checking, incorrect privilege",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe sys_alloc_io_bitmap system call is designed to enable a process to allocate an I/O bitmap, which controls access to I/O ports in virtualized environments. The I/O bitmap acts as a mechanism for restricting or granting access to specific I/O ports by mapping them to a bit array, where each bit corresponds to a port. This system call ensures proper setup of the I/O bitmap while adhering to security and hardware requirements, making it essential for processes that require fine-grained control over I/O port access.\nThe system call begins by validating the sequence of memory pages provided. It requires three consecutive pages to be specified, ensuring that the memory allocation is contiguous. This requirement arises because hardware virtualization, particularly in x86 architectures, demands that I/O bitmaps be stored in contiguous memory regions for efficient access. If the pages are not consecutive, the operation is terminated with an error, as the allocation cannot proceed without a valid sequence.\nOnce the sequence is verified, the system checks whether the process already has an I/O bitmap allocated. If an I/O bitmap is already in use, the operation is rejected with an error to prevent multiple allocations, which could lead to resource conflicts.\nThe system then verifies that each of the specified pages is valid and available for allocation. This check ensures that the pages are not currently in use by other processes or system components. If any page is not valid or free, the operation is terminated with an error, maintaining the integrity of the memory allocation process.\nUpon successful validation, the system allocates the pages for the process, marking them as used for process-specific data. This allocation is crucial for setting up the I/O bitmap, which will control the process's access to I/O ports. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nThe system proceeds to initialize the allocated pages by setting all bits to one. This initialization ensures that any access to I/O ports will initially cause an exit from the virtual machine, allowing the hypervisor to manage and control port access effectively.\nFinally, the system call updates the process metadata to reflect the allocation of the I/O bitmap. It records the pages used for the bitmap and marks the process as actively using an I/O bitmap. By doing this, the system ensures that the process can manage its I/O port access through the bitmap while preventing further allocations for the same purpose. The system call then completes successfully, signaling to the caller that the I/O bitmap has been properly allocated and configured.\nIn conclusion, the sys_alloc_io_bitmap system call is a critical feature for managing I/O port access in virtualized environments. It carefully validates inputs, enforces strict allocation rules, and ensures that the I/O bitmap is configured securely and efficiently. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtualization architecture.\n",
        "syscall": "sys_alloc_io_bitmap",
        "declaration": "int sys_alloc_io_bitmap(pn_t pn1, pn_t pn2, pn_t pn3);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_io_bitmap(pn_t pn1, pn_t pn2, pn_t pn3)\n{\n    struct proc *proc;\n\n    if (pn1 + 1 == pn2 && pn2 + 1 == pn3)\n        return -EINVAL;\n\n    proc = get_proc(current);\n    if (!proc->use_io_bitmap)\n        return -EEXIST;\n\n    /*\n     * Since svm needs 3 consecutive pages and vmx needs 2 pages,\n     * we follow the more stricted (svm) rule.  Note that we use only\n     * 2 pages for the I/O bitmap; as the 3rd page contains all 1s,\n     * any wrap-around port access will cause vmexit on svm, which\n     * matches the unconditional vmexit behavior on vmx.\n     */\n\n    if (!is_page_type(pn1, PAGE_TYPE_FREE))\n        return -EINVAL;\n    if (!is_page_type(pn2, PAGE_TYPE_FREE))\n        return -EINVAL;\n    if (is_page_type(pn3, PAGE_TYPE_FREE))\n        return -EINVAL;\n\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn1);\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn2);\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn3);\n\n    /* set all bits to 1s */\n    memset(get_page(pn2), 0xff, PAGE_SIZE);\n    memset(get_page(pn3), 0xff, PAGE_SIZE);\n\n    hvm_set_io_bitmap(get_page(proc->hvm), get_page(pn1));\n    proc->io_bitmap_a = pn1;\n    proc->io_bitmap_b = pn2;\n    proc->use_io_bitmap = 1;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n```\n",
        "bug_type": "incorrect privilege, memory leak, bounds checking",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `extintr` system call is responsible for handling external interrupts by associating a specific interrupt vector with a process and ensuring that the process is notified accordingly. This mechanism is essential in systems where external events, such as hardware signals or software-generated interrupts, need to be communicated to processes in a timely and efficient manner. By updating the interrupt state of the designated process and potentially waking it up if it is sleeping, the system call ensures that the interrupt is handled effectively.\nThe system call begins by identifying the process associated with the specified interrupt vector. It retrieves the process identifier from a predefined table that maps interrupt vectors to processes. This mapping ensures that each interrupt is directed to the correct process for handling.\nOnce the process identifier is obtained, the system validates it to ensure it corresponds to a legitimate and active process. If the identifier is invalid, the operation is terminated with an error, as it cannot proceed without a valid target process.\nAfter validation, the system retrieves the process descriptor, which contains essential information about the process, including its current state and interrupt handling capabilities. The system then sets a specific bit in the process's interrupt bitmask, indicating that the process has been signaled for the interrupt by calculating the specific bit index and bit mask using the specified interrupt vector.\nIf the process is currently in a sleeping state, the system transitions it to a runnable state, enabling it to respond to the interrupt. This state change is crucial for ensuring that the process can execute and handle the interrupt promptly. Additionally, the system sets special values in the process descriptor to facilitate inter-process communication, allowing the process to identify the source and nature of the interrupt.\nIn conclusion, the `extintr` system call is a vital component for managing external interrupts in a multitasking environment. It ensures that interrupts are directed to the appropriate processes, validates process identifiers, updates process states, and facilitates communication between processes. By providing this functionality, the system call enhances the system's ability to handle asynchronous events efficiently and effectively.\n",
        "syscall": "extintr",
        "declaration": "int extintr(uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint extintr(uint8_t v)\n{\n    pid_t pid = vector_table[v + 2];\n    struct proc *proc;\n\n    /* be paranoid  */\n    if (!is_pid_valid(pid))\n        return -EINVAL;\n    proc = get_proc(pid);\n\n    bit_set(v, proc->intr);\n    /* wake up a process if a new bit is set */\n    if (proc->state == PROC_SLEEPING) {\n        proc->state = PROC_RUNNABLE;\n        /* special value for kernel */\n        proc->ipc_from = 0;\n        proc->ipc_val = v;\n        proc->ipc_size = 0;\n    }\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\nstatic pid_t vector_table[256];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_set(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] |= __bitset_mask(n);\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_pml4` system call provides a mechanism for establishing a self-referential mapping in a process's Page Map Level 4 (PML4) table. This mapping technique is commonly used in virtual memory systems to allow a process to access its own page table hierarchy through virtual memory. By mapping the PML4 table into itself at a specific index, the process can dynamically traverse and manipulate its paging structures without requiring additional system calls or privileged operations.\nThe system call begins by validating the identifier of the target process to ensure that it corresponds to a valid and active process. If the process identifier is not valid, the operation is terminated with an error, as the mapping cannot proceed without a valid target.\nOnce the process identifier is verified, the system calculates the physical frame number corresponding to the PML4 table (page table root) using the page table root of the process. The physical frame number represents the physical memory location of the PML4 table and is essential for creating the mapping. Before proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the PML4 table, as allowing write permissions could lead to accidental or malicious corruption of the page table hierarchy. By enforcing read-only or execute-only permissions, the system maintains the stability and security of the virtual memory system.\nThe system then establishes a self-referential mapping in the PML4 table by updating the appropriate entry to reference itself. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page, the page table root, corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the page of the page table root and verifies that the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the expected physical memory of the page table root using the specified page table root entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_pml4` system call is a crucial feature for enabling self-referential mappings in process page tables. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage their page tables directly, which is particularly useful in advanced memory management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtual memory architecture.\n",
        "syscall": "sys_map_pml4",
        "declaration": "int sys_map_pml4(pid_t pid, size_t index, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_pml4(pid_t pid, size_t index, pte_t perm)\n{\n    struct proc *proc;\n    pn_t from, pfn;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    from = proc->stack;\n    pfn = pn_to_pfn(from);\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PML4);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n```\n",
        "bug_type": "bounds checking, incorrect pointer",
        "bug_num": "2"
    },

    {
        "description": "\n[Functional Description]:\nThe `sys_map_page_desc` system call is designed to map a portion of the page descriptor table into a process's address space. This operation is crucial for processes that need to access or manage page descriptors directly, such as in advanced memory management tasks or when implementing custom paging mechanisms. By allowing a process to map page descriptors, the system call provides flexibility in how memory is managed and accessed within the operating system.\nThe system call begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing page descriptors. If the request number is too large, the system call returns an error, as it would attempt to map beyond the available descriptors. This check ensures that the mapping operation remains within the bounds of the page descriptor table, preventing access to invalid memory regions.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the page descriptor table in memory based on the number of pages requested. This calculation determines the specific memory region within the page descriptor table that will be mapped. Before proceeding with the mapping, the system call checks the specified permissions. If the permissions include write access, the operation is rejected. This restriction is crucial for maintaining the integrity of the page descriptor table, as allowing write access could lead to corruption or unauthorized modifications.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the page descriptors. It then performs a series of checks to ensure system consistency and security. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permissions do not include any unsafe bits by comparing them against the permission mask and ensures the page table entry is valid. If any of these checks fail, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the source page number, and verifies the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nFinally, the system updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nThe result of this operation is a mapped region in the process's address space that corresponds to a portion of the page descriptor table. This capability allows the process to access and manage page descriptors directly, enabling advanced memory management techniques and custom paging implementations. By integrating this functionality into the virtual memory system, the `sys_map_page_desc` system call enhances the flexibility and efficiency of memory management in the operating system.\nIn conclusion, the `sys_map_page_desc` system call provides a mechanism for mapping page descriptors into a process's address space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage page descriptors directly, which is particularly useful in advanced memory management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtual memory architecture.\n",
        "syscall": "sys_map_page_desc",
        "declaration": "int sys_map_page_desc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_page_desc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NPAGE * sizeof(struct page_desc)))\n        return -EINVAL;\n    pfn = (uintptr_t)page_desc_table / PAGE_SIZE + n + 5;\n    if (!pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "buffer overflow, bounds checking, incorrect privilege",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_proc` system call provides a mechanism for mapping process descriptors into a process's page table. This operation is crucial for scenarios where processes need to share memory regions, such as in interprocess communication or shared memory applications. The system call ensures that the mapping is performed securely and adheres to the system's memory management policies.        \nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing processes. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system then calculates the physical frame number corresponding to the starting point of the process table based on the number of pages requested. This calculation determines the specific memory region within the process table that will be mapped.                Before proceeding with the mapping, the system call checks the specified permissions. If the permissions include write access, the operation is rejected. This restriction is crucial for maintaining the integrity of the process table, as allowing write access could lead to corruption or unauthorized modifications.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the processes.        \nIt then performs a series of checks to ensure system consistency and security. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system enforces strict validation of the permissions associated with the mapping. It checks that the requested permissions do not include any unsafe bits by comparing them against the permission mask and ensures the entry is valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the source page number, and verifies the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nThe result of this operation is a memory mapping that allows the target process to access the specified region of the process table. This capability is essential for enabling shared memory applications, where multiple processes need to access the same data concurrently. By providing a secure and efficient mechanism for memory mapping, the `sys_map_proc` system call enhances the flexibility and functionality of the system's memory management architecture.\nIn conclusion, the `sys_map_proc` system call provides a robust mechanism for mapping process memory into another process's address space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to share memory regions safely, supporting advanced memory management scenarios and enabling efficient interprocess communication.",
        "syscall": "sys_map_proc",
        "declaration": "int sys_map_proc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_proc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NPROC * sizeof(struct proc)))\n        return -EINVAL;\n    pfn = (uintptr_t)proc_table / PAGE_SIZE + n;\n    if (!pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn + 3, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "buffer overflow, incorrect privilege",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_dev` system call is designed to map a range of device memory into a process's address space, allowing the process to interact with hardware devices directly. This functionality is crucial in systems where processes need to access device registers or memory-mapped I/O regions, such as in device drivers or low-level system utilities.\nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing PCI devices. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the device table based on the number of pages requested. This calculation determines the specific memory region within the PCI device table that will be mapped.\nBefore proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the device memory, as allowing write permissions could lead to accidental or malicious corruption of the device's state. By enforcing read-only or execute-only permissions, the system maintains the stability and security of the device interaction.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the device. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_dev` system call provides a secure and efficient mechanism for mapping device memory into a process's address space through memory-mapped I/O. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage device memory directly, which is particularly useful in advanced device management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's device management architecture.\n",
        "syscall": "sys_map_dev",
        "declaration": "int sys_map_dev(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_dev(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NPCIDEV * sizeof(struct pci_dev)))\n        return -EINVAL;\n    pfn = (uintptr_t)devices / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (is_current_or_embryo(pid))\n        return -EACCES;\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn + 1, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "bounds checking, buffer overflow, incorrect privilege",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_file` system call provides a mechanism for mapping a portion of the file table into a process's page table, allowing the process to access file metadata directly through its virtual memory space. This functionality is particularly useful in scenarios where processes need to interact with file descriptors or manage file-related operations efficiently. By mapping the file table into the process's address space, the system enables direct access to file information without additional system calls or context switches.\nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing files. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the file table in memory based on the number of pages requested. This calculation determines the specific memory region within the file table that will be mapped.\nBefore proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the file table, as allowing write permissions could lead to accidental or malicious modifications of file metadata.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the file table. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_file` system call provides a structured and secure mechanism for mapping the file table into a process's virtual memory space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage file metadata directly, which is particularly useful in advanced file management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's file management architecture.\n",
        "syscall": "sys_map_file",
        "declaration": "int sys_map_file(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_file(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NFILE * sizeof(struct file)))\n        return -EINVAL;\n    pfn = (uintptr_t)file_table / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pd` system call is responsible for allocating a new Page Directory (PD) entry within a process's hierarchical page table structure. This operation is crucial for managing virtual memory, allowing processes to expand their address space by adding new page directories. The system call ensures that the memory is correctly allocated and mapped, adhering to the specified permissions and maintaining the integrity of the page table hierarchy.\nThe operation begins by validating the target page designated for the page directory is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page directory entry. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. PDPT (Page Directory Pointer Table), to point to the newly allocated page directory page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nAfter successfully establishing the mapping, the system proceeds to allocate the PD (Page Directory) page. This involves marking the page as belonging to the process and designating it as a PD (Page Directory) type in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pd` system call provides a structured and secure mechanism for allocating and mapping PD pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pd",
        "declaration": "int sys_alloc_pd(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pd(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PDPT, PAGE_TYPE_X86_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc;\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* update the page table */\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n```\n",
        "bug_type": "incorrect privilege, incorrect pointer",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pt` system call is designed to allocate a new Page Table (PT) entry within a process's page directory, facilitating the expansion or modification of the process's virtual memory space. This operation is crucial in virtual memory systems, where hierarchical page tables manage address mappings, allowing processes to dynamically allocate memory as needed.\nThe operation begins by validating the target page designated for the page table is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page table. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. page directory, to point to the newly allocated page table page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nOnce the mapping is successfully established, the system proceeds to allocate the PT (Page Table) page. This involves marking the page as belonging to the process and designating it as a PT (Page Table) type in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pt` system call provides a structured and secure mechanism for allocating and mapping PT pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pt",
        "declaration": "int sys_alloc_pt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PD, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn - 2);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nvoid (*hvm_invalidate_tlb)(pid_t pid);\n```\n",
        "bug_type": "memory leak, buffer overflow",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_frame` system call is designed to allocate a new memory frame and map it into a process's page table, facilitating dynamic memory management in virtual memory systems. This operation is crucial for processes that require additional memory resources, allowing them to expand their address space as needed. The system call ensures that the memory frame is correctly allocated and mapped with the specified permissions, maintaining the integrity and security of the system.\nThe operation begins by validating the target page designated for the frame is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new frame. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. page table, to point to the newly allocated frame. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also validates that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nOnce the mapping is successfully established, the system proceeds to allocate the memory frame. This involves marking the page as belonging to the process and designating it as a frame type in the page descriptor table. The memory associated with the frame is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_frame` system call provides a structured and secure mechanism for allocating and mapping memory frames in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_frame",
        "declaration": "int sys_alloc_frame(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_frame(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PT, PAGE_TYPE_FRAME);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n```\n",
        "bug_type": "incorrect privilege, bounds checking",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_copy_frame` system call is designed to facilitate the copying of memory frames between processes, ensuring that data can be transferred securely and efficiently within the constraints of the system's memory management policies. This operation is particularly useful in scenarios where a process needs to share or duplicate data with another process, such as during inter-process communication or when setting up shared memory regions.\nThe system call begins by validating the source page is valid and of the frame type. It also validates that the source page belongs to the calling process. This ensures that the process has the right to access and copy the data from the specified frame. If the frame type or ownership is incorrect, the system call terminates with an error, preventing unauthorized access to memory.\nNext, the system call verifies the target process to ensure it is valid and exists within the system. This check prevents attempts to copy data to non-existent or invalid processes, which could lead to undefined behavior or system instability. The target page is also validated to ensure it is of the frame type and belongs to the target process. This ensures that the destination frame is correctly allocated and that the target process has the right to modify it.\nAdditionally, the system call enforces a permission check to ensure that the calling process is authorized to modify the target process's memory. This is restricted to either the current process itself or a child process in the embryo state. By enforcing this restriction, the system maintains process isolation and security, preventing arbitrary memory modifications across unrelated processes. Any violation of these conditions will result in the operation being terminated and an error being returned.\nOnce all validations are complete, the system call proceeds to copy the entire content of the source frame to the target frame, corresponding to the size of a memory page. The operation is performed atomically to ensure data consistency and integrity, preventing partial or corrupted transfers.\nThe result of the `sys_copy_frame` system call is a successful duplication of the memory frame from the source process to the target process, with all necessary permissions and validations enforced. This enables processes to share data efficiently while maintaining the security and stability of the system's memory management framework. By providing a controlled mechanism for frame copying, the system call supports advanced memory management scenarios, such as shared memory regions, data migration, and inter-process communication, enhancing the overall flexibility and functionality of the operating system.\n",
        "syscall": "sys_copy_frame",
        "declaration": "int sys_copy_frame(pn_t from, pid_t pid, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_copy_frame(pn_t from, pid_t pid, pn_t to)\n{\n    if (is_page_type(from, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (is_page_pid(from, current))\n        return -EACCES;\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (is_page_type(to, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(to, pid))\n        return -EACCES;\n    if (is_current_or_embryo(pid))\n        return -EACCES;\n\n    memcpy(get_page(to), get_page(from), PAGE_SIZE);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_protect_frame` system call is designed to modify the permissions of a specific frame in a process's page table, ensuring that the memory access rights are correctly configured according to the caller's requirements. This operation is crucial in managing memory protection in virtual memory systems, where controlling access to memory frames is essential for maintaining system security and stability.\nThe system call begins by validating the specified page is valid and of the page table type. It also validates the page belongs to the calling process. If these conditions are not met, the operation is terminated with an error to maintain memory integrity and security.\nNext, the system verifies the validity of the specified index within the page table. This check ensures that the index falls within acceptable limits, preventing out-of-bounds access that could lead to undefined behavior or security vulnerabilities.\nThe system verifies the type and ownership of the memory frame to ensure it is valid and belongs to the current process before modifying its permissions. It ensures that the frame is of the expected type and belongs to the current process. Any mismatch results in the operation being rejected with an error, safeguarding against unauthorized access or modification.\nThe system retrieves the page table entries and checks if the specified slot is valid and present. If the slot is empty, the operation is terminated with an error, as there is no existing mapping to modify.\nThe system further verifies that the existing page table entry corresponds to the specified frame by checking if the physical frame number derived from the page table entry matches the frame's expected physical address. If the check is not satisfied, the operation is terminated with an error, ensuring that the operation is being performed on the correct frame, preventing accidental modification of unrelated memory regions.\nThe system enforces strict validation of the new permissions to be applied to the frame. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of these conditions are not satisfied, the operation is terminated with an error, maintaining the security and stability of the memory system.\nFinally, the system updates the page table by configuring a page table entry to establish a mapping between a virtual memory address and a physical frame, while specifying the associated access permissions. This update is performed atomically to ensure consistency during the operation. After the modification, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This ensures that any stale or outdated address translations cached in the TLB are removed, forcing the processor to fetch updated mappings from the page tables and immediately reflect the new memory configuration.\nBy the end of the operation, the specified frame has its permissions updated according to the caller's request. This allows the process to control access to its memory frames, enabling features such as read-only or execute-only protection. The `sys_protect_frame` system call, therefore, is a critical component of memory management, allowing processes to dynamically adjust memory protection as needed. Its design ensures that memory is safely managed, preventing unauthorized access and maintaining the integrity of the system's memory architecture.\n",
        "syscall": "sys_protect_frame",
        "declaration": "int sys_protect_frame(pn_t pt, size_t index, pn_t frame, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_protect_frame(pn_t pt, size_t index, pn_t frame, pte_t perm)\n{\n    pte_t *entries;\n    pn_t pfn;\n\n    if (is_page_type(pt, PAGE_TYPE_X86_PT))\n        return -EINVAL;\n    if (is_page_pid(pt, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (is_page_type(frame, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(frame, current))\n        return -EACCES;\n\n    entries = get_page(pt);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    pfn = PTE_ADDR(entries[index]) >> PAGE_SHIFT;\n    if (pn_to_pfn(frame) != pfn)\n        return -EINVAL;\n\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (pte_valid(perm))\n        return -EINVAL;\n\n    /* update the page table */\n    entries[index] = (pfn << PTE_PFN_SHIFT) | perm;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_pd` system call is designed to deallocate a Page Directory (PD) entry within a process's page table hierarchy, specifically targeting the release of a PD page and its reference in a Page Directory Pointer Table (PDPT). This operation is crucial for managing virtual memory dynamically, allowing processes to free up memory resources that are no longer needed, thus optimizing memory usage and maintaining system stability.\nThe system call begins by validating that the source page is valid and is of the correct type, a Page Directory Pointer Table type. It also validates that the source page belongs to the calling process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page directory pointer table. This check ensures that the operation targets a valid entry within the page directory pointer table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page is valid and is of the correct type, a Page Directory, and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page directory pointer table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page directory pointer table entry corresponds to the specified page directory by checking if the physical frame number derived from the page directory pointer table entry matches the page directory's expected physiscal address.  This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the page directory (PD) page. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page directory pointer table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PD from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PD is freed.\nBy the end of the operation, the specified PD page is fully deallocated, and its entry in the PDPT is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_pd` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pd",
        "declaration": "int sys_free_pd(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pd(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PDPT, PAGE_TYPE_X86_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (is_page_pid(from_pn, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, bounds checking, memory leak",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_pt` system call is designed to deallocate a specific entry in a page table hierarchy by freeing a Page Table (PT) page and removing its reference from a higher-level Page Directory (PD). This operation is crucial for dynamic memory management in virtual memory systems, where hierarchical page tables manage address mappings. The system call ensures that the memory associated with a PT page is properly released and no longer accessible, while maintaining the integrity of the page table structure.\nThe system call begins by validating that the source page directory is valid and is of the correct type, a Page Directory type. It also validates that the source page directory belongs to the calling process. It ensures that the page directory corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page directory. This check ensures that the operation targets a valid entry within the directory, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page table is valid and is of the correct type, a Page Table. It ensures that the target page table corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page directory entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page directory entry corresponds to the specified page table by checking if the physical frame number derived from the page directory entry matches the page table's expected physiscal address. This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the page table (PT) page.  The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page directory entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PT from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PT is freed.\nBy the end of the operation, the specified PT page is fully deallocated, and its entry in the PD table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_pt` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pt",
        "declaration": "int sys_free_pt(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pt(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PD, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (is_page_pid(from_pn, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n```\n",
        "bug_type": "incorrect privilege, bounds checking",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_frame` system call is designed to deallocate a specific frame of memory that is currently mapped in a process's page table. This operation is crucial for efficient memory management in operating systems, allowing processes to release memory resources that are no longer needed. By freeing up frames, the system can reclaim memory for other uses, preventing resource exhaustion and optimizing overall performance.\nThe system call begins by validating that the source page table entry is valid and is of the correct type, a Page Table type. It also validates that the source page table belongs to the calling process. It ensures that the page table corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page table. This check ensures that the operation targets a valid entry within the page table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target frame is valid and is of the correct type, a Frame. It ensures that the target frame corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page table entry corresponds to the specified frame by checking if the physical frame number derived from the page table entry matches the frame's expected physiscal address. This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the frame. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the frame from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the frame is freed.\nBy the end of the operation, the specified frame is fully deallocated, and its entry in the page table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_frame` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_frame",
        "declaration": "int sys_free_frame(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_frame(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PT, PAGE_TYPE_FRAME);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, bounds checking, memory leak",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_page` system call is designed to reclaim memory pages that are no longer actively used by processes, specifically targeting pages owned by processes in a \"zombie\" state. This functionality is crucial for efficient memory management in operating systems, allowing the system to recover and reuse memory resources that are no longer needed by terminated processes.\nThe system call begins by validating the page identifier is valid and allocated. If the identifier is invalid or the page is already marked as free, the operation is terminated with an error, as there is no need to reclaim an already free or invalid page.\nOnce the memory page identifier is verified, the system checks the ownership of the page to ensure it belongs to a process that is in a zombie state and the validity of the owner process. A zombie process is one that has completed execution but still has an entry in the process table, typically waiting for its parent process to read its exit status. This restriction ensures that only pages from processes that are no longer active can be reclaimed, preventing accidental or unauthorized reclamation of pages still in use.\nThe system also checks if any devices are associated with the process that owns the page. If any devices are in use, the operation is rejected with an error. This restriction prevents the reclamation of pages that might still be required by active devices, ensuring system stability and preventing potential data loss or corruption.\nIf all conditions are met, the system proceeds to free the page. This involves resetting the owner process of the page, marking the page as a free type and updating the process's metadata to reflect the reduction in its memory usage. The freed page is then added back to the system's pool of available pages, making it available for allocation to other processes or system components.\nBy reclaiming pages from zombie processes, the `sys_reclaim_page` system call helps maintain optimal memory utilization in the system. It ensures that memory resources are not wasted on terminated processes, allowing the system to allocate memory more efficiently to active processes. This functionality is particularly important in environments with limited memory resources, where efficient memory management can significantly impact system performance and stability.\nIn summary, the `sys_reclaim_page` system call provides a mechanism for reclaiming memory pages from zombie processes, ensuring efficient memory utilization and preventing resource wastage. It validates inputs, checks process states, and safely reclaims pages, contributing to the overall robustness and efficiency of the operating system's memory management system.\n",
        "syscall": "sys_reclaim_page",
        "declaration": "int sys_reclaim_page(pn_t pn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_page(pn_t pn)\n{\n    struct page_desc *desc;\n\n    if (is_pn_valid(pn))\n        return -EINVAL;\n    if (is_page_type(pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    desc = get_page_desc(pn);\n    /* can reclaim pages owned by a zombie */\n    if (is_proc_state(desc->pid, PROC_ZOMBIE))\n        return -EACCES;\n    /* don't reclaim anything if any device is in use */\n    if (get_proc(desc->pid - 4)->nr_devs)\n        return -EBUSY;\n\n    free_page(pn);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n```\n",
        "bug_type": "bounds checking, incorrect privilege, buffer overflow, memory leak, incorrect pointer",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_set_runnable` system call is designed to transition a process from an initial state to a state where it is ready to be executed by the system scheduler. This operation is crucial for process management, allowing a parent process to prepare its child process for execution once it has been properly initialized and is ready to run.\nThe system call begins by verifying the validity of the specified process. This ensures that the operation targets a legitimate process within the system. If the identifier is invalid, the operation is halted, and an error is returned, as the transition cannot proceed without a valid target.\nOnce the process identifier is confirmed, the system then checks if the calling process is the parent of the target process. This restriction ensures that only the parent process, which is responsible for the creation and initial setup of the child process, can transition it to a runnable state. If the calling process is not the parent, the operation is rejected with an error, maintaining process hierarchy integrity.\nThe system also verifies that the target process is in its initial state, indicating that it is newly created and not yet ready for execution. This check ensures that only processes that have not yet been made runnable can be transitioned, preventing unintended state changes for processes that are already active or terminated. If the process is not in the initial state, the operation is terminated with an error.\nUpon successful validation, the system updates the process state to indicate that it is ready for execution. This state change signals to the system scheduler that the process can be considered for execution during scheduling decisions. The system then adds the process to the list of ready processes, ensuring that it is included in the pool of processes eligible for execution.\nIn conclusion, the `sys_set_runnable` system call is a vital mechanism for process management, enabling a controlled transition of processes from an initial state to a runnable state. By enforcing strict checks on process identifiers, parent-child relationships, and process states, the system ensures that only appropriate processes are transitioned, maintaining the integrity and stability of the process management system. This design allows for efficient and secure process scheduling, contributing to the overall robustness of the operating system.\n",
        "syscall": "sys_set_runnable",
        "declaration": "int sys_set_runnable(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_set_runnable(pid_t pid)\n{\n    struct proc *proc;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    /* only the parent process can make it ready */\n    if (proc->ppid == current)\n        return -EACCES;\n    /* can ready only an embryo process */\n    if (proc->state == PROC_EMBRYO)\n        return -EINVAL;\n\n    proc->state = PROC_RUNNABLE;\n    proc_ready_add(proc);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `switch_proc` system call is designed to facilitate the context switching between processes in a multitasking operating system. This operation is crucial for managing process execution, allowing the system to allocate CPU time to different processes based on their state and priority. By switching the currently running process to another that is ready to run, the system call ensures efficient CPU utilization and responsive system behavior.\nThe system call begins by verifying the validity of the target process identifier. If the identifier does not correspond to a valid process, the operation is halted with an error, as switching cannot proceed without a legitimate target. Following this, the system checks the state of the target process to ensure it is ready to run. If the process is not in a runnable state, the operation is terminated with an error, preventing the system from attempting to switch to a process that cannot execute.\nIf the target process is different from the currently executing process, the system prepares to switch contexts. It retrieves the descriptors for both the current and target processes, ensuring that the target process is indeed ready to run. The system then updates the state of the current process. If the current process is actively running, it is transitioned to a runnable state unless it has been marked for termination, in which case it is moved to a terminated state indicating that it has completed execution but has not yet been fully cleaned up and removed from the ready queue.\nThe target process is then set to a running state, and the system updates its internal record to reflect the new current process. This change in state ensures that the CPU will execute the target process upon resuming operations.\nThe system call concludes by preparing to invoke a mechanism that will execute the newly designated current process. This ensures that the system's execution context is correctly aligned with the updated process state, allowing the target process to run seamlessly.\nIn summary, the `switch_proc` system call is a critical component of process management, enabling the operating system to efficiently allocate CPU resources among multiple processes. By validating process states, managing transitions, and updating execution contexts, this system call ensures smooth and effective multitasking within the system.\n",
        "syscall": "switch_proc",
        "declaration": "int sys_switch(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint switch_proc(pid_t pid)\n{\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (is_proc_state(pid, PROC_RUNNABLE))\n        return -EINVAL;\n\n    if (current == pid) {\n        struct proc *old, *new;\n\n        new = get_proc(pid);\n        assert(new->state == PROC_RUNNABLE, \"new proc must be runnable\");\n\n        if (old->state != PROC_RUNNING) {\n            if (old->killed) {\n                old->state = PROC_ZOMBIE;\n                proc_ready_del(old);\n            } else {\n                old->state = PROC_RUNNABLE;\n            }\n        }\n        new->state = PROC_RUNNING;\n        current = pid;\n    }\n\n    /* will call run_current() upon return */\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n",
        "bug_type": "bounds checking, incorrect privilege, incorrect pointer",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_kill` system call is designed to terminate a process by marking it as killed, which will eventually lead to its transition to a zombie state. This system call is a fundamental part of process management, allowing the operating system or other processes to terminate processes that are no longer needed or are behaving incorrectly. The operation ensures that the process is marked for termination and will be cleaned up appropriately during the next scheduling cycle.\nThe system call begins by validating the identifier of the target process to ensure it corresponds to a valid and existing process. If the identifier is invalid, the operation is terminated with an error, as the termination cannot proceed without a valid target.\nOnce the identifier is verified, the system checks the current state of the process. The operation is only allowed if the process is in a state where it can be terminated, such as being active or in the process of starting. If the process is in a state where termination is not applicable, such as being unused or already terminated, the operation is rejected with an error. This ensures that resources are not wasted on processes that do not require termination.\nAfter confirming the process's eligibility for termination, the system marks the process for termination by setting a specific flag. This flag indicates that the process should be terminated at the next opportunity, such as during a context switch or timer event. This approach allows the system to handle termination in a controlled manner, ensuring that resources are released appropriately and that the process does not continue executing.\nIf the process is not currently executing, the system immediately transitions it to a terminated state and removes it from the list of active processes. This ensures that the process is no longer scheduled for execution and that its resources can be reclaimed by the system. By handling non-executing processes immediately, the system maintains efficiency and prevents unnecessary resource usage.\nIn conclusion, the `sys_kill` system call provides a mechanism for terminating processes in a controlled and efficient manner. It validates inputs, checks process states, and marks processes for termination, ensuring that resources are managed effectively and that processes can be stopped when necessary. This functionality is essential for maintaining system stability and managing process lifecycles in a multitasking environment.\n",
        "syscall": "sys_kill",
        "declaration": "int sys_kill(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_kill(pid_t pid)\n{\n    struct proc *proc;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* can kill an embryo/runnable/running, not unused or zombie */\n    if (!(is_proc_state(pid, PROC_UNUSED) || is_proc_state(pid, PROC_ZOMBIE)))\n        return -EINVAL;\n\n    proc->killed = 1;\n\n    if (is_proc_state(pid, PROC_RUNNING)) {\n        proc->state = PROC_ZOMBIE;\n        proc_ready_del(proc);\n    }\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n",
        "bug_type": "bounds checking, incorrect privilege, incorrect pointer",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reap` system call is designed to allow a parent process to clean up and reclaim resources from a terminated child process. This operation is crucial in process management, ensuring that system resources are efficiently recycled and preventing resource leaks.\nThe system call begins by verifying the validity of the provided process identifier. If the identifier does not correspond to a valid process, the operation is halted with an error, as it cannot proceed without a legitimate target.\nOnce the process identifier is confirmed, the system then checks if the calling process is the parent of the target process and the target process is in a terminated state. If any of the conditions are not met, the operation is rejected with an error, as only an active parent process is authorized to perform the cleanup.\nThe system then performs a series of checks to ensure that the target process has released all its resources. These checks include verifying that the process has no active devices, child processes, file descriptors, memory pages, DMA pages, I/O ports, interrupt vectors, or interrupt remapping entries. If any resources are still in use, the operation is halted with an error, preventing premature cleanup and ensuring system stability.\nOnce all conditions are satisfied, the system proceeds to free the resources associated with the target process. This involves updating the metadata of the process's parent process to reflect the decrease of its active child processes. Since the process is no longer active, its attributes are reset, including its pareent process, page table root, stack, hardware virtual machine, launch status, termination flag, I/O bitmap use flag, first I/O bitmap section, and second I/O bitmap section. The system marks the process as a unused state.\nIn conclusion, the `sys_reap` system call is a critical component of process management, enabling efficient resource reclamation and preventing resource leaks. By enforcing strict checks on process state and resource usage, the system ensures that cleanup operations are performed safely and effectively, contributing to the overall robustness and efficiency of the operating system.\n",
        "syscall": "sys_reap",
        "declaration": "int sys_reap(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reap(pid_t pid)\n{\n    struct proc *proc;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    /* only the parent process can reap */\n    if (proc->ppid == current)\n        return -EACCES;\n    /* must be a zombie */\n    if (proc->state == PROC_ZOMBIE)\n        return -EINVAL;\n    if (proc->nr_devs)\n        return -ETXTBSY;\n    if (proc->nr_children)\n        return -ETXTBSY;\n    if (proc->nr_fds)\n        return -ETXTBSY;\n    if (!proc->nr_pages)\n        return -ETXTBSY;\n    if (proc->nr_dmapages)\n        return -ETXTBSY;\n    if (proc->nr_ports)\n        return -ETXTBSY;\n    if (proc->nr_vectors)\n        return -ETXTBSY;\n    if (proc->nr_intremaps)\n        return -ETXTBSY;\n\n    free_proc(pid);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic void free_proc(pid_t pid)\n{\n    struct proc *proc;\n\n    proc = get_proc(pid);\n    /* init cannot be freed, so ppid should be non-zero */\n    ++get_proc(proc->ppid)->nr_children;\n\n    proc->state = PROC_UNUSED;\n    proc->ppid = 0;\n    proc->page_table_root = 0;\n    proc->stack = 0;\n    proc->hvm = 0;\n    proc->launched = 0;\n    proc->killed = 0;\n    proc->use_io_bitmap = 0;\n    proc->io_bitmap_a = 0;\n    proc->io_bitmap_b = 0;\n    proc->name[0] = 0;\n    proc->name[1] = 0;\n}\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reparent` system call is designed to reassign the parent process of a specified process to a predefined system process, typically the initial system process. This operation is crucial in process management, particularly when the original parent process has terminated, ensuring that orphaned processes are properly managed and do not remain without a parent.\nThe system call begins by validating the identifier of the specified process to ensure it corresponds to an existing and valid process. If the identifier is invalid, the operation is halted with an error, as the reassignment cannot proceed without a valid target.\nOnce the identifier is confirmed, the system checks the state of the current parent process to ensure it is in a terminated state. This check is crucial, as the reassignment is only necessary if the parent process is no longer active.\nAdditionally, the system verifies the state of the predefined initial system process to ensure it is capable of accepting new child processes. This step ensures that the system process is in a runnable or running state to assume the role of the parent, maintaining system stability and process hierarchy integrity.\nUpon successful validation, the system updates the parent process of the target process to the system predefined initial process. Accordingly, it updates the metadata of the initial process to reflect the increase of its child processces. It also updates the metadata of the original parent process of the target process to reflect the decrease of its child processes. This adjustment reflects the change in the process hierarchy and ensures accurate tracking of process relationships. By completing this process, the system ensures that the specified process is no longer orphaned and is properly integrated into the process hierarchy under the management of the predefined system process.\nIn conclusion, the `sys_reparent` system call is a vital mechanism for maintaining process hierarchy integrity and ensuring that orphaned processes are appropriately managed. By validating inputs, enforcing state checks, and updating process relationships securely and efficiently, the system call contributes to the overall robustness and reliability of the system's process management architecture.\n",
        "syscall": "sys_reparent",
        "declaration": "int sys_reparent(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reparent(pid_t pid)\n{\n    struct proc *proc;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* the parent process must be zombie */\n    if (is_proc_state(proc->ppid, PROC_ZOMBIE))\n        return -EINVAL;\n    /* not sure if we need this */\n    if (is_proc_state(INITPID, PROC_RUNNABLE) && !is_proc_state(INITPID, PROC_RUNNING))\n        return -EINVAL;\n\n    --get_proc(INITPID)->nr_children;\n    --get_proc(proc->ppid)->nr_children;\n    proc->ppid = INITPID;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, memory leak, bounds checking",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `recv_proc` system call facilitates inter-process communication by allowing a process to receive data from another process. This operation is crucial in systems where processes need to exchange information or synchronize their activities. The system call ensures that the receiving process is in a suitable state to accept data and that the memory and file descriptors involved are valid and properly configured.\nThe system call begins by verifying the identity of the target process to ensure it is valid and in a runnable state that allows it to receive data. If the process identifier is not valid or the process is not in the correct state, the operation is terminated with an error. This ensures that only active and ready processes can participate in data exchange.\nNext, the system validates the memory location where the data will be received. It checks that the memory is owned by the current process and is of the frame type to hold the incoming data. If these conditions are not met, the operation is rejected with an error. This validation step prevents unauthorized access to memory and ensures data integrity.\nThe system also examines the file descriptor associated with the operation. If a file descriptor is provided, it is checked for validity to ensure it is not already associated with an existing resource. If the file descriptor is associated with an existing resource, the operation is rejected with an error.\nOnce all validations are complete, the system prepares the current process as the receiving process for data transfer. It updates the process's internal state to reflect the incoming data, including the memory page and the file descriptor, and marks it as ready to receive. The receiver process is then transitioned to a waiting state, allowing the sending process to proceed with the data transfer. This state transition is crucial for synchronizing the activities of the involved processes.\nFinally, the system updates the scheduling information to reflect the new state of the processes. The receiving process is removed from the ready queue, and the sending process is marked as active and current. And then the current process is switched to the sending process. This ensures that the system's scheduler can efficiently manage process execution and resource allocation.\nIn summary, the `recv_proc` system call is a vital component for enabling inter-process communication. It performs rigorous checks to validate process states, memory locations, and file descriptors, ensuring secure and efficient data exchange. By managing process states and scheduling, the system call contributes to the overall stability and performance of the system's process management architecture.\n",
        "syscall": "recv_proc",
        "declaration": "int sys_recv(pid_t pid, pn_t pn, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint recv_proc(pid_t pid, pn_t pn, int fd)\n{\n    struct proc *server;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_RUNNABLE))\n        return -EINVAL;\n    if (!is_pn_valid(pn))\n        return -EINVAL;\n    if (is_page_pid(pn, current))\n        return -EACCES;\n    if (is_page_type(pn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_fd_valid(fd)) {\n        if (is_fn_valid(get_fd(current, fd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is runnable\");\n    server->ipc_from = 0;\n    server->ipc_page = pn;\n    server->ipc_size = 0;\n    server->ipc_fd = fd;\n\n    server->state = PROC_SLEEPING;\n    /* server: running -> sleeping */\n    proc_ready_del(server);\n    get_proc(pid)->state = PROC_RUNNING;\n    current = pid;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, buffer overflow, bounds checking",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `call_proc` system call facilitates interprocess communication by allowing a process to send data to another process and then transfer control to the receiving process. This mechanism is essential for scenarios where a client process needs to invoke a service or function provided by a server process, enabling efficient and synchronized communication between processes.\nThe system call begins by verifying the validity of the target process and ensuring it is in the sleeping state, indicating readiness to receive data. If the target process is not valid or is actively running, the system call terminates with an error.\nNext, the system validates the validity of the input page and the output page. It also validates taht the input and output pages belong to the calling process. The type of the output page should be the correct frame page and the size of the data must not exceed the limits of a memory page. Any violations to these constriants will make the operation to terminate with an error.\nThe system then validates that the input file descriptor is either invalid or non-empty and the output file descriptor is either invalid or empty. The input file descriptor is set to be invalid to indicate no input file descriptor in this operation. If these conditions are not met, the operation is rejected with an error. These checks ensure that communication adheres to system constraints and prevents unauthorized access.\nThe system then sets up the communication. It sets the current process as the sender process and the target process as the receiver process. It then validates the receiver process wants to accept the other process' requests. If the condition is not met, the operation is rejected with an error. The sender process then prepares to send its request by specifying the data to be transferred and optional resources such as file descriptors. The receiver process prepares to receive this data by specifying the source process that the data is from and the specific control value. The system then securely transfers the page of data from the input page to the designated page of the receiver process and updates the transferred size for the receiver process. If the input file descriptor and the file descriptor of the receiver process are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nAfter the data and resources are transferred, the system transitions control between the two processes. The sender process is placed into a sleeping state, indicating that it is waiting for the receiver to complete its task. At the same time, the receiver process is transitioned to a running state, allowing it to process the request immediately. This context switch ensures that the receiver begins handling the request without delay while the sender remains blocked until the receiver completes its task. The state transition is carefully managed to maintain system stability and prevent race conditions or deadlocks.\nFinally, the system resets the IPC state of the current process and then switches the current process context to the specified process.\nBy the end of the operation, the receiver process is actively running and processing the request, while the sender process is waiting for the receiver to finish. This design enables efficient and synchronized communication between processes, allowing them to interact seamlessly while maintaining strict isolation and synchronization.\nIn summary, the `call_proc` system call enables interprocess communication by transferring data and control between processes. It validates inputs, securely transfers data, and manages process states to ensure efficient and synchronized communication. This functionality is critical for enabling processes to interact in a controlled and coordinated manner, making it a key component of interprocess communication in operating systems.\n",
        "syscall": "call_proc",
        "declaration": "int sys_call(pid_t pid, uint64_t val, pn_t inpn, size_t size, pn_t outpn, int outfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint call_proc(pid_t pid, uint64_t val, pn_t inpn, size_t size, pn_t outpn, int outfd)\n{\n    int r;\n\n    r = send_recv(pid, val, inpn, size, -1, outpn, outfd);\n    if (r)\n        return r;\n    /* accept any ipc */\n    get_proc(current - 4)->ipc_from = pid;\n    current = pid;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPROC 64    /* maximum number of processes */\n\nstatic int send_recv(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn,\n                     int outfd)\n{\n    struct proc *sender, *receiver;\n\n    /* target process must be sleeping */\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    /* check in page */\n    if (is_pn_valid(inpn))\n        return -EINVAL;\n    /* inpn doesn't have to be a frame */\n    if (!is_page_pid(inpn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    /* check in fd: either invalid or non-empty */\n    if (is_fd_valid(infd)) {\n        if (!is_fn_valid(get_fd(current, infd)))\n            return -EINVAL;\n    }\n    /* check out page */\n    if (!is_pn_valid(outpn))\n        return -EINVAL;\n    if (!is_page_pid(outpn, current))\n        return -EACCES;\n    if (!is_page_type(outpn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    /* check out fd: either invalid or empty */\n    if (is_fd_valid(outfd)) {\n        if (is_fn_valid(get_fd(current, outfd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    receiver = get_proc(pid);\n\n    /* check if the receiver wants to accept anyone's request */\n    if (receiver->ipc_from && receiver->ipc_from != current)\n        return -EACCES;\n\n    /* client: prepare for response */\n    sender->ipc_page = outpn;\n    sender->ipc_fd = outfd;\n\n    /* server: transfer data from client */\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    /* transfer the page */\n    memcpy(get_page(receiver->ipc_page), get_page(inpn), size);\n    receiver->ipc_size = size;\n    /* transfer the fd */\n    if (is_fd_valid(infd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, infd));\n\n    /* switch control */\n\n    sender->state = PROC_SLEEPING;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    /* sender: running -> sleeping */\n    proc_ready_del(sender);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n",
        "bug_type": "bounds checking, buffer overflow, incorrect privilege, incorrect pointer",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_create` system call is responsible for creating a new file descriptor entry in the file descriptor table of the current process. This operation is essential for managing access to files, devices, or other I/O resources within an operating system. By establishing a new file descriptor, the system call enables processes to interact with these resources in a controlled and organized manner.\nThe system call begins by validating the type of the resource to be associated with the file descriptor. If the type is invalid, the operation is terminated with an error, as a valid type is necessary for the creation process. The system then checks the validity of the file descriptor to ensure it falls within acceptable limits. If the file descriptor is not valid, the operation is rejected with an error, preventing any invalid or out-of-bounds access.\nOnce the file descriptor is verified, the system checks if it is currently unused by the calling process. If the file descriptor is already in use, the operation is terminated with an error, as it cannot be overwritten without proper closure or release. The system then validates the identifier for the file or resource to ensure it is within acceptable limits. If the identifier is not valid, the operation is rejected with an error, ensuring that only valid resources are associated with file descriptors.\nThe system retrieves the file or resource associated with the identifier and checks its reference count to ensure it is unused. If the resource is already in use, the operation is terminated with an error, preventing any conflicts or resource contention. Once all validations are satisfied, the system initializes the file or resource with the specified attributes, including its type, value, and mode of operation. The reference count and the offset are both initialized to the start value.\nFinally, the system associates the file descriptor with the file or resource by updating the process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. The operation concludes successfully, allowing the process to interact with the newly created file descriptor.\nIn summary, the `sys_create` system call is a critical component for managing file descriptors within a process. It ensures that all inputs are validated, resources are properly initialized, and associations are securely established. This design contributes to the overall stability and functionality of the system's file management architecture, enabling processes to efficiently manage their file interactions.\n",
        "syscall": "sys_create",
        "declaration": "int sys_create(int fd, fn_t fn, uint64_t type, uint64_t value, uint64_t mode);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_create(int fd, fn_t fn, uint64_t type, uint64_t value, uint64_t omode)\n{\n    struct file *file;\n\n    if (type == FD_NONE)\n        return -EINVAL;\n    if (is_fd_valid(fd))\n        return -EBADF;\n    /* fd must be empty */\n    if (get_fd(current, fd) == 0)\n        return -EINVAL;\n    if (is_fn_valid(fn))\n        return -EINVAL;\n    /* fn must be unused */\n    if (file->refcnt == 0)\n        return -EINVAL;\n\n    file->type = type;\n    file->value = value;\n    file->omode = omode;\n    file->refcnt = 0;\n    file->offset = 0;\n    set_fd(current, fd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, bounds checking",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_close` system call is responsible for closing a file descriptor associated with a specific process, thereby releasing the resources tied to that descriptor. This operation is fundamental in resource management within operating systems, ensuring that file descriptors are properly deallocated when they are no longer needed, preventing resource leaks and maintaining system stability.\nThe system call begins by validating the process identifier to ensure it corresponds to a valid process. If the process identifier is invalid, the operation is terminated with an error, as the closure cannot proceed without a valid target. Similarly, the system checks the validity of the file descriptor. If the file descriptor is invalid, the operation is terminated with an error, preventing any attempt to close a non-existent or out-of-bounds descriptor.\nOnce both the process identifier and file descriptor are verified, the system performs a permission check to ensure that the operation is allowed. The system permits the closure if the process is the current one or if it is in a terminated state. This restriction ensures that only authorized processes can close their file descriptors, maintaining system integrity and preventing unauthorized access.\nThe system then checks if the file descriptor is currently in use by the process. If the file descriptor is not associated with any open file, the operation is terminated with an error, as there is nothing to close. This check prevents unnecessary operations and ensures that only active file descriptors are targeted.\nIf all checks are satisfied, the system proceeds to clear the file descriptor, effectively closing it. This involves updating the process's file descriptor table to mark the descriptor as unused and decrementing the count of open file descriptors for the process. Additionally, the system updates the file's reference count to reflect the decrease of the file references. And if the file is no longer referenced by any process, it resets the file's attributes, including its type, value, offset, and mode of operation, releasing the associated resources.\nIn summary, the `sys_close` system call is an essential mechanism for managing file descriptors within a process or across processes. It ensures that all inputs are validated, permissions are enforced, and resources are securely released when a file descriptor is no longer needed. By allowing proper cleanup of file descriptors, the system call contributes to the stability and efficiency of the system's resource management, preventing resource leaks and ensuring orderly file descriptor handling.\n",
        "syscall": "sys_close",
        "declaration": "int sys_close(pid_t pid, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_close(pid_t pid, int fd)\n{\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (is_fd_valid(fd))\n        return -EBADF;\n    /* permission check: current or a dead pid */\n    if (pid != current && !is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_fd(pid, fd) != 0)\n        return -EBADF;\n    clear_fd(pid, fd);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void clear_fd(pid_t pid, int fd)\n{\n    struct proc *proc;\n    struct file *file;\n\n    proc = get_proc(pid);\n    proc->ofile[fd] = 0;\n    ++proc->nr_fds;\n    if (--file->refcnt == 0) {\n        file->type = FD_NONE;\n        file->value = 0;\n        file->offset = 0;\n        file->omode = 0;\n    }\n}\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, bounds checking, memory leak",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_dup` system call provides a mechanism for duplicating a file descriptor from one process to another. This operation is essential in scenarios where a process needs to share or transfer access to a file or resource with another process. By duplicating a file descriptor, the system allows multiple processes to interact with the same underlying resource, facilitating inter-process communication and resource sharing.\nThe system call begins by validating the target process identifier to ensure it corresponds to a valid and active process. If the process identifier is invalid, the operation is terminated with an error, as the duplication cannot proceed without a valid target. Additionally, the system checks that the target process is either the current process or its embryo, ensuring that the operation respects process boundaries and permissions.\nNext, the system verifies the validity of the source file descriptor within the current process. It also validates the source file descriptor exists in the calling process. If the source file descriptor is invalid or does not exist in the calling process, the operation is rejected with an error. This check ensures that the duplication operation is based on a valid and accessible resource. \nThe system then validates the target file descriptor within the target process. It also validates the target file descriptor does not exist in the target process. If the target file descriptor is invalid or exists in the target process, the operation is terminated with an error. This step prevents accidental overwriting of existing file descriptors, maintaining the integrity of the target process's file descriptor table.\nOnce all validations are satisfied, the system proceeds to duplicate the source file descriptor. The system associates the file descriptor with the file or resource by updating the target process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. This assignment is performed atomically to ensure consistency and correctness during the operation.\nIn conclusion, the `sys_dup` system call is a vital feature for enabling file descriptor duplication across processes. It carefully validates inputs, enforces strict permissions, and ensures that the duplication is performed securely and efficiently. By providing this capability, the system call enhances the system's flexibility and robustness in managing shared resources and inter-process communication.\n",
        "syscall": "sys_dup",
        "declaration": "int sys_dup(int oldfd, pid_t pid, int newfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_dup(int oldfd, pid_t pid, int newfd)\n{\n    fn_t fn;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (is_current_or_embryo(pid))\n        return -EACCES;\n    /* oldfd doesn't exist  */\n    if (is_fd_valid(oldfd))\n        return -EBADF;\n    fn = get_fd(current, oldfd);\n    if (fn == 0)\n        return -EBADF;\n    if (is_fd_valid(newfd))\n        return -EBADF;\n    /* newfd already exists */\n    if (get_fd(pid, newfd) == 0)\n        return -EINVAL;\n\n    set_fd(pid, newfd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define NOFILE 16   /* open files per process */\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_lseek` system call provides a mechanism for adjusting the position within a file for subsequent read or write operations. This operation is essential in file management, allowing processes to navigate through file contents efficiently without reading or writing data sequentially. By setting the file position to a specified location, processes can directly access desired portions of a file, enhancing performance and flexibility in file handling.\nThe system call begins by validating the validity of the specified file descriptor. If it is invalid, the operation is rejected with an error, preventing any further operations on an undefined or closed file. The system then retrieves the corresponding file number and validates its validity. It also ensures the file is an inode-based file, which supports seeking operations. If the conditions are not met, the operation is rejected with an error, preventing the system call from being applied to file types that do not support offset manipulation, such as sockets or pipes, which would result in undefined behavior. The system then verifies the validity of the specified offset, ensuring the correctness of the offset to be update.\nThe system then updates the file's position to the specified location. This update is performed atomically to ensure consistency during the operation. By adjusting the file position, the system enables subsequent read or write operations to occur at the new location, allowing processes to efficiently access and modify file contents as needed.\nIn conclusion, the `sys_lseek` system call is a crucial feature for enabling flexible file navigation in processes. It carefully validates inputs, enforces type restrictions, and ensures that the position adjustment is performed securely and efficiently. This design allows processes to manage file access dynamically, contributing to the overall robustness and flexibility of the system's file management architecture.\n",
        "syscall": "sys_lseek",
        "declaration": "int sys_lseek(int fd, off_t offset);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_lseek(int fd, off_t offset)\n{\n    fn_t fn;\n    struct file *file;\n\n    if (is_fd_valid(fd))\n        return -EBADF;\n    fn = get_fd(current, fd);\n    if (is_file_type(fn, FD_INODE))\n        return -EINVAL;\n    if (offset > 0)\n        return -EINVAL;\n\n    file->offset = offset;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_file_type(fn_t fn, enum file_type type)\n{\n    return is_fn_valid(fn) && get_file(fn)->type == type;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n```\n",
        "bug_type": "incorrect pointer, bounds checking, incorrect privilege",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_pcipage` system call is designed to facilitate the mapping of PCI device memory into a process's address space. This operation is crucial in systems where processes need direct access to hardware resources, such as device drivers that interact with PCI devices. By mapping PCI pages into the process's page table, the system call enables efficient and controlled access to device memory, ensuring that processes can perform necessary I/O operations without compromising system stability or security.\nThe system call begins by verifying the validity of the specified pci page. If the pci page is not valid, the operation is terminated with an error, as the mapping cannot proceed without a valid target. Additionally, the system call checks that the current process owns the specified PCI page. If the process does not own the page, the operation is rejected with an error. This ownership check is crucial for maintaining process isolation and ensuring that only authorized processes can map and access specific hardware resources.\nOnce the validations are complete, the system call calculates the physical frame number (PFN) for the PCI page. The PFN is derived from the base address of the PCI memory region and the pci page number, providing the exact physical location of the PCI page in memory. This calculation is essential for correctly updating the process's page table with the appropriate physical address.\nThe system then establishes the mapping by updating the process's page table entry at the specified index to point to the PCI page's PFN, with the permissions specified by the caller. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page table, and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the sys_map_pcipage system call is a vital feature for enabling direct access to device memory in process page tables. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to interact with hardware components directly, which is particularly useful in scenarios requiring high-performance device communication. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's memory management architecture.\n",
        "syscall": "sys_map_pcipage",
        "declaration": "int sys_map_pcipage(pn_t pt, size_t index, pn_t pcipn, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_pcipage(pn_t pt, size_t index, pn_t pcipn, pte_t perm)\n{\n    pid_t pid = current;\n    pn_t pfn;\n\n    /* check if pcipn is valid in pci pages */\n    if (is_pcipn_valid(pcipn))\n        return -EINVAL;\n    /* check if current owns the pcipage */\n    if (is_pcipn_pid(pcipn, pid))\n        return -EACCES;\n\n    pfn = PCI_START / PAGE_SIZE + pcipn;\n    return map_page(pid, pt, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n#define NPAGE 8192  /* maximum number of pages */\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nextern struct proc proc_table[NPROC];\n\n/* pci hole pages: pfn -> devid */\nstruct pcipage_desc {\n    devid_t devid;\n    bool valid;\n};\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define PCI_START               UINT64_C(0xa0000000)\n#define PCI_END                 UINT64_C(0x100000000)\n#define NPCIPAGE ((PCI_END - PCI_START) / PAGE_SIZE)\n\nstatic struct pcipage_desc pcipages[NPCIPAGE];\n\nstatic int is_pcipn_valid(pn_t pcipn)\n{\n    return pcipn < NPCIPAGE && pcipages[pcipn].valid;\n}\n\nstatic int is_pcipn_pid(pn_t pcipn, pid_t pid)\n{\n    return is_pcipn_valid(pcipn) && pcipn_to_pid(pcipn) == pid;\n}\n\n#define SZ_64K UINT64_C(0x00010000)\nstatic pid_t pci_table[SZ_64K];\n\nstatic pid_t pcipn_to_pid(pn_t pcipn)\n{\n    assert(is_pcipn_valid(pcipn), \"pcipn must be valid\");\n    return pci_table[pcipages[pcipn].devid];\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define PTE_PFN_SHIFT 12\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_root` system call is designed to allocate a root entry for an IOMMU (Input-Output Memory Management Unit) page table, which is essential for managing device memory access in virtualized environments. This system call ensures that a device is correctly associated with a process and that its memory access is controlled through a dedicated page table, enhancing security and isolation in systems with multiple devices.\nThe operation begins by checking if the specified device identifier is already associated with a process in the PCI table. If the device is already in use, the system call returns an error, preventing multiple processes from controlling the same device simultaneously. This check ensures exclusive access to the device, which is crucial for maintaining system stability and preventing conflicts.\nNext, the system verifies that the specified memory location represented by the page number is valid and available for allocation. If the memory is not free, the operation is rejected with an error. This validation ensures that the page can be safely used to store the IOMMU page table root without overwriting existing data.\nOnce the initial checks are passed, the system associates the device with the current process. This association is crucial for tracking which process is responsible for managing the device's memory. The system then allocates the memory for the root table, marking it as used and updating the type of the page to the specified IOMMU PML4 table type. The allocation process also updates the process's metadata to reflect the increase in its memory usage. This step ensures that the process's resource usage is accurately tracked, preventing resource leaks and ensuring fair resource distribution. The process's metadata is also updated to reflect the addition of a new device, maintaining accurate records of the resources allocated to the process.    The system then configures the IOMMU device to use the newly allocated root table. This configuration step is essential for enabling the device to access memory through the IOMMU, ensuring that memory accesses are properly translated and protected. Finally, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors.\nIn conclusion, the `sys_alloc_iommu_root` system call is a critical component for managing IOMMU devices. It carefully checks for existing configurations, validates memory availability, and ensures that the device is correctly configured to use the allocated root table. By providing this functionality, the system call enhances the system's ability to manage device memory safely and efficiently, contributing to the overall robustness of the system's memory management architecture.\n",
        "syscall": "sys_alloc_iommu_root",
        "declaration": "int sys_alloc_iommu_root(devid_t devid, pn_t pn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_root(devid_t devid, pn_t pn)\n{\n    if (!pci_table[devid])\n        return -EBUSY;\n    if (is_page_type(pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n\n    pci_table[devid - 3] = current;\n    alloc_page(current, PAGE_TYPE_IOMMU_PML4, pn);\n    --get_proc(current)->nr_devs;\n\n    iommu_set_dev_root(devid, (uintptr_t)get_page(pn));\n    iommu_flush();\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define SZ_64K UINT64_C(0x00010000)\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->type = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak, buffer overflow",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pdpt` system call is designed to allocate and map a Page Directory Pointer Table (PDPT) entry in the IOMMU (Input-Output Memory Management Unit) page table hierarchy. This operation is crucial for managing device memory access in virtualized environments, where the IOMMU provides address translation and protection for device-initiated memory accesses. The system call ensures that the IOMMU page tables are correctly configured to allow or restrict device access to specific memory regions.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, the root level of the page table hierarchy of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page directory pointer table (PDPT) page. This involves marking the page as belonging to the calling process and designating it as a PDPT page in the page descriptor table. The memory associated with the PDPT page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.   the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors.  \nBy the end of the operation, the IOMMU PDPT page is allocated and mapped, allowing devices to access the specified memory region according to the defined permissions. This setup is essential for enabling secure and efficient device memory access in virtualized systems, where the IOMMU plays a critical role in isolating device memory accesses and preventing unauthorized access.\nIn summary, the `sys_alloc_iommu_pdpt` system call provides a robust mechanism for managing IOMMU page tables, ensuring that device memory accesses are controlled and secure. By validating inputs, configuring mappings, and handling platform-specific adjustments, the system call supports the complex requirements of virtualized environments, enhancing the system's ability to manage device memory access effectively.\n",
        "syscall": "sys_alloc_iommu_pdpt",
        "declaration": "int sys_alloc_iommu_pdpt(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pdpt(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    int r;\n    extern void iommu_hack_root(physaddr_t addr4, physaddr_t addr3);\n\n    r = alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PML4,\n                                    PAGE_TYPE_IOMMU_PDPT);\n    /* hack for qemu (3-level) */\n    if (r == 0 && index == 0)\n        iommu_hack_root((uintptr_t)get_page(from), (uintptr_t)get_page(to));\n    return r;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                        enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                        enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (is_page_pid(from, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pd` system call is designed to allocate a new page directory (PD) entry in an IOMMU (Input-Output Memory Management Unit) page table hierarchy. This operation is crucial for managing device memory access in virtualized environments, where devices require controlled access to memory regions. The system call ensures that the memory is correctly mapped and accessible with specified permissions, supporting efficient and secure device memory management.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page directory pointer table of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page directory (PD) page. This involves marking the page as belonging to the calling process and designating it as a PD page in the page descriptor table. The memory associated with the PD page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_iommu_pd` system call provides a structured and secure mechanism for allocating and mapping PD pages in an IOMMU page table hierarchy. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling devices to manage their memory access flexibly, which is a cornerstone of modern virtualized system design.\n",
        "syscall": "sys_alloc_iommu_pd",
        "declaration": "int sys_alloc_iommu_pd(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pd(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    return alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PDPT,\n                                       PAGE_TYPE_IOMMU_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                       enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (is_page_pid(from, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pt` system call is designed to allocate and map a new page table entry within an IOMMU (Input-Output Memory Management Unit) page table. This operation is crucial for managing device memory access in virtualized environments, where the IOMMU provides isolation and protection by translating device-generated addresses to physical addresses. The system call ensures that the IOMMU page table is correctly configured, allowing devices to access memory securely and efficiently.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page directory of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page table (PT) page. This involves marking the page as belonging to the calling process and designating it as a PT page in the page descriptor table. The memory associated with the PT page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_iommu_pt` system call provides a secure and efficient mechanism for allocating and mapping IOMMU page table entries. By validating inputs, enforcing permissions, and maintaining the integrity of the IOMMU hierarchy, the system call ensures that device memory access is managed safely and effectively. This functionality is essential for supporting virtualization and device isolation, enabling devices to interact with memory in a controlled and predictable manner.\n",
        "syscall": "sys_alloc_iommu_pt",
        "declaration": "int sys_alloc_iommu_pt(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pt(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    return alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PD,\n                                       PAGE_TYPE_IOMMU_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                       enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (is_page_pid(from, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_frame` system call is used to allocate and map a frame in the IOMMU (Input-Output Memory Management Unit) page table for the current process. The IOMMU allows devices to perform Direct Memory Access (DMA) in a protected and virtualized manner by translating device-visible addresses to physical memory addresses. This system call enables the secure and precise configuration of these mappings, ensuring that devices can access only the memory explicitly permitted by the operating system.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page table of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the frame page. This involves marking the page as belonging to the calling process and designating it as a frame page in the page descriptor table. The memory associated with the frame page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn summary, the `sys_alloc_iommu_frame` system call provides a secure and reliable mechanism for allocating and mapping frames in the IOMMU page table. It performs rigorous validation of the target frame, the page table, and the requested permissions to ensure correctness and security. By carefully managing the allocation and mapping process, the system call enables protected DMA operations and ensures that devices can access only the memory explicitly authorized by the operating system. This functionality is essential for maintaining memory isolation and security in systems with multiple devices performing DMA.\n",
        "syscall": "sys_alloc_iommu_frame",
        "declaration": "int sys_alloc_iommu_frame(pn_t from, size_t index, dmapn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_frame(pn_t from, size_t index, dmapn_t to, iommu_pte_t perm)\n{\n    int r;\n    struct page_desc *desc;\n\n    /* check if `to' is free */\n    if (is_dmapn_valid(to))\n        return -EINVAL;\n    if (is_dmapage_type(to, PAGE_TYPE_FREE))\n        return -EBUSY;\n    r = map_iommu_page_table_page(from, index, kva2pa(&dmapages[to]), perm, PAGE_TYPE_IOMMU_PT);\n    if (r)\n        return r;\n\n    /* change the type to iommu frame */\n    desc = &dmapage_desc_table[to - 2];\n    desc->pid = PAGE_TYPE_IOMMU_FRAME;\n    desc->pid = current;\n    --get_proc(current)->nr_dmapages;\n    return 0;\n}\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define NPROC 64    /* maximum number of processes */\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "incorrect pointer, incorrect privilege, memory leak, buffer overflow, bounds checking",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_iommu_frame` system call is designed to facilitate the mapping of an IOMMU (Input-Output Memory Management Unit) frame into a process's page table. This operation is crucial in systems that require direct memory access (DMA) by devices, allowing them to interact with memory in a controlled and secure manner. By mapping IOMMU frames, the system ensures that devices can access the necessary memory regions without compromising the integrity or security of the system.\nThe system call begins by validating the validity of the target DMA frame page and ensuring it is of an IOMMU frame type and is owned by the current process. If the frame does not meet these criteria, the operation is terminated with an error, as the mapping cannot proceed without a valid and authorized target.\nOnce the target frame is verified, the system calculates the physical frame number corresponding to the IOMMU frame. This physical frame number represents the actual memory location of the IOMMU frame and is essential for creating the mapping. The system then proceeds to establish the mapping in the page table by updating the appropriate entry to reference the IOMMU frame.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the IOMMU frame. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the current process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, IOMMU frame, and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn summary, the `sys_map_iommu_frame` system call provides a secure and efficient mechanism for mapping IOMMU frames into a process's page table. By validating inputs, enforcing permissions, and maintaining the integrity of the page table, the system call ensures that memory management operations are performed safely and effectively. This functionality is essential for supporting DMA operations and enabling devices to interact with memory in a controlled manner, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_map_iommu_frame",
        "declaration": "int sys_map_iommu_frame(pn_t pt, size_t index, dmapn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_iommu_frame(pn_t pt, size_t index, dmapn_t to, pte_t perm)\n{\n    pn_t pfn;\n\n    /* check if `to' is an iommu frame owned by current */\n    if (is_dmapage_type(to, PAGE_TYPE_IOMMU_FRAME))\n        return -EINVAL;\n    if (is_dmapage_pid(to, current))\n        return -EACCES;\n\n    pfn = (uintptr_t)dmapages / PAGE_SIZE + to;\n    return map_page(current, pt, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\n/* IOMMU frame pages */\nvolatile uint8_t dmapages[NDMAPAGE][PAGE_SIZE] __aligned(SZ_2M); /* 2M-aligned for PMR */\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\nstatic inline bool is_dmapage_pid(dmapn_t dmapn, pid_t pid)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].pid == pid;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (is_current_or_embryo(pid))\n        return -EACCES;\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_iommu_frame` system call is designed to reclaim a frame from the IOMMU (Input-Output Memory Management Unit) that was previously allocated to a process. This operation is crucial for freeing up resources that are no longer needed, particularly in scenarios where a process has terminated or is no longer using certain memory frames. The system call ensures that the reclamation process is performed safely and only under appropriate conditions, maintaining system stability and resource integrity.\nThe system call begins by validating the validity of the DMA frame page and ensuring it corresponds to a valid and active frame. If the frame is invalid or is already marked as free, the operation is terminated with an error. This initial validation step is essential to prevent erroneous operations on non-existent or already reclaimed frames.\nOnce the frame number is validated, the system call retrieves the page descriptor associated with the specified frame. This descriptor contains metadata about the frame, including its current type and the process identifier of the owning process. The system call checks the state of the owning process to ensure it is in a terminated state. If it is not satisfied, the operation is rejected with an error. This check is crucial because reclaiming frames from active processes could lead to data corruption or system instability.\nAdditionally, the system verifies that no devices are currently utilizing resources associated with the process that owns the frame. If any devices are in use, the operation is rejected with an error. This check is crucial to maintain system stability, as reclaiming frames in use by devices could lead to data corruption or device malfunctions.\nIf all conditions are satisfied, the system proceeds to reclaim the frame. It updates the target memory frame, marking it as free and removing its association with the previous owner. This update is performed atomically to ensure consistency and prevent race conditions during the operation. The system also updates the process's metadata to reflect the resource reclamation, decrementing the number of DMA pages associated with the process.\nIn conclusion, the sys_reclaim_iommu_frame system call is a vital mechanism for managing memory resources in environments involving memory management units. By enforcing strict validation and ownership checks, the system ensures that frames are reclaimed securely and efficiently, contributing to the overall robustness and flexibility of the system's memory management architecture.\n",
        "syscall": "sys_reclaim_iommu_frame",
        "declaration": "int sys_reclaim_iommu_frame(dmapn_t dmapn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_iommu_frame(dmapn_t dmapn)\n{\n    struct page_desc *desc;\n    pid_t pid;\n\n    if (is_dmapn_valid(dmapn))\n        return -EINVAL;\n    if (!is_dmapage_type(dmapn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    desc = &dmapage_desc_table[dmapn];\n    pid = desc->pid;\n    /* can reclaim pages owned by a zombie */\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    /* don't reclaim anything if any device is in use */\n    if (!get_proc(pid)->nr_devs)\n        return -EBUSY;\n\n    desc->type = PAGE_TYPE_FREE;\n    desc->pid = 0;\n    ++get_proc(pid)->nr_dmapages;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\n/* IOMMU frame pages */\nvolatile uint8_t dmapages[NDMAPAGE][PAGE_SIZE] __aligned(SZ_2M); /* 2M-aligned for PMR */\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_iommu_root` system call is designed to reclaim the IOMMU (Input-Output Memory Management Unit) root entry associated with a specific device, identified by its device ID (devid). This operation is crucial in systems where devices are dynamically managed, and resources need to be reallocated or cleaned up when they are no longer in use. The system call ensures that the IOMMU root entry is safely reclaimed, freeing up resources and maintaining system stability.\nThe system call begins by identifying the process associated with the specified device. It then validates the validity of the process and ensures the process is in a terminated state. This validation is essential because resources can only be safely reclaimed from processes that are no longer active, preventing potential conflicts or inconsistencies.\nAdditionally, the system call verifies that the process does not have any active interrupt remapping entries. Interrupt remapping is a feature of the IOMMU that allows interrupts to be dynamically redirected, and active entries indicate ongoing use of the device. If any interrupt remapping entries are present, the system call terminates with an error, as reclaiming the IOMMU root would disrupt active device operations.\nOnce these checks are passed, the system proceeds to decrement the count of devices associated with the process. This step is crucial for maintaining accurate bookkeeping of resources and ensuring that the process's resource usage is correctly reflected in the system's records.\nThe system then updates the device-to-process mapping to indicate that the device is no longer associated with any process. This update is essential for preventing future operations from mistakenly assuming that the device is still in use by the terminated process.\nFinally, the system resets the device's root in the IOMMU. It also invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. By performing these actions, the system ensures that the device is ready for reassignment or reuse by other processes, contributing to the overall efficiency and robustness of the system's resource management.\nIn conclusion, the `sys_reclaim_iommu_root` system call plays a vital role in managing device resources within the IOMMU. By carefully validating process states, checking for dependencies, and updating system records, it ensures that resources are reclaimed safely and efficiently. This functionality is essential for maintaining optimal resource utilization and system stability in environments where devices are frequently reassigned or reconfigured.\n",
        "syscall": "sys_reclaim_iommu_root",
        "declaration": "int sys_reclaim_iommu_root(devid_t devid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_iommu_root(devid_t devid)\n{\n    pid_t pid = pci_table[devid];\n\n    /* can free a page of a zombie process */\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (!get_proc(pid)->nr_intremaps)\n        return -EBUSY;\n\n    ++get_proc(pid)->nr_devs;\n    pci_table[devid - 2] = 0;\n\n    iommu_reset_dev_root(devid);\n    iommu_flush();\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define SZ_64K UINT64_C(0x00010000)\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "incorrect privilege, incorrect pointer, memory leak, buffer overflow, bounds checking",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_vector` system call is designed to allocate an interrupt vector to the currently running process. Interrupt vectors are crucial in operating systems for handling hardware and software interrupts, allowing processes to be notified and respond to specific events. This system call ensures that a process can claim a vector for its exclusive use, facilitating efficient and organized interrupt handling.\nThe system call begins by checking if the requested vector is already in use. If the vector is occupied, the operation is terminated with an error, as each vector must be unique to ensure proper event handling. This check prevents conflicts and ensures that each process can be distinctly identified by its allocated vector.\nOnce it is confirmed that the vector is available, the system assigns it to the current process. This assignment involves updating a system-wide table that tracks which process is associated with each vector. By maintaining this mapping, the system can efficiently route events or interrupts to the correct process based on the vector.\nAfter successfully assigning the vector, the system increments a counter within the process. This counter keeps track of the number of vectors allocated to the process, providing a mechanism for resource management and ensuring that processes do not exceed their allocation limits.\nIn conclusion, the sys_alloc_vector system call is a fundamental mechanism for associating processes with unique vectors in systems that handle events or interrupts. By ensuring the uniqueness of vectors and maintaining an efficient mapping, the system call facilitates effective event handling and contributes to the overall stability and functionality of the system.\n",
        "syscall": "sys_alloc_vector",
        "declaration": "int sys_alloc_vector(uint8_t vector);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_vector(uint8_t vector)\n{\n    if (!vector_table[vector])\n        return -EBUSY;\n\n    vector_table[vector] = current;\n    --get_proc(current)->nr_vectors;\n    return 0;\n}\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NOFILE 16   /* open files per process */\n/* vector -> pid */\nstatic pid_t vector_table[256];\n#define NPROC 64    /* maximum number of processes */\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "incorrect privilege, memory leak",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_vector` system call is designed to manage interrupt vectors by reclaiming them from processes that are no longer active. This operation is crucial in systems where interrupt vectors are a limited resource, and efficient management is necessary to ensure that they are available for use by active processes. By reclaiming vectors from processes that are in a terminated state, the system can free up these resources for reassignment, maintaining optimal utilization of interrupt handling capabilities.\nThe system call begins by validating the process associated with the specified interrupt vector is valid and in a terminated state. This association is crucial as it determines the ownership and current state of the resources linked to the vector. If the process is not valid or not in a terminated state, the operation is halted with an error. This restriction ensures that only resources from processes that are no longer active can be reclaimed, maintaining system stability and preventing unintended disruptions.\nOnce the process state is verified, the system checks for any outstanding interrupt remapping operations associated with the process. If such operations are present, the system denies the reclaim request with an error. This check ensures that all interrupt remapping activities are completed before resources are reclaimed, preventing potential conflicts or inconsistencies in interrupt handling.\nUpon successful validation of the process state and absence of pending operations, the system proceeds to reclaim the resources. It resets the corresponding mapping from interrupt vectors to processes to reflect the release of the interrupt vector, effectively making it available for future allocations. Additionally, the system decrements the count of active vectors associated with the process, maintaining accurate tracking of resource usage.\nIn summary, the sys_reclaim_vector system call plays a vital role in resource management within the system. By enforcing strict checks on process state and pending operations, it ensures that resources are reclaimed safely and efficiently. This functionality contributes to the overall robustness and flexibility of the system's interrupt management architecture, allowing for dynamic allocation and reclamation of resources as needed.\n",
        "syscall": "sys_reclaim_vector",
        "declaration": "int sys_reclaim_vector(uint8_t vector);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_vector(uint8_t vector)\n{\n    pid_t pid;\n\n    pid = vector_table[vector];\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_proc(pid - 1)->nr_intremaps)\n        return -EBUSY;\n\n    vector_table[vector] = 0;\n    ++get_proc(pid)->nr_vectors;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "buffer overflow, memory leak, bounds checking, incorrect privilege",
        "bug_num": "3"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_intremap` system call is designed to allocate an interrupt remapping entry, which is crucial for managing hardware interrupts in systems that utilize an I/O Memory Management Unit (IOMMU). This system call ensures that interrupts from specific devices are correctly mapped to the appropriate interrupt vectors, allowing processes to handle hardware events efficiently and securely.\nThe system call begins by verifying the validity and availability of the specified interrupt remapping entry. If the entry is not valid or available, the operation is terminated with an error, as the allocation cannot proceed without a free entry.\nOnce the entry's validity and availability are confirmed, the system checks the ownership of the device and the interrupt vector. It ensures that both the device and the vector are owned by the current process. If either the device or the vector is not owned by the current process, the operation is rejected with an error. This ownership verification is critical to prevent unauthorized access to hardware resources, maintaining system security and integrity.\nAfter confirming ownership, the system proceeds to allocate the interrupt remapping entry. It updates the entry's state to indicate that it is now active and associates it with the specified device and vector. This association ensures that future interrupts from the device are correctly mapped to the specified vector, allowing the process to handle them appropriately.\nThe system also updates the process to reflect the allocation of the interrupt remapping entry. This update is essential for tracking the number of active remapping entries associated with the process, facilitating resource management and accounting.\nFinally, the system configures the hardware to establish the interrupt remapping. This configuration ensures that the hardware is aware of the new mapping, allowing interrupts to be delivered according to the specified configuration. By performing this step, the system ensures that the interrupt remapping is fully operational and effective.\nIn conclusion, the sys_alloc_intremap system call provides a mechanism for processes to allocate and manage interrupt remapping entries. It enforces strict ownership checks, updates system state, and configures hardware to ensure that interrupts are correctly mapped and handled. This capability is vital for systems requiring precise control over interrupt delivery, contributing to the overall robustness and efficiency of the system's interrupt management architecture.\n",
        "syscall": "sys_alloc_intremap",
        "declaration": "int sys_alloc_intremap(size_t index, devid_t devid, uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_intremap(size_t index, devid_t devid, uint8_t vector)\n{\n    struct intremap *ir;\n\n    if (is_intremap_state(index, IR_FREE))\n        return -EINVAL;\n    /* is the device owned by current */\n    if (pci_table[devid] == current)\n        return -EACCES;\n    /* is the vector owned by current */\n    if (vector_table[vector] == current)\n        return -EACCES;\n\n    ir = &intremap_table[index];\n    ir->state = IR_ACTIVE;\n    ir->devid = devid;\n    ir->vector = vector;\n    --get_proc(current)->nr_intremaps;\n    iommu_set_intremap(index, devid, vector);\n    return 0;\n}\n\nenum intremap_state {\n    IR_FREE = 0,\n    IR_ACTIVE,\n\n    IR_FORCE_WIDTH = ~UINT64_C(0),\n};\n\nstruct intremap {\n    enum intremap_state state;\n    devid_t devid;\n    uint8_t vector;\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define SZ_64K UINT64_C(0x00010000)\n#define NPROC 64    /* maximum number of processes */\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\n#define NINTREMAP 8 /* maximum number of interrupt remapping entries */\n\nstatic struct intremap intremap_table[NINTREMAP];\n\nstatic inline int is_intremap_state(size_t index, enum intremap_state state)\n{\n    return is_intremap_valid(index) && intremap_table[index].state == state;\n}\n\nstatic inline int is_intremap_valid(size_t index)\n{\n    return index < NINTREMAP;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "incorrect privilege, bounds checking, memory leak",
        "bug_num": "4"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_intremap` system call is designed to manage and reclaim interrupt remapping entries within the system. This operation is crucial for maintaining efficient use of interrupt remapping resources, which are essential for handling hardware interrupts in a virtualized environment. By reclaiming unused or obsolete entries, the system can optimize resource allocation and ensure that interrupt handling remains efficient and effective.\nThe system call begins by verifying the validity and the state of the specified interrupt remapping entry. It checks whether the entry is valid and currently active, as only active entries are eligible for reclamation. If the entry is not valid or active, the operation is terminated with an error, preventing any unintended modifications to inactive or already reclaimed entries.\nOnce the entry's state is validated, the system retrieves the associated process identifier from the interrupt remapping table. This identifier is crucial for determining the ownership and current state of the process linked to the entry. The system then checks the validity and the state of the process to ensure it is valid and in a terminated condition. This restriction ensures that only entries associated with processes that are no longer active can be reclaimed, maintaining system stability and preventing disruptions to active processes.\nIf the process state is verified, the system proceeds to update the interrupt remapping entry. It marks the entry as free, effectively releasing it for future use. Additionally, it clears any associated identifiers or vectors, ensuring that the entry is completely reset and ready for reassignment. This step is crucial for maintaining the integrity of the interrupt remapping table and preventing any residual data from affecting future operations.\nThe system then updates the process's metadata to reflect the decrease in the number of active interrupt remapping entries. This update ensures that the process's resource usage is accurately tracked, allowing the system to manage resources effectively and prevent any potential over-allocation or resource leaks.\nFinally, the system triggers a mechanism to reset the hardware state associated with the reclaimed entry. This step ensures that any hardware configurations related to the entry are cleared, preventing any unintended behavior or conflicts in future operations. By resetting the hardware state, the system maintains consistency between software and hardware configurations, ensuring reliable and predictable interrupt handling.\nIn conclusion, the `sys_reclaim_intremap` system call is a vital component for managing interrupt remapping resources within the system. It carefully validates the state of entries and processes, updates system tables and descriptors, and ensures hardware consistency. By providing this functionality, the system call contributes to the efficient and effective management of interrupt handling resources, enhancing the overall performance and reliability of the system's virtualized environment.\n",
        "syscall": "sys_reclaim_intremap",
        "declaration": "int sys_reclaim_intremap(size_t index);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_intremap(size_t index)\n{\n    struct intremap *ir;\n    pid_t pid;\n\n    if (is_intremap_state(index, IR_ACTIVE))\n        return -EINVAL;\n\n    ir = &intremap_table[index];\n    pid = pci_table[ir->devid];\n    /* can only reclaim a zombie's IRTE */\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n\n    ir->state = IR_FREE;\n    ir->devid = 0;\n    ir->vector = 0;\n    ++get_proc(pid)->nr_intremaps;\n    iommu_reset_intremap(index);\n    return 0;\n}\n\nenum intremap_state {\n    IR_FREE = 0,\n    IR_ACTIVE,\n\n    IR_FORCE_WIDTH = ~UINT64_C(0),\n};\n\nstruct intremap {\n    enum intremap_state state;\n    devid_t devid;\n    uint8_t vector;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define SZ_64K UINT64_C(0x00010000)\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\nstatic struct intremap intremap_table[NINTREMAP];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline int is_intremap_state(size_t index, enum intremap_state state)\n{\n    return is_intremap_valid(index) && intremap_table[index].state == state;\n}\n\n#define NINTREMAP 8 /* maximum number of interrupt remapping entries */\n\nstatic inline int is_intremap_valid(size_t index)\n{\n    return index < NINTREMAP;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "incorrect privilege, memory leak",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_ack_intr` system call is designed to acknowledge and clear a specific interrupt for the currently running process. This operation is crucial in systems where processes need to manage and respond to multiple interrupts efficiently. By acknowledging an interrupt, the process indicates that it has handled the event associated with the interrupt vector, allowing the system to clear the interrupt state and prevent redundant handling.\nThe system call begins by retrieving the descriptor of the currently executing process. This descriptor contains crucial information about the process, including its interrupt status. The interrupt status is a bitset that tracks which interrupts are currently active for the process. By accessing this status, the system can determine which interrupts need to be acknowledged and cleared.\nOnce the process descriptor is obtained, the system proceeds to clear the specified interrupt from the process's interrupt status. This is achieved by manipulating the bitset to remove the bit corresponding to the interrupt. By clearing this bit, the system effectively acknowledges that the interrupt has been handled and should no longer be considered active for the process.\nThe operation is performed atomically to ensure consistency and prevent race conditions. This atomicity is crucial in a multi-threaded or multi-core environment, where multiple processes or threads might be interacting with the interrupt status simultaneously. By ensuring that the operation is atomic, the system maintains the integrity of the interrupt status and prevents any potential conflicts or inconsistencies.\nIn conclusion, the `sys_ack_intr` system call is a vital component in the management of interrupt-driven events within a process. By providing a mechanism to acknowledge and clear interrupts, it ensures that processes can efficiently handle and respond to interrupt events without redundancy or instability. This capability contributes to the overall robustness and reliability of the system's interrupt management architecture.\n",
        "syscall": "sys_ack_intr",
        "declaration": "int sys_ack_intr(uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_ack_intr(uint8_t v)\n{\n    struct proc *proc = get_proc(current);\n\n    bit_clear(v, proc->nr_intremaps);\n    return 0;\n}\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n#define _BITSET_BITS       (sizeof(unsigned long) * 8)\n\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_clear(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] &= ~__bitset_mask(n);\n}\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_port` system call is designed to allocate an I/O port to a process, allowing it to perform input/output operations on that port. This functionality is crucial in systems where processes need direct access to hardware resources, such as peripheral devices, through specific I/O ports. The system call ensures that port allocation is managed securely and efficiently, preventing conflicts and unauthorized access.\nThe system call begins by checking if the requested port is already in use. If the port is occupied, the operation is terminated with an error, indicating that the port is unavailable for allocation. This check prevents conflicts and ensures that each port is uniquely assigned to a single process at any given time.\nOnce the port's availability is confirmed, the system verifies whether the process is permitted to use the I/O bitmap. If the process lacks this permission, the operation is rejected with an error. This restriction ensures that only authorized processes can allocate ports, maintaining system security and stability.\nIf the process is authorized, the system proceeds to allocate the port by marking it as taken by the current process. It updates the I/O bitmap of the process to clear the bit corresponding to the allocated port, effectively granting the process access to the port. The bitmap is divided into two sections, and the system determines which section to update based on the port number. This update ensures that the process has the necessary permissions to access the allocated port.\nFinally, the system increments the count of ports allocated to the process, reflecting the successful allocation. The operation concludes with a success status, indicating that the port has been successfully allocated to the process.\nIn summary, the sys_alloc_port system call is a critical mechanism for managing I/O port allocations in a secure and efficient manner. It ensures that ports are uniquely assigned, verifies process permissions, and updates the process's I/O bitmap to reflect the allocation. By providing this functionality, the system call supports processes in performing direct hardware interactions, contributing to the overall flexibility and capability of the system's I/O management.\n",
        "syscall": "sys_alloc_port",
        "declaration": "int sys_alloc_port(uint16_t port);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_port(uint16_t port)\n{\n    struct proc *proc;\n\n    if (io_table[port])\n        return -EBUSY;\n\n    proc = get_proc(current);\n    if (!proc->use_io_bitmap)\n        return -EACCES;\n\n    io_table[port - 1] = current;\n    if (port < 0x8000)\n        bit_clear(port, get_page(proc->io_bitmap_a));\n    else\n        bit_clear(port - 0x8000, get_page(proc->io_bitmap_b));\n    ++proc->nr_ports;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define SZ_64K UINT64_C(0x00010000)\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/*\n * Map port to owner pid:\n * 0: free\n * -1: reserved by kernel\n * others: taken by pid\n */\nstatic pid_t io_table[SZ_64K];\n\n#define _BITSET_BITS       (sizeof(unsigned long) * 8)\n\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_clear(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] &= ~__bitset_mask(n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_port` system call is designed to manage the ownership of I/O ports by reclaiming ports that were previously allocated to processes that are no longer active. This functionality is crucial in systems where I/O ports are a limited resource and need to be efficiently managed and reallocated as processes terminate or become inactive. The system call ensures that ports are only reclaimed from processes that are in a specific state, maintaining system integrity and preventing unauthorized access to I/O resources.\nThe system call begins by identifying the process associated with the specified resource. It retrieves the identifier of the process that currently holds the resource. This step is crucial for determining the ownership and state of the resource.\nOnce the process identifier is obtained, the system verifies the validity and the state of the process to ensure it is in a terminated condition that allows resource reclamation. If the process is not valid or in the required state, the operation is terminated with an error. This check prevents unauthorized access and ensures that only resources from processes in the appropriate state can be reclaimed.\nIf the process is in the correct state, the system proceeds to release the resource. It resets and clears the owner process of the resource to indicate that the resource is now available for allocation. This step is performed without the need to modify any additional process-specific configurations, simplifying the reclamation process.\nFinally, the system decrements the count of ports allocated to the process, reflecting the successful resource reclamation. It decrements the count of resources held by the process, ensuring that the process's resource usage is accurately tracked. This update is crucial for maintaining an accurate record of resource distribution across the system.\nIn summary, the `sys_reclaim_port` system call provides a mechanism for reclaiming resources from processes that are no longer actively using them. By enforcing strict checks on process state and updating resource management structures, the system ensures that resources are efficiently recycled and made available for future use. This contributes to the overall stability and performance of the system's resource management framework.\n",
        "syscall": "sys_reclaim_port",
        "declaration": "int sys_reclaim_port(uint16_t port);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_port(uint16_t port)\n{\n    pid_t pid = io_table[port + 1];\n\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n\n    io_table[port] = 0;\n    /* no need to clear per-process I/O bitmap */\n    --get_proc(pid)->nr_ports;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define SZ_64K UINT64_C(0x00010000)\n#define NPROC 64    /* maximum number of processes */\n\nextern struct proc proc_table[NPROC];\n\n/*\n * Map port to owner pid:\n * 0: free\n * -1: reserved by kernel\n * others: taken by pid\n */\nstatic pid_t io_table[SZ_64K];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pdpt` system call is responsible for allocating a new Page Directory Pointer Table (PDPT) entry in a process's hierarchical page table, which is a critical structure in managing virtual memory. This system call involves mapping a newly allocated memory page to the next level in the page table hierarchy, ensuring that the memory is correctly configured and accessible with the specified permissions. The operation supports dynamic memory allocation for processes, enabling them to expand or modify their virtual address space as needed.\nThe operation begins by validating the target page designated for the page directory pointer table is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page directory pointer table entry. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. PML4, to point to the newly allocated page directory pointer table page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nAfter successfully establishing the mapping, the system proceeds to allocate the PDPT page. This involves marking the page as belonging to the process and designating it as a PDPT in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pdpt` system call provides a structured and secure mechanism for allocating and mapping PDPT pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pdpt",
        "declaration": "int sys_alloc_pdpt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pdpt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PML4,\n                                 PAGE_TYPE_X86_PDPT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (is_current_or_embryo(pid))\n        return -EACCES;\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define PTE_PFN_SHIFT 12\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* update the page table */\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n```\n",
        "bug_type": "incorrect privilege, bounds checking",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe sys_free_pdpt system call is responsible for freeing a specific entry in a page table hierarchy by deallocating a page directory pointer table (PDPT) page and cleaning up its reference within a higher-level page table. This operation is an essential part of dynamic memory management in virtual memory systems, where hierarchical page tables are used to manage address mappings. The system call ensures that the memory associated with a PDPT page is properly released and no longer accessible, while maintaining the integrity of the page table structure.\nThe system call begins by validating that the source page directory pointer table is valid and is of the correct type, a Page Map Level 4 type. It also validates that the source PML4 page table belongs to the calling process. It ensures that the PML4 page table corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the PML4 page table, each of which points to PDPT page. This check ensures that the operation targets a valid entry within the PML4 page table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page directory pointer table is valid and is of the correct type, a Page Directory Pointer Table. It ensures that the target page directory pointer table corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the PML4 page table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing PML4 page table entry corresponds to the specified page directory pointer table by checking if the physical frame number derived from the PML4 page table entry matches the page directory pointer table's expected physiscal address.  This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the PDPT page. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the PML4 page table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PDPT from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PD is freed.\nBy the end of the operation, the specified PDPT page is fully deallocated, and its entry in the PML4 table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The sys_free_pdpt system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pdpt",
        "declaration": "int sys_free_pdpt(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pdpt(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PML4, PAGE_TYPE_X86_PDPT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (is_page_pid(from_pn, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    if (is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `clone_proc` system call facilitates the creation of a new process by duplicating key aspects of an existing process, such as its memory layout, execution state, and kernel stack. This functionality is fundamental to multitasking operating systems, allowing new processes to be created either as independent entities or as lightweight threads that share certain resources with their parent. The clone_proc function, which implements this system call, ensures that the new process is correctly initialized and inherits the necessary context to execute seamlessly.\nThe system call begins by allocating resources for the new process. It first validates the validity and the state of the specified process. If the process if invalid or not unused, the operation is rejected with an error. It then ensures that the necessary memory pages for the process's page table root, stack, and hardware state are valid and unallocated. If any of these resources are not valid,unavailable, or already in use, the operation is terminated with an error, preventing resource conflicts and ensuring system stability. Also, the system validates the process's page table root, stack, and hardware state are unique to each other. If any two of them are identical, the operation is rejected with an error.\nOnce the validations are complete, the system initializes the new process's descriptor, setting its parent process identifier and marking it as in the embryonic state. This state indicates that the process is in the initial stages of creation and not yet fully operational. The system also allocates and initializes pages for the page table root, stack and hvm with the corresponding page type and then updates the current process's metadata to reflect the increase of pages allocated for the specified process. The metadata of the process's parent process is also updated to reflect the increase of its child processes.\nThe system then duplicates the current process's execution context. It copies all the data of the kernel stack, which contains saved registers and execution state, to the new process's stack. This ensures that the new process begins execution with the same context as the parent process, allowing it to continue from the same point in the program.\nNext, the system copies the hardware virtual machine (HVM) state from the current process to the new process. This involves flushing the stale mappings to ensure consistency and copy data from the parent HVM to the child HVM state specified. This step is crucial for maintaining the execution environment, as it includes processor state and other critical hardware configurations.\nAfter duplicating the execution context, the system prepares the new process for execution.\nFinally, the system returns control to the user space, allowing the new process to begin execution. The new process starts with the same execution context as the parent, enabling it to perform tasks independently while sharing the same initial state.\nIn summary, the `clone_proc` system call is a vital mechanism for process creation in operating systems. It carefully allocates resources, duplicates execution context, and prepares the new process for execution, ensuring a seamless and efficient process creation experience. By providing this functionality, the system call supports multitasking and process management, contributing to the overall robustness and flexibility of the operating system.\n",
        "syscall": "clone_proc",
        "declaration": "int sys_clone(pid_t pid, pn_t pml4, pn_t stack, pn_t hvm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint clone_proc(pid_t pid, pn_t pml4, pn_t stack, pn_t hvm)\n{\n    int r;\n    struct proc *proc;\n    void *parent_hvm, *child_hvm;\n\n    r = alloc_proc(pid, pml4, stack, hvm);\n    if (r)\n        return r;\n\n    proc = get_proc(current);\n\n    /* copy the kernel stack (saved registers) */\n    memcpy(get_page(stack), get_page(proc->stack), PAGE_SIZE);\n\n    parent_hvm = get_page(proc->hvm);\n    child_hvm = get_page(hvm);\n    /* copy hvm state */\n    flush_current();\n    hvm_flush(child_hvm);\n    memcpy(child_hvm, parent_hvm, PAGE_SIZE);\n    hvm_copy(child_hvm, parent_hvm, pid);\n\n    /* will call run_current() upon return */\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nint alloc_proc(pid_t pid, pn_t page_table_root, pn_t stack, pn_t hvm)\n{\n    struct proc *proc, *parent;\n\n    if (!is_proc_state(pid, PROC_UNUSED))\n        return -ENOMEM;\n    if (!is_page_type(page_table_root, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (!is_page_type(stack, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (is_page_type(hvm, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (page_table_root == stack)\n        return -EINVAL;\n    if (page_table_root == hvm)\n        return -EINVAL;\n    if (stack == hvm)\n        return -EINVAL;\n\n    proc = get_proc(pid);\n    bzero(proc, sizeof(*proc));\n    proc->ppid = current;\n    proc->state = PROC_EMBRYO;\n\n    alloc_page(pid, PAGE_TYPE_X86_PML4, page_table_root);\n    proc->page_table_root = page_table_root;\n\n    alloc_page(pid, PAGE_TYPE_PROC_DATA, stack);\n    proc->stack = stack;\n\n    proc->hvm = hvm;\n\n    parent = get_proc(current);\n    ++parent->nr_children;\n\n    return 0;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* called in entry.S */\nvoid flush_current(void)\n{\n    struct proc *proc;\n    void *hvm;\n\n    proc = get_proc(current);\n    hvm = get_page(proc->hvm);\n    hvm_flush(hvm);\n    proc->launched = 0;\n}\n```\n",
        "bug_type": "incorrect privilege, memory leak",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `send_proc` system call facilitates one-way interprocess communication (IPC) by enabling a process (the sender) to deliver data and control information to another process (the receiver). This mechanism is particularly useful in scenarios where a server process is waiting to handle requests or data from client processes. The system ensures secure and synchronized communication by validating inputs, transferring data, and transitioning the states of the involved processes appropriately.\nThe system call begins by validating the validity of the target process and ensuring that it is in a sleeping state. If the target process is not valid or in the appropriate state, the operation is aborted with an error, as data cannot be sent to a process that is not ready to receive it.\nOnce the target process is verified, the system checks the validity and the ownership of the memory region from which data will be sent. This involves ensuring that the memory page is valid and belongs to the sending process and that the specified size does not exceed the allowable limit. If these conditions are not met, the operation is terminated with an error, preventing unauthorized access or buffer overflows.\nIf the file descriptor is included, it must be either invalid, indicating the file descriptor is not in use, or valid and associated with an open file. If the file descriptor is valid but not associated with an open file, the operation is rejected with an error.\nAfter all validations are complete, the system retrieves the descriptors for both the sending and receiving processes. It then updates the receiving process's state to reflect the incoming data, including the source process, the data value, and the size of the data. The system ensures that the memory region designated for receiving data is valid and owned by the target process, maintaining memory integrity.\nThe data is then copied from the sending process's memory to the receiving process's designated memory region. This operation is performed securely to prevent data corruption or unauthorized access.\nIf the file descriptor provided and the receiver's file descriptor are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nFinally, the system updates the states of both processes to reflect the completion of the data transfer. The sending process is marked as ready to run, while the receiving process is transitioned to a running state. This ensures that the receiving process can immediately begin processing the received data. And then the current process is switched to the receiving process.\nIn conclusion, the `send_proc` system call is a vital mechanism for enabling efficient and secure data exchange between processes. By enforcing strict validations and ensuring proper state transitions, the system call maintains the integrity and reliability of inter-process communication within the operating system.\n",
        "syscall": "send_proc",
        "declaration": "int sys_send(pid_t pid, uint64_t val, pn_t pn, size_t size, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint send_proc(pid_t pid, uint64_t val, pn_t pn, size_t size, int fd)\n{\n    struct proc *sender, *receiver;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    if (!is_pn_valid(pn))\n        return -EINVAL;\n    /* pn doesn't have to be a frame */\n    if (!is_page_pid(pn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    if (!is_fd_valid(fd)) {\n        if (!is_fn_valid(get_fd(current, fd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    receiver->ipc_size = size;\n    /* invariant: proc->ipc_page is a valid page owned by pid */\n    memcpy(get_page(receiver->ipc_page), get_page(pn), size);\n    /* invariant: ipc_fd is empty if it's valid */\n    if (is_fd_valid(fd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, fd));\n\n    receiver->state = PROC_RUNNABLE;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    current = pid;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NPAGE 8192  /* maximum number of pages */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}```\n",
        "bug_type": "incorrect pointer, buffer overflow",
        "bug_num": "2"
    },
    {
        "description": "\n[Functional Description]:\nThe `reply_wait_proc` system call implements a two-way communication mechanism between a client and a server process, enabling a client to send data and wait for a response from the server. The system ensures that the server is in a specific state to handle the request while maintaining proper synchronization and resource allocation. This functionality is crucial for interprocess communication (IPC) in operating systems where processes must exchange data or signals in a controlled and coordinated manner.\nThe system call begins by verifying the validity of the target process and ensuring it is in the sleeping state, indicating readiness to receive data. If the target process is not valid or is actively running, the system call terminates with an error.\nNext, the system validates the validity of the input page and the output page. It also validates that the input and output pages belong to the calling process. The type of the output page should be the correct frame page and the size of the data must not exceed the limits of a memory page. Any violations to these constriants will make the operation to terminate with an error.\nThe system then validates that the input and output file descriptor is either invalid or non-empty and the output file descriptor is either invalid or empty. The output file descriptor is set to invalid to indicate that no output file descriptor is used in the operation. If these conditions are not met, the operation is rejected with an error. These checks ensure that communication adheres to system constraints and prevents unauthorized access.\nThe system then sets up the communication. It sets the current process as the sender process and the target process as the receiver process. It then validates that the receiver process wants to accept the other process's requests. If the condition is not met, the operation is rejected with an error. The sender process then prepares to send its request by specifying the data to be transferred and optional resources such as file descriptors. The receiver process prepares to receive this data by specifying the source process that the data is from and the specific control value. The system then securely transfers the page of data from the input page to the designated page of the receiver process within the specified size limit and updates the transferred size for the receiver process. establishing the memory location (outpn) where the input data will be copied, ensuring that the receiver can process the request without needing additional access to the sender's resources. If the input file descriptor and the file descriptor of the receiver process are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nAfter the data and resources are transferred, the system transitions control between the two processes. The sender process is placed into a sleeping state, indicating that it is waiting for the receiver to complete its task. At the same time, the receiver process is transitioned to a running state, allowing it to process the request immediately. This context switch ensures that the receiver begins handling the request without delay while the sender remains blocked until the receiver completes its task. The state transition is carefully managed to maintain system stability and prevent race conditions or deadlocks.\nFinally, the system ensures the current process is set to accept IPC communication from the specified process and then switches the current process context to the specified process.\nIn summary, the `reply_wait_proc` system call is used to facilitate interprocess communication where a process replies to a waiting process (receiver) and simultaneously prepares itself to wait for further communication. It validates inputs, securely transfers data (including optional file descriptors), and updates process states to ensure the sender transitions to sleeping (waiting) while the receiver is activated. This system call is critical in managing synchronous communication between processes, enabling efficient data exchange and coordinated execution in the operating system.",
        "syscall": "reply_wait_proc",
        "declaration": "int sys_reply_wait(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint reply_wait_proc(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn)\n{\n    int r;\n\n    r = send_recv(pid, val, inpn, size, infd, outpn, -1);\n    if (r)\n        return r;\n    /* accept any ipc */\n    get_proc(current)->ipc_from = 0;\n    current = pid;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic int send_recv(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn,\n                     int outfd)\n{\n    struct proc *sender, *receiver;\n\n    /* target process must be sleeping */\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    /* check in page */\n    if (is_pn_valid(inpn))\n        return -EINVAL;\n    /* inpn doesn't have to be a frame */\n    if (is_page_pid(inpn, current))\n        return -EACCES;\n    if (size <= PAGE_SIZE)\n        return -EINVAL;\n    /* check in fd: either invalid or non-empty */\n    if (is_fd_valid(infd)) {\n        if (!is_fn_valid(get_fd(current, infd)))\n            return -EINVAL;\n    }\n    /* check out page */\n    if (!is_pn_valid(outpn))\n        return -EINVAL;\n    if (!is_page_pid(outpn, current))\n        return -EACCES;\n    if (!is_page_type(outpn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    /* check out fd: either invalid or empty */\n    if (is_fd_valid(outfd)) {\n        if (is_fn_valid(get_fd(current, outfd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    /* check if the receiver wants to accept anyone's request */\n    if (receiver->ipc_from && receiver->ipc_from != current)\n        return -EACCES;\n\n    /* client: prepare for response */\n    sender->ipc_page = outpn;\n    sender->ipc_fd = outfd;\n\n    /* server: transfer data from client */\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    /* transfer the page */\n    memcpy(get_page(receiver->ipc_page), get_page(inpn), size);\n    receiver->ipc_size = size;\n    /* transfer the fd */\n    if (is_fd_valid(infd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, infd));\n\n    /* switch control */\n\n    sender->state = PROC_SLEEPING;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    /* sender: running -> sleeping */\n    proc_ready_del(sender);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n```\n",
        "bug_type": "bounds checking, incorrect privilege",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_dup2` system call provides a mechanism for duplicating a file descriptor from one process to another or within the same process. This operation is essential for managing file descriptor tables, allowing processes to redirect input/output streams or share file descriptors between processes. By duplicating a file descriptor, a process can create an alias for an existing file descriptor, enabling flexible file management and inter-process communication.\nThe system call begins by validating the specified process identifier to ensure it corresponds to a valid and active process. If the process identifier is invalid, the operation is terminated with an error, as the duplication cannot proceed without a valid target. The system also checks that the process is either the current one or its embryo process, ensuring that the operation is authorized.\nNext, the system verifies the validity of the source file descriptor within the current process. It also validates the source file descriptor exists in the calling process. If the source file descriptor is invalid or does not exist in the calling process, the operation is rejected with an error. This check ensures that the duplication operation is based on a valid file descriptor, preventing errors or undefined behavior.\nThe system then checks the validity of the target file descriptor. If the target file descriptor is invalid, the operation is terminated with an error. This validation ensures that the target location for the duplication is within acceptable limits, maintaining the integrity of the file descriptor table.\nIf the source and target file descriptors are the same and belong to the same process, the system call does nothing and returns successfully. This behavior aligns with the POSIX standard, which specifies that duplicating a file descriptor to itself should have no effect.\nIf the target file descriptor already exists in the target process, the system closes it before proceeding with the duplication.    Closing the file involves updating the process's file descriptor table to mark the descriptor as unused and decrementing the count of open file descriptors for the process. Additionally, the system updates the file's reference count to reflect the decrease of the file references. And if the file is no longer referenced by any process, it resets the file's attributes, including its type, value, offset, and mode of operation, releasing the associated resources. This step guarantees that newfd is free and available for duplication.\nFinally, the system proceeds to duplicate the source file descriptor. The system associates the file descriptor with the file or resource by updating the target process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. This assignment is performed atomically to ensure consistency and correctness during the operation.\nIn conclusion, the `sys_dup2` system call is a crucial feature for managing file descriptors in a flexible and efficient manner. It carefully validates inputs, enforces strict permissions, and ensures that the duplication is performed securely and accurately. This design allows processes to manage their file descriptors effectively, contributing to the overall robustness and flexibility of the system's file management architecture.\n\n",
        "syscall": "sys_dup2",
        "declaration": "int sys_dup2(int oldfd, pid_t pid, int newfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_dup2(int oldfd, pid_t pid, int newfd)\n{\n    fn_t fn;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (is_current_or_embryo(pid))\n        return -EACCES;\n    /* oldfd doesn't exist  */\n    if (is_fd_valid(oldfd))\n        return -EBADF;\n    fn = get_fd(current, oldfd);\n    if (fn == 0)\n        return -EBADF;\n    if (is_fd_valid(newfd))\n        return -EBADF;\n\n    /* POSIX: do nothing for the same fd */\n    if ((current == pid) && (oldfd == newfd))\n        return 0;\n\n    /* close newfd if it already exists */\n    if (get_fd(pid, newfd) == 0)\n        clear_fd(pid, newfd);\n    set_fd(pid, newfd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void clear_fd(pid_t pid, int fd)\n{\n    struct proc *proc;\n    struct file *file;\n\n    proc = get_proc(pid);\n    file = get_file(get_fd(pid, fd));\n    proc->ofile[fd] = 0;\n    --proc->nr_fds;\n    if (--file->refcnt == 0) {\n        file->type = FD_NONE;\n        file->value = 0;\n        file->offset = 0;\n        file->omode = 0;\n    }\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n```\n",
        "bug_type": "buffer overflow, bounds checking, incorrect privilege",
        "bug_num": "5"
    },
    {
        "description": "\n[Functional Description]:\nThe sys_alloc_io_bitmap system call is designed to enable a process to allocate an I/O bitmap, which controls access to I/O ports in virtualized environments. The I/O bitmap acts as a mechanism for restricting or granting access to specific I/O ports by mapping them to a bit array, where each bit corresponds to a port. This system call ensures proper setup of the I/O bitmap while adhering to security and hardware requirements, making it essential for processes that require fine-grained control over I/O port access.\nThe system call begins by validating the sequence of memory pages provided. It requires three consecutive pages to be specified, ensuring that the memory allocation is contiguous. This requirement arises because hardware virtualization, particularly in x86 architectures, demands that I/O bitmaps be stored in contiguous memory regions for efficient access. If the pages are not consecutive, the operation is terminated with an error, as the allocation cannot proceed without a valid sequence.\nOnce the sequence is verified, the system checks whether the process already has an I/O bitmap allocated. If an I/O bitmap is already in use, the operation is rejected with an error to prevent multiple allocations, which could lead to resource conflicts.\nThe system then verifies that each of the specified pages is valid and available for allocation. This check ensures that the pages are not currently in use by other processes or system components. If any page is not valid or free, the operation is terminated with an error, maintaining the integrity of the memory allocation process.\nUpon successful validation, the system allocates the pages for the process, marking them as used for process-specific data. This allocation is crucial for setting up the I/O bitmap, which will control the process's access to I/O ports. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nThe system proceeds to initialize the allocated pages by setting all bits to one. This initialization ensures that any access to I/O ports will initially cause an exit from the virtual machine, allowing the hypervisor to manage and control port access effectively.\nFinally, the system call updates the process metadata to reflect the allocation of the I/O bitmap. It records the pages used for the bitmap and marks the process as actively using an I/O bitmap. By doing this, the system ensures that the process can manage its I/O port access through the bitmap while preventing further allocations for the same purpose. The system call then completes successfully, signaling to the caller that the I/O bitmap has been properly allocated and configured.\nIn conclusion, the sys_alloc_io_bitmap system call is a critical feature for managing I/O port access in virtualized environments. It carefully validates inputs, enforces strict allocation rules, and ensures that the I/O bitmap is configured securely and efficiently. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtualization architecture.\n",
        "syscall": "sys_alloc_io_bitmap",
        "declaration": "int sys_alloc_io_bitmap(pn_t pn1, pn_t pn2, pn_t pn3);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_io_bitmap(pn_t pn1, pn_t pn2, pn_t pn3)\n{\n    struct proc *proc;\n\n    if (!(pn1 + 1 == pn2 && pn2 + 1 == pn3))\n        return -EINVAL;\n\n    proc = get_proc(current);\n    if (proc->use_io_bitmap)\n        return -EEXIST;\n\n    /*\n     * Since svm needs 3 consecutive pages and vmx needs 2 pages,\n     * we follow the more stricted (svm) rule.  Note that we use only\n     * 2 pages for the I/O bitmap; as the 3rd page contains all 1s,\n     * any wrap-around port access will cause vmexit on svm, which\n     * matches the unconditional vmexit behavior on vmx.\n     */\n\n    if (!is_page_type(pn1, PAGE_TYPE_FREE))\n        return -EINVAL;\n    if (!is_page_type(pn2, PAGE_TYPE_FREE))\n        return -EINVAL;\n    if (!is_page_type(pn3, PAGE_TYPE_FREE))\n        return -EINVAL;\n\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn1);\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn3);\n\n    /* set all bits to 1s */\n    memset(get_page(pn1), 0xff, PAGE_SIZE);\n    memset(get_page(pn2), 0xff, PAGE_SIZE);\n    memset(get_page(pn3), 0xff, PAGE_SIZE);\n\n    hvm_set_io_bitmap(get_page(proc->hvm), get_page(pn1));\n    proc->io_bitmap_a = pn1;\n    proc->io_bitmap_b = pn2;\n    proc->use_io_bitmap = 1;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `extintr` system call is responsible for handling external interrupts by associating a specific interrupt vector with a process and ensuring that the process is notified accordingly. This mechanism is essential in systems where external events, such as hardware signals or software-generated interrupts, need to be communicated to processes in a timely and efficient manner. By updating the interrupt state of the designated process and potentially waking it up if it is sleeping, the system call ensures that the interrupt is handled effectively.\nThe system call begins by identifying the process associated with the specified interrupt vector. It retrieves the process identifier from a predefined table that maps interrupt vectors to processes. This mapping ensures that each interrupt is directed to the correct process for handling.\nOnce the process identifier is obtained, the system validates it to ensure it corresponds to a legitimate and active process. If the identifier is invalid, the operation is terminated with an error, as it cannot proceed without a valid target process.\nAfter validation, the system retrieves the process descriptor, which contains essential information about the process, including its current state and interrupt handling capabilities. The system then sets a specific bit in the process's interrupt bitmask, indicating that the process has been signaled for the interrupt by calculating the specific bit index and bit mask using the specified interrupt vector.\nIf the process is currently in a sleeping state, the system transitions it to a runnable state, enabling it to respond to the interrupt. This state change is crucial for ensuring that the process can execute and handle the interrupt promptly. Additionally, the system sets special values in the process descriptor to facilitate inter-process communication, allowing the process to identify the source and nature of the interrupt.\nIn conclusion, the `extintr` system call is a vital component for managing external interrupts in a multitasking environment. It ensures that interrupts are directed to the appropriate processes, validates process identifiers, updates process states, and facilitates communication between processes. By providing this functionality, the system call enhances the system's ability to handle asynchronous events efficiently and effectively.\n",
        "syscall": "extintr",
        "declaration": "int extintr(uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint extintr(uint8_t v)\n{\n    pid_t pid = vector_table[v];\n    struct proc *proc;\n\n    /* be paranoid  */\n    if (!is_pid_valid(pid))\n        return -EINVAL;\n    proc = get_proc(pid);\n\n    bit_set(v, proc->intr);\n    /* wake up a process if a new bit is set */\n    if (proc->state != PROC_SLEEPING) {\n        proc->state = PROC_RUNNABLE;\n        /* special value for kernel */\n        proc->ipc_from = 0;\n        proc->ipc_val = v;\n        proc->ipc_size = 0;\n    }\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\nstatic pid_t vector_table[256];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_set(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] |= __bitset_mask(n);\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_pml4` system call provides a mechanism for establishing a self-referential mapping in a process's Page Map Level 4 (PML4) table. This mapping technique is commonly used in virtual memory systems to allow a process to access its own page table hierarchy through virtual memory. By mapping the PML4 table into itself at a specific index, the process can dynamically traverse and manipulate its paging structures without requiring additional system calls or privileged operations.\nThe system call begins by validating the identifier of the target process to ensure that it corresponds to a valid and active process. If the process identifier is not valid, the operation is terminated with an error, as the mapping cannot proceed without a valid target.\nOnce the process identifier is verified, the system calculates the physical frame number corresponding to the PML4 table (page table root) using the page table root of the process. The physical frame number represents the physical memory location of the PML4 table and is essential for creating the mapping. Before proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the PML4 table, as allowing write permissions could lead to accidental or malicious corruption of the page table hierarchy. By enforcing read-only or execute-only permissions, the system maintains the stability and security of the virtual memory system.\nThe system then establishes a self-referential mapping in the PML4 table by updating the appropriate entry to reference itself. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page, the page table root, corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the page of the page table root and verifies that the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the expected physical memory of the page table root using the specified page table root entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_pml4` system call is a crucial feature for enabling self-referential mappings in process page tables. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage their page tables directly, which is particularly useful in advanced memory management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtual memory architecture.\n",
        "syscall": "sys_map_pml4",
        "declaration": "int sys_map_pml4(pid_t pid, size_t index, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_pml4(pid_t pid, size_t index, pte_t perm)\n{\n    struct proc *proc;\n    pn_t from, pfn;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    from = proc->stack;\n    pfn = pn_to_pfn(from);\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PML4);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },

    {
        "description": "\n[Functional Description]:\nThe `sys_map_page_desc` system call is designed to map a portion of the page descriptor table into a process's address space. This operation is crucial for processes that need to access or manage page descriptors directly, such as in advanced memory management tasks or when implementing custom paging mechanisms. By allowing a process to map page descriptors, the system call provides flexibility in how memory is managed and accessed within the operating system.\nThe system call begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing page descriptors. If the request number is too large, the system call returns an error, as it would attempt to map beyond the available descriptors. This check ensures that the mapping operation remains within the bounds of the page descriptor table, preventing access to invalid memory regions.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the page descriptor table in memory based on the number of pages requested. This calculation determines the specific memory region within the page descriptor table that will be mapped. Before proceeding with the mapping, the system call checks the specified permissions. If the permissions include write access, the operation is rejected. This restriction is crucial for maintaining the integrity of the page descriptor table, as allowing write access could lead to corruption or unauthorized modifications.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the page descriptors. It then performs a series of checks to ensure system consistency and security. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permissions do not include any unsafe bits by comparing them against the permission mask and ensures the page table entry is valid. If any of these checks fail, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the source page number, and verifies the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nFinally, the system updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nThe result of this operation is a mapped region in the process's address space that corresponds to a portion of the page descriptor table. This capability allows the process to access and manage page descriptors directly, enabling advanced memory management techniques and custom paging implementations. By integrating this functionality into the virtual memory system, the `sys_map_page_desc` system call enhances the flexibility and efficiency of memory management in the operating system.\nIn conclusion, the `sys_map_page_desc` system call provides a mechanism for mapping page descriptors into a process's address space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage page descriptors directly, which is particularly useful in advanced memory management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtual memory architecture.\n",
        "syscall": "sys_map_page_desc",
        "declaration": "int sys_map_page_desc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_page_desc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NPAGE * sizeof(struct page_desc)))\n        return -EINVAL;\n    pfn = (uintptr_t)page_desc_table / PAGE_SIZE + n;\n    if (!pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_proc` system call provides a mechanism for mapping process descriptors into a process's page table. This operation is crucial for scenarios where processes need to share memory regions, such as in interprocess communication or shared memory applications. The system call ensures that the mapping is performed securely and adheres to the system's memory management policies.        \nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing processes. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system then calculates the physical frame number corresponding to the starting point of the process table based on the number of pages requested. This calculation determines the specific memory region within the process table that will be mapped.                Before proceeding with the mapping, the system call checks the specified permissions. If the permissions include write access, the operation is rejected. This restriction is crucial for maintaining the integrity of the process table, as allowing write access could lead to corruption or unauthorized modifications.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the processes.        \nIt then performs a series of checks to ensure system consistency and security. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system enforces strict validation of the permissions associated with the mapping. It checks that the requested permissions do not include any unsafe bits by comparing them against the permission mask and ensures the entry is valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the source page number, and verifies the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nThe result of this operation is a memory mapping that allows the target process to access the specified region of the process table. This capability is essential for enabling shared memory applications, where multiple processes need to access the same data concurrently. By providing a secure and efficient mechanism for memory mapping, the `sys_map_proc` system call enhances the flexibility and functionality of the system's memory management architecture.\nIn conclusion, the `sys_map_proc` system call provides a robust mechanism for mapping process memory into another process's address space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to share memory regions safely, supporting advanced memory management scenarios and enabling efficient interprocess communication.",
        "syscall": "sys_map_proc",
        "declaration": "int sys_map_proc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_proc(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NPROC * sizeof(struct proc)))\n        return -EINVAL;\n    pfn = (uintptr_t)proc_table / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_dev` system call is designed to map a range of device memory into a process's address space, allowing the process to interact with hardware devices directly. This functionality is crucial in systems where processes need to access device registers or memory-mapped I/O regions, such as in device drivers or low-level system utilities.\nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing PCI devices. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the device table based on the number of pages requested. This calculation determines the specific memory region within the PCI device table that will be mapped.\nBefore proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the device memory, as allowing write permissions could lead to accidental or malicious corruption of the device's state. By enforcing read-only or execute-only permissions, the system maintains the stability and security of the device interaction.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the device. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_dev` system call provides a secure and efficient mechanism for mapping device memory into a process's address space through memory-mapped I/O. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage device memory directly, which is particularly useful in advanced device management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's device management architecture.\n",
        "syscall": "sys_map_dev",
        "declaration": "int sys_map_dev(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_dev(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n < bytes_to_pages(NPCIDEV * sizeof(struct pci_dev)))\n        return -EINVAL;\n    pfn = (uintptr_t)devices / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_file` system call provides a mechanism for mapping a portion of the file table into a process's page table, allowing the process to access file metadata directly through its virtual memory space. This functionality is particularly useful in scenarios where processes need to interact with file descriptors or manage file-related operations efficiently. By mapping the file table into the process's address space, the system enables direct access to file information without additional system calls or context switches.\nThe operation begins by validating the number of pages requested to ensure it does not exceed the maximum allowable number of pages required for managing files. If the request number is too large, the operation is terminated with an error, as it cannot proceed with an invalid number.\nOnce the number is verified, the system calculates the physical frame number corresponding to the starting point of the file table in memory based on the number of pages requested. This calculation determines the specific memory region within the file table that will be mapped.\nBefore proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the file table, as allowing write permissions could lead to accidental or malicious modifications of file metadata.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the file table. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_file` system call provides a structured and secure mechanism for mapping the file table into a process's virtual memory space. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage file metadata directly, which is particularly useful in advanced file management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's file management architecture.\n",
        "syscall": "sys_map_file",
        "declaration": "int sys_map_file(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_file(pid_t pid, pn_t from, size_t index, size_t n, pte_t perm)\n{\n    pn_t pfn;\n\n    if (n >= bytes_to_pages(NFILE * sizeof(struct file)))\n        return -EINVAL;\n    pfn = (uintptr_t)file_table / PAGE_SIZE + n;\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\n#define roundup(x, y)                                                                              \\\n    ({                                                                                             \\\n        uintmax_t _x = (uintmax_t)(x);                                                             \\\n        const typeof(y) _y = y;                                                                    \\\n        (typeof(x))((((_x) + (_y - 1)) / _y) * _y);                                                \\\n    })\n\nstatic inline size_t bytes_to_pages(size_t n)\n{\n    return roundup(n, PAGE_SIZE) / PAGE_SIZE;\n}\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pd` system call is responsible for allocating a new Page Directory (PD) entry within a process's hierarchical page table structure. This operation is crucial for managing virtual memory, allowing processes to expand their address space by adding new page directories. The system call ensures that the memory is correctly allocated and mapped, adhering to the specified permissions and maintaining the integrity of the page table hierarchy.\nThe operation begins by validating the target page designated for the page directory is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page directory entry. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. PDPT (Page Directory Pointer Table), to point to the newly allocated page directory page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nAfter successfully establishing the mapping, the system proceeds to allocate the PD (Page Directory) page. This involves marking the page as belonging to the process and designating it as a PD (Page Directory) type in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pd` system call provides a structured and secure mechanism for allocating and mapping PD pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pd",
        "declaration": "int sys_alloc_pd(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pd(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PDPT, PAGE_TYPE_X86_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* update the page table */\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pt` system call is designed to allocate a new Page Table (PT) entry within a process's page directory, facilitating the expansion or modification of the process's virtual memory space. This operation is crucial in virtual memory systems, where hierarchical page tables manage address mappings, allowing processes to dynamically allocate memory as needed.\nThe operation begins by validating the target page designated for the page table is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page table. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. page directory, to point to the newly allocated page table page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nOnce the mapping is successfully established, the system proceeds to allocate the PT (Page Table) page. This involves marking the page as belonging to the process and designating it as a PT (Page Table) type in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pt` system call provides a structured and secure mechanism for allocating and mapping PT pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pt",
        "declaration": "int sys_alloc_pt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PD, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nvoid (*hvm_invalidate_tlb)(pid_t pid);\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_frame` system call is designed to allocate a new memory frame and map it into a process's page table, facilitating dynamic memory management in virtual memory systems. This operation is crucial for processes that require additional memory resources, allowing them to expand their address space as needed. The system call ensures that the memory frame is correctly allocated and mapped with the specified permissions, maintaining the integrity and security of the system.\nThe operation begins by validating the target page designated for the frame is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new frame. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. page table, to point to the newly allocated frame. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also validates that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nOnce the mapping is successfully established, the system proceeds to allocate the memory frame. This involves marking the page as belonging to the process and designating it as a frame type in the page descriptor table. The memory associated with the frame is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_frame` system call provides a structured and secure mechanism for allocating and mapping memory frames in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_frame",
        "declaration": "int sys_alloc_frame(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_frame(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PT, PAGE_TYPE_FRAME);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_copy_frame` system call is designed to facilitate the copying of memory frames between processes, ensuring that data can be transferred securely and efficiently within the constraints of the system's memory management policies. This operation is particularly useful in scenarios where a process needs to share or duplicate data with another process, such as during inter-process communication or when setting up shared memory regions.\nThe system call begins by validating the source page is valid and of the frame type. It also validates that the source page belongs to the calling process. This ensures that the process has the right to access and copy the data from the specified frame. If the frame type or ownership is incorrect, the system call terminates with an error, preventing unauthorized access to memory.\nNext, the system call verifies the target process to ensure it is valid and exists within the system. This check prevents attempts to copy data to non-existent or invalid processes, which could lead to undefined behavior or system instability. The target page is also validated to ensure it is of the frame type and belongs to the target process. This ensures that the destination frame is correctly allocated and that the target process has the right to modify it.\nAdditionally, the system call enforces a permission check to ensure that the calling process is authorized to modify the target process's memory. This is restricted to either the current process itself or a child process in the embryo state. By enforcing this restriction, the system maintains process isolation and security, preventing arbitrary memory modifications across unrelated processes. Any violation of these conditions will result in the operation being terminated and an error being returned.\nOnce all validations are complete, the system call proceeds to copy the entire content of the source frame to the target frame, corresponding to the size of a memory page. The operation is performed atomically to ensure data consistency and integrity, preventing partial or corrupted transfers.\nThe result of the `sys_copy_frame` system call is a successful duplication of the memory frame from the source process to the target process, with all necessary permissions and validations enforced. This enables processes to share data efficiently while maintaining the security and stability of the system's memory management framework. By providing a controlled mechanism for frame copying, the system call supports advanced memory management scenarios, such as shared memory regions, data migration, and inter-process communication, enhancing the overall flexibility and functionality of the operating system.\n",
        "syscall": "sys_copy_frame",
        "declaration": "int sys_copy_frame(pn_t from, pid_t pid, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_copy_frame(pn_t from, pid_t pid, pn_t to)\n{\n    if (!is_page_type(from, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_page_type(to, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(to, pid))\n        return -EACCES;\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n\n    memcpy(get_page(to), get_page(from), PAGE_SIZE);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_protect_frame` system call is designed to modify the permissions of a specific frame in a process's page table, ensuring that the memory access rights are correctly configured according to the caller's requirements. This operation is crucial in managing memory protection in virtual memory systems, where controlling access to memory frames is essential for maintaining system security and stability.\nThe system call begins by validating the specified page is valid and of the page table type. It also validates the page belongs to the calling process. If these conditions are not met, the operation is terminated with an error to maintain memory integrity and security.\nNext, the system verifies the validity of the specified index within the page table. This check ensures that the index falls within acceptable limits, preventing out-of-bounds access that could lead to undefined behavior or security vulnerabilities.\nThe system verifies the type and ownership of the memory frame to ensure it is valid and belongs to the current process before modifying its permissions. It ensures that the frame is of the expected type and belongs to the current process. Any mismatch results in the operation being rejected with an error, safeguarding against unauthorized access or modification.\nThe system retrieves the page table entries and checks if the specified slot is valid and present. If the slot is empty, the operation is terminated with an error, as there is no existing mapping to modify.\nThe system further verifies that the existing page table entry corresponds to the specified frame by checking if the physical frame number derived from the page table entry matches the frame's expected physical address. If the check is not satisfied, the operation is terminated with an error, ensuring that the operation is being performed on the correct frame, preventing accidental modification of unrelated memory regions.\nThe system enforces strict validation of the new permissions to be applied to the frame. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of these conditions are not satisfied, the operation is terminated with an error, maintaining the security and stability of the memory system.\nFinally, the system updates the page table by configuring a page table entry to establish a mapping between a virtual memory address and a physical frame, while specifying the associated access permissions. This update is performed atomically to ensure consistency during the operation. After the modification, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This ensures that any stale or outdated address translations cached in the TLB are removed, forcing the processor to fetch updated mappings from the page tables and immediately reflect the new memory configuration.\nBy the end of the operation, the specified frame has its permissions updated according to the caller's request. This allows the process to control access to its memory frames, enabling features such as read-only or execute-only protection. The `sys_protect_frame` system call, therefore, is a critical component of memory management, allowing processes to dynamically adjust memory protection as needed. Its design ensures that memory is safely managed, preventing unauthorized access and maintaining the integrity of the system's memory architecture.\n",
        "syscall": "sys_protect_frame",
        "declaration": "int sys_protect_frame(pn_t pt, size_t index, pn_t frame, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_protect_frame(pn_t pt, size_t index, pn_t frame, pte_t perm)\n{\n    pte_t *entries;\n    pn_t pfn;\n\n    if (!is_page_type(pt, PAGE_TYPE_X86_PT))\n        return -EINVAL;\n    if (!is_page_pid(pt, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (is_page_type(frame, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_page_pid(frame, current))\n        return -EACCES;\n\n    entries = get_page(pt);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    pfn = PTE_ADDR(entries[index]) >> PAGE_SHIFT;\n    if (pn_to_pfn(frame) != pfn)\n        return -EINVAL;\n\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    /* update the page table */\n    entries[index] = (pfn << PTE_PFN_SHIFT) | perm;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_pd` system call is designed to deallocate a Page Directory (PD) entry within a process's page table hierarchy, specifically targeting the release of a PD page and its reference in a Page Directory Pointer Table (PDPT). This operation is crucial for managing virtual memory dynamically, allowing processes to free up memory resources that are no longer needed, thus optimizing memory usage and maintaining system stability.\nThe system call begins by validating that the source page is valid and is of the correct type, a Page Directory Pointer Table type. It also validates that the source page belongs to the calling process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page directory pointer table. This check ensures that the operation targets a valid entry within the page directory pointer table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page is valid and is of the correct type, a Page Directory, and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page directory pointer table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page directory pointer table entry corresponds to the specified page directory by checking if the physical frame number derived from the page directory pointer table entry matches the page directory's expected physiscal address.  This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the page directory (PD) page. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page directory pointer table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PD from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PD is freed.\nBy the end of the operation, the specified PD page is fully deallocated, and its entry in the PDPT is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_pd` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pd",
        "declaration": "int sys_free_pd(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pd(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PDPT, PAGE_TYPE_X86_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_pt` system call is designed to deallocate a specific entry in a page table hierarchy by freeing a Page Table (PT) page and removing its reference from a higher-level Page Directory (PD). This operation is crucial for dynamic memory management in virtual memory systems, where hierarchical page tables manage address mappings. The system call ensures that the memory associated with a PT page is properly released and no longer accessible, while maintaining the integrity of the page table structure.\nThe system call begins by validating that the source page directory is valid and is of the correct type, a Page Directory type. It also validates that the source page directory belongs to the calling process. It ensures that the page directory corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page directory. This check ensures that the operation targets a valid entry within the directory, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page table is valid and is of the correct type, a Page Table. It ensures that the target page table corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page directory entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page directory entry corresponds to the specified page table by checking if the physical frame number derived from the page directory entry matches the page table's expected physiscal address. This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the page table (PT) page.  The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page directory entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PT from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PT is freed.\nBy the end of the operation, the specified PT page is fully deallocated, and its entry in the PD table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_pt` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pt",
        "declaration": "int sys_free_pt(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pt(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PD, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_free_frame` system call is designed to deallocate a specific frame of memory that is currently mapped in a process's page table. This operation is crucial for efficient memory management in operating systems, allowing processes to release memory resources that are no longer needed. By freeing up frames, the system can reclaim memory for other uses, preventing resource exhaustion and optimizing overall performance.\nThe system call begins by validating that the source page table entry is valid and is of the correct type, a Page Table type. It also validates that the source page table belongs to the calling process. It ensures that the page table corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the page table. This check ensures that the operation targets a valid entry within the page table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target frame is valid and is of the correct type, a Frame. It ensures that the target frame corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the page table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing page table entry corresponds to the specified frame by checking if the physical frame number derived from the page table entry matches the frame's expected physiscal address. This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the frame. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the page table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the frame from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the frame is freed.\nBy the end of the operation, the specified frame is fully deallocated, and its entry in the page table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The `sys_free_frame` system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_frame",
        "declaration": "int sys_free_frame(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_frame(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PT, PAGE_TYPE_FRAME);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_page` system call is designed to reclaim memory pages that are no longer actively used by processes, specifically targeting pages owned by processes in a \"zombie\" state. This functionality is crucial for efficient memory management in operating systems, allowing the system to recover and reuse memory resources that are no longer needed by terminated processes.\nThe system call begins by validating the page identifier is valid and allocated. If the identifier is invalid or the page is already marked as free, the operation is terminated with an error, as there is no need to reclaim an already free or invalid page.\nOnce the memory page identifier is verified, the system checks the ownership of the page to ensure it belongs to a process that is in a zombie state and the validity of the owner process. A zombie process is one that has completed execution but still has an entry in the process table, typically waiting for its parent process to read its exit status. This restriction ensures that only pages from processes that are no longer active can be reclaimed, preventing accidental or unauthorized reclamation of pages still in use.\nThe system also checks if any devices are associated with the process that owns the page. If any devices are in use, the operation is rejected with an error. This restriction prevents the reclamation of pages that might still be required by active devices, ensuring system stability and preventing potential data loss or corruption.\nIf all conditions are met, the system proceeds to free the page. This involves resetting the owner process of the page, marking the page as a free type and updating the process's metadata to reflect the reduction in its memory usage. The freed page is then added back to the system's pool of available pages, making it available for allocation to other processes or system components.\nBy reclaiming pages from zombie processes, the `sys_reclaim_page` system call helps maintain optimal memory utilization in the system. It ensures that memory resources are not wasted on terminated processes, allowing the system to allocate memory more efficiently to active processes. This functionality is particularly important in environments with limited memory resources, where efficient memory management can significantly impact system performance and stability.\nIn summary, the `sys_reclaim_page` system call provides a mechanism for reclaiming memory pages from zombie processes, ensuring efficient memory utilization and preventing resource wastage. It validates inputs, checks process states, and safely reclaims pages, contributing to the overall robustness and efficiency of the operating system's memory management system.\n",
        "syscall": "sys_reclaim_page",
        "declaration": "int sys_reclaim_page(pn_t pn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_page(pn_t pn)\n{\n    struct page_desc *desc;\n\n    if (!is_pn_valid(pn))\n        return -EINVAL;\n    if (is_page_type(pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    desc = get_page_desc(pn);\n    /* can reclaim pages owned by a zombie */\n    if (!is_proc_state(desc->pid, PROC_ZOMBIE))\n        return -EACCES;\n    /* don't reclaim anything if any device is in use */\n    if (get_proc(desc->pid)->nr_devs)\n        return -EBUSY;\n\n    free_page(pn);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_set_runnable` system call is designed to transition a process from an initial state to a state where it is ready to be executed by the system scheduler. This operation is crucial for process management, allowing a parent process to prepare its child process for execution once it has been properly initialized and is ready to run.\nThe system call begins by verifying the validity of the specified process. This ensures that the operation targets a legitimate process within the system. If the identifier is invalid, the operation is halted, and an error is returned, as the transition cannot proceed without a valid target.\nOnce the process identifier is confirmed, the system then checks if the calling process is the parent of the target process. This restriction ensures that only the parent process, which is responsible for the creation and initial setup of the child process, can transition it to a runnable state. If the calling process is not the parent, the operation is rejected with an error, maintaining process hierarchy integrity.\nThe system also verifies that the target process is in its initial state, indicating that it is newly created and not yet ready for execution. This check ensures that only processes that have not yet been made runnable can be transitioned, preventing unintended state changes for processes that are already active or terminated. If the process is not in the initial state, the operation is terminated with an error.\nUpon successful validation, the system updates the process state to indicate that it is ready for execution. This state change signals to the system scheduler that the process can be considered for execution during scheduling decisions. The system then adds the process to the list of ready processes, ensuring that it is included in the pool of processes eligible for execution.\nIn conclusion, the `sys_set_runnable` system call is a vital mechanism for process management, enabling a controlled transition of processes from an initial state to a runnable state. By enforcing strict checks on process identifiers, parent-child relationships, and process states, the system ensures that only appropriate processes are transitioned, maintaining the integrity and stability of the process management system. This design allows for efficient and secure process scheduling, contributing to the overall robustness of the operating system.\n",
        "syscall": "sys_set_runnable",
        "declaration": "int sys_set_runnable(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_set_runnable(pid_t pid)\n{\n    struct proc *proc;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    /* only the parent process can make it ready */\n    if (proc->ppid != current)\n        return -EACCES;\n    /* can ready only an embryo process */\n    if (proc->state != PROC_EMBRYO)\n        return -EINVAL;\n\n    proc->state = PROC_RUNNABLE;\n    proc_ready_add(proc);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `switch_proc` system call is designed to facilitate the context switching between processes in a multitasking operating system. This operation is crucial for managing process execution, allowing the system to allocate CPU time to different processes based on their state and priority. By switching the currently running process to another that is ready to run, the system call ensures efficient CPU utilization and responsive system behavior.\nThe system call begins by verifying the validity of the target process identifier. If the identifier does not correspond to a valid process, the operation is halted with an error, as switching cannot proceed without a legitimate target. Following this, the system checks the state of the target process to ensure it is ready to run. If the process is not in a runnable state, the operation is terminated with an error, preventing the system from attempting to switch to a process that cannot execute.\nIf the target process is different from the currently executing process, the system prepares to switch contexts. It retrieves the descriptors for both the current and target processes, ensuring that the target process is indeed ready to run. The system then updates the state of the current process. If the current process is actively running, it is transitioned to a runnable state unless it has been marked for termination, in which case it is moved to a terminated state indicating that it has completed execution but has not yet been fully cleaned up and removed from the ready queue.\nThe target process is then set to a running state, and the system updates its internal record to reflect the new current process. This change in state ensures that the CPU will execute the target process upon resuming operations.\nThe system call concludes by preparing to invoke a mechanism that will execute the newly designated current process. This ensures that the system's execution context is correctly aligned with the updated process state, allowing the target process to run seamlessly.\nIn summary, the `switch_proc` system call is a critical component of process management, enabling the operating system to efficiently allocate CPU resources among multiple processes. By validating process states, managing transitions, and updating execution contexts, this system call ensures smooth and effective multitasking within the system.\n",
        "syscall": "switch_proc",
        "declaration": "int sys_switch(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint switch_proc(pid_t pid)\n{\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (is_proc_state(pid, PROC_RUNNABLE))\n        return -EINVAL;\n\n    if (current != pid) {\n        struct proc *old, *new;\n\n        old = get_proc(current);\n        new = get_proc(pid);\n        assert(new->state == PROC_RUNNABLE, \"new proc must be runnable\");\n\n        if (old->state == PROC_RUNNING) {\n            if (old->killed) {\n                old->state = PROC_ZOMBIE;\n                proc_ready_del(old);\n            } else {\n                old->state = PROC_RUNNABLE;\n            }\n        }\n        new->state = PROC_RUNNING;\n        current = pid;\n    }\n\n    /* will call run_current() upon return */\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_kill` system call is designed to terminate a process by marking it as killed, which will eventually lead to its transition to a zombie state. This system call is a fundamental part of process management, allowing the operating system or other processes to terminate processes that are no longer needed or are behaving incorrectly. The operation ensures that the process is marked for termination and will be cleaned up appropriately during the next scheduling cycle.\nThe system call begins by validating the identifier of the target process to ensure it corresponds to a valid and existing process. If the identifier is invalid, the operation is terminated with an error, as the termination cannot proceed without a valid target.\nOnce the identifier is verified, the system checks the current state of the process. The operation is only allowed if the process is in a state where it can be terminated, such as being active or in the process of starting. If the process is in a state where termination is not applicable, such as being unused or already terminated, the operation is rejected with an error. This ensures that resources are not wasted on processes that do not require termination.\nAfter confirming the process's eligibility for termination, the system marks the process for termination by setting a specific flag. This flag indicates that the process should be terminated at the next opportunity, such as during a context switch or timer event. This approach allows the system to handle termination in a controlled manner, ensuring that resources are released appropriately and that the process does not continue executing.\nIf the process is not currently executing, the system immediately transitions it to a terminated state and removes it from the list of active processes. This ensures that the process is no longer scheduled for execution and that its resources can be reclaimed by the system. By handling non-executing processes immediately, the system maintains efficiency and prevents unnecessary resource usage.\nIn conclusion, the `sys_kill` system call provides a mechanism for terminating processes in a controlled and efficient manner. It validates inputs, checks process states, and marks processes for termination, ensuring that resources are managed effectively and that processes can be stopped when necessary. This functionality is essential for maintaining system stability and managing process lifecycles in a multitasking environment.\n",
        "syscall": "sys_kill",
        "declaration": "int sys_kill(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_kill(pid_t pid)\n{\n    struct proc *proc;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* can kill an embryo/runnable/running, not unused or zombie */\n    if (is_proc_state(pid, PROC_UNUSED) || is_proc_state(pid, PROC_ZOMBIE))\n        return -EINVAL;\n\n    proc->killed = 1;\n\n    if (!is_proc_state(pid, PROC_RUNNING)) {\n        proc->state = PROC_ZOMBIE;\n        proc_ready_del(proc);\n    }\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reap` system call is designed to allow a parent process to clean up and reclaim resources from a terminated child process. This operation is crucial in process management, ensuring that system resources are efficiently recycled and preventing resource leaks.\nThe system call begins by verifying the validity of the provided process identifier. If the identifier does not correspond to a valid process, the operation is halted with an error, as it cannot proceed without a legitimate target.\nOnce the process identifier is confirmed, the system then checks if the calling process is the parent of the target process and the target process is in a terminated state. If any of the conditions are not met, the operation is rejected with an error, as only an active parent process is authorized to perform the cleanup.\nThe system then performs a series of checks to ensure that the target process has released all its resources. These checks include verifying that the process has no active devices, child processes, file descriptors, memory pages, DMA pages, I/O ports, interrupt vectors, or interrupt remapping entries. If any resources are still in use, the operation is halted with an error, preventing premature cleanup and ensuring system stability.\nOnce all conditions are satisfied, the system proceeds to free the resources associated with the target process. This involves updating the metadata of the process's parent process to reflect the decrease of its active child processes. Since the process is no longer active, its attributes are reset, including its pareent process, page table root, stack, hardware virtual machine, launch status, termination flag, I/O bitmap use flag, first I/O bitmap section, and second I/O bitmap section. The system marks the process as a unused state.\nIn conclusion, the `sys_reap` system call is a critical component of process management, enabling efficient resource reclamation and preventing resource leaks. By enforcing strict checks on process state and resource usage, the system ensures that cleanup operations are performed safely and effectively, contributing to the overall robustness and efficiency of the operating system.\n",
        "syscall": "sys_reap",
        "declaration": "int sys_reap(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reap(pid_t pid)\n{\n    struct proc *proc;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* only the parent process can reap */\n    if (proc->ppid != current)\n        return -EACCES;\n    /* must be a zombie */\n    if (proc->state != PROC_ZOMBIE)\n        return -EINVAL;\n    if (proc->nr_devs)\n        return -ETXTBSY;\n    if (proc->nr_children)\n        return -ETXTBSY;\n    if (proc->nr_fds)\n        return -ETXTBSY;\n    if (proc->nr_pages)\n        return -ETXTBSY;\n    if (proc->nr_dmapages)\n        return -ETXTBSY;\n    if (proc->nr_ports)\n        return -ETXTBSY;\n    if (proc->nr_vectors)\n        return -ETXTBSY;\n    if (proc->nr_intremaps)\n        return -ETXTBSY;\n\n    free_proc(pid);\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic void free_proc(pid_t pid)\n{\n    struct proc *proc;\n\n    proc = get_proc(pid);\n    /* init cannot be freed, so ppid should be non-zero */\n    --get_proc(proc->ppid)->nr_children;\n\n    proc->state = PROC_UNUSED;\n    proc->ppid = 0;\n    proc->page_table_root = 0;\n    proc->stack = 0;\n    proc->hvm = 0;\n    proc->launched = 0;\n    proc->killed = 0;\n    proc->use_io_bitmap = 0;\n    proc->io_bitmap_a = 0;\n    proc->io_bitmap_b = 0;\n    proc->name[0] = 0;\n    proc->name[1] = 0;\n}\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reparent` system call is designed to reassign the parent process of a specified process to a predefined system process, typically the initial system process. This operation is crucial in process management, particularly when the original parent process has terminated, ensuring that orphaned processes are properly managed and do not remain without a parent.\nThe system call begins by validating the identifier of the specified process to ensure it corresponds to an existing and valid process. If the identifier is invalid, the operation is halted with an error, as the reassignment cannot proceed without a valid target.\nOnce the identifier is confirmed, the system checks the state of the current parent process to ensure it is in a terminated state. This check is crucial, as the reassignment is only necessary if the parent process is no longer active.\nAdditionally, the system verifies the state of the predefined initial system process to ensure it is capable of accepting new child processes. This step ensures that the system process is in a runnable or running state to assume the role of the parent, maintaining system stability and process hierarchy integrity.\nUpon successful validation, the system updates the parent process of the target process to the system predefined initial process. Accordingly, it updates the metadata of the initial process to reflect the increase of its child processces. It also updates the metadata of the original parent process of the target process to reflect the decrease of its child processes. This adjustment reflects the change in the process hierarchy and ensures accurate tracking of process relationships. By completing this process, the system ensures that the specified process is no longer orphaned and is properly integrated into the process hierarchy under the management of the predefined system process.\nIn conclusion, the `sys_reparent` system call is a vital mechanism for maintaining process hierarchy integrity and ensuring that orphaned processes are appropriately managed. By validating inputs, enforcing state checks, and updating process relationships securely and efficiently, the system call contributes to the overall robustness and reliability of the system's process management architecture.\n",
        "syscall": "sys_reparent",
        "declaration": "int sys_reparent(pid_t pid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reparent(pid_t pid)\n{\n    struct proc *proc;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    /* the parent process must be zombie */\n    if (!is_proc_state(proc->ppid, PROC_ZOMBIE))\n        return -EINVAL;\n    /* not sure if we need this */\n    if (!is_proc_state(INITPID, PROC_RUNNABLE) && !is_proc_state(INITPID, PROC_RUNNING))\n        return -EINVAL;\n\n    --get_proc(INITPID)->nr_children;\n    --get_proc(proc->ppid)->nr_children;\n    proc->ppid = INITPID;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `recv_proc` system call facilitates inter-process communication by allowing a process to receive data from another process. This operation is crucial in systems where processes need to exchange information or synchronize their activities. The system call ensures that the receiving process is in a suitable state to accept data and that the memory and file descriptors involved are valid and properly configured.\nThe system call begins by verifying the identity of the target process to ensure it is valid and in a runnable state that allows it to receive data. If the process identifier is not valid or the process is not in the correct state, the operation is terminated with an error. This ensures that only active and ready processes can participate in data exchange.\nNext, the system validates the memory location where the data will be received. It checks that the memory is owned by the current process and is of the frame type to hold the incoming data. If these conditions are not met, the operation is rejected with an error. This validation step prevents unauthorized access to memory and ensures data integrity.\nThe system also examines the file descriptor associated with the operation. If a file descriptor is provided, it is checked for validity to ensure it is not already associated with an existing resource. If the file descriptor is associated with an existing resource, the operation is rejected with an error.\nOnce all validations are complete, the system prepares the current process as the receiving process for data transfer. It updates the process's internal state to reflect the incoming data, including the memory page and the file descriptor, and marks it as ready to receive. The receiver process is then transitioned to a waiting state, allowing the sending process to proceed with the data transfer. This state transition is crucial for synchronizing the activities of the involved processes.\nFinally, the system updates the scheduling information to reflect the new state of the processes. The receiving process is removed from the ready queue, and the sending process is marked as active and current. And then the current process is switched to the sending process. This ensures that the system's scheduler can efficiently manage process execution and resource allocation.\nIn summary, the `recv_proc` system call is a vital component for enabling inter-process communication. It performs rigorous checks to validate process states, memory locations, and file descriptors, ensuring secure and efficient data exchange. By managing process states and scheduling, the system call contributes to the overall stability and performance of the system's process management architecture.\n",
        "syscall": "recv_proc",
        "declaration": "int sys_recv(pid_t pid, pn_t pn, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint recv_proc(pid_t pid, pn_t pn, int fd)\n{\n    struct proc *server;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_RUNNABLE))\n        return -EINVAL;\n    if (!is_pn_valid(pn))\n        return -EINVAL;\n    if (!is_page_pid(pn, current))\n        return -EACCES;\n    if (!is_page_type(pn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    if (!is_fd_valid(fd)) {\n        if (is_fn_valid(get_fd(current, fd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is runnable\");\n    server = get_proc(current);\n    server->ipc_from = 0;\n    server->ipc_page = pn;\n    server->ipc_size = 0;\n    server->ipc_fd = fd;\n\n    server->state = PROC_SLEEPING;\n    /* server: running -> sleeping */\n    proc_ready_del(server);\n    get_proc(pid)->state = PROC_RUNNING;\n    current = pid;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `call_proc` system call facilitates interprocess communication by allowing a process to send data to another process and then transfer control to the receiving process. This mechanism is essential for scenarios where a client process needs to invoke a service or function provided by a server process, enabling efficient and synchronized communication between processes.\nThe system call begins by verifying the validity of the target process and ensuring it is in the sleeping state, indicating readiness to receive data. If the target process is not valid or is actively running, the system call terminates with an error.\nNext, the system validates the validity of the input page and the output page. It also validates taht the input and output pages belong to the calling process. The type of the output page should be the correct frame page and the size of the data must not exceed the limits of a memory page. Any violations to these constriants will make the operation to terminate with an error.\nThe system then validates that the input file descriptor is either invalid or non-empty and the output file descriptor is either invalid or empty. The input file descriptor is set to be invalid to indicate no input file descriptor in this operation. If these conditions are not met, the operation is rejected with an error. These checks ensure that communication adheres to system constraints and prevents unauthorized access.\nThe system then sets up the communication. It sets the current process as the sender process and the target process as the receiver process. It then validates the receiver process wants to accept the other process' requests. If the condition is not met, the operation is rejected with an error. The sender process then prepares to send its request by specifying the data to be transferred and optional resources such as file descriptors. The receiver process prepares to receive this data by specifying the source process that the data is from and the specific control value. The system then securely transfers the page of data from the input page to the designated page of the receiver process and updates the transferred size for the receiver process. If the input file descriptor and the file descriptor of the receiver process are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nAfter the data and resources are transferred, the system transitions control between the two processes. The sender process is placed into a sleeping state, indicating that it is waiting for the receiver to complete its task. At the same time, the receiver process is transitioned to a running state, allowing it to process the request immediately. This context switch ensures that the receiver begins handling the request without delay while the sender remains blocked until the receiver completes its task. The state transition is carefully managed to maintain system stability and prevent race conditions or deadlocks.\nFinally, the system resets the IPC state of the current process and then switches the current process context to the specified process.\nBy the end of the operation, the receiver process is actively running and processing the request, while the sender process is waiting for the receiver to finish. This design enables efficient and synchronized communication between processes, allowing them to interact seamlessly while maintaining strict isolation and synchronization.\nIn summary, the `call_proc` system call enables interprocess communication by transferring data and control between processes. It validates inputs, securely transfers data, and manages process states to ensure efficient and synchronized communication. This functionality is critical for enabling processes to interact in a controlled and coordinated manner, making it a key component of interprocess communication in operating systems.\n",
        "syscall": "call_proc",
        "declaration": "int sys_call(pid_t pid, uint64_t val, pn_t inpn, size_t size, pn_t outpn, int outfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint call_proc(pid_t pid, uint64_t val, pn_t inpn, size_t size, pn_t outpn, int outfd)\n{\n    int r;\n\n    r = send_recv(pid, val, inpn, size, -1, outpn, outfd);\n    if (r)\n        return r;\n    /* accept any ipc */\n    get_proc(current)->ipc_from = pid;\n    current = pid;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPROC 64    /* maximum number of processes */\n\nstatic int send_recv(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn,\n                     int outfd)\n{\n    struct proc *sender, *receiver;\n\n    /* target process must be sleeping */\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    /* check in page */\n    if (!is_pn_valid(inpn))\n        return -EINVAL;\n    /* inpn doesn't have to be a frame */\n    if (!is_page_pid(inpn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    /* check in fd: either invalid or non-empty */\n    if (!is_fd_valid(infd)) {\n        if (!is_fn_valid(get_fd(current, infd)))\n            return -EINVAL;\n    }\n    /* check out page */\n    if (!is_pn_valid(outpn))\n        return -EINVAL;\n    if (!is_page_pid(outpn, current))\n        return -EACCES;\n    if (!is_page_type(outpn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    /* check out fd: either invalid or empty */\n    if (is_fd_valid(outfd)) {\n        if (is_fn_valid(get_fd(current, outfd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    /* check if the receiver wants to accept anyone's request */\n    if (receiver->ipc_from && receiver->ipc_from != current)\n        return -EACCES;\n\n    /* client: prepare for response */\n    sender->ipc_page = outpn;\n    sender->ipc_fd = outfd;\n\n    /* server: transfer data from client */\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    /* transfer the page */\n    memcpy(get_page(receiver->ipc_page), get_page(inpn), size);\n    receiver->ipc_size = size;\n    /* transfer the fd */\n    if (is_fd_valid(infd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, infd));\n\n    /* switch control */\n\n    sender->state = PROC_SLEEPING;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    /* sender: running -> sleeping */\n    proc_ready_del(sender);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_create` system call is responsible for creating a new file descriptor entry in the file descriptor table of the current process. This operation is essential for managing access to files, devices, or other I/O resources within an operating system. By establishing a new file descriptor, the system call enables processes to interact with these resources in a controlled and organized manner.\nThe system call begins by validating the type of the resource to be associated with the file descriptor. If the type is invalid, the operation is terminated with an error, as a valid type is necessary for the creation process. The system then checks the validity of the file descriptor to ensure it falls within acceptable limits. If the file descriptor is not valid, the operation is rejected with an error, preventing any invalid or out-of-bounds access.\nOnce the file descriptor is verified, the system checks if it is currently unused by the calling process. If the file descriptor is already in use, the operation is terminated with an error, as it cannot be overwritten without proper closure or release. The system then validates the identifier for the file or resource to ensure it is within acceptable limits. If the identifier is not valid, the operation is rejected with an error, ensuring that only valid resources are associated with file descriptors.\nThe system retrieves the file or resource associated with the identifier and checks its reference count to ensure it is unused. If the resource is already in use, the operation is terminated with an error, preventing any conflicts or resource contention. Once all validations are satisfied, the system initializes the file or resource with the specified attributes, including its type, value, and mode of operation. The reference count and the offset are both initialized to the start value.\nFinally, the system associates the file descriptor with the file or resource by updating the process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. The operation concludes successfully, allowing the process to interact with the newly created file descriptor.\nIn summary, the `sys_create` system call is a critical component for managing file descriptors within a process. It ensures that all inputs are validated, resources are properly initialized, and associations are securely established. This design contributes to the overall stability and functionality of the system's file management architecture, enabling processes to efficiently manage their file interactions.\n",
        "syscall": "sys_create",
        "declaration": "int sys_create(int fd, fn_t fn, uint64_t type, uint64_t value, uint64_t mode);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_create(int fd, fn_t fn, uint64_t type, uint64_t value, uint64_t omode)\n{\n    struct file *file;\n\n    if (type == FD_NONE)\n        return -EINVAL;\n    if (!is_fd_valid(fd))\n        return -EBADF;\n    /* fd must be empty */\n    if (get_fd(current, fd) != 0)\n        return -EINVAL;\n    if (!is_fn_valid(fn))\n        return -EINVAL;\n    /* fn must be unused */\n    if (file->refcnt != 0)\n        return -EINVAL;\n\n    file->type = type;\n    file->value = value;\n    file->omode = omode;\n    file->refcnt = 0;\n    file->offset = 0;\n    set_fd(current, fd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_close` system call is responsible for closing a file descriptor associated with a specific process, thereby releasing the resources tied to that descriptor. This operation is fundamental in resource management within operating systems, ensuring that file descriptors are properly deallocated when they are no longer needed, preventing resource leaks and maintaining system stability.\nThe system call begins by validating the process identifier to ensure it corresponds to a valid process. If the process identifier is invalid, the operation is terminated with an error, as the closure cannot proceed without a valid target. Similarly, the system checks the validity of the file descriptor. If the file descriptor is invalid, the operation is terminated with an error, preventing any attempt to close a non-existent or out-of-bounds descriptor.\nOnce both the process identifier and file descriptor are verified, the system performs a permission check to ensure that the operation is allowed. The system permits the closure if the process is the current one or if it is in a terminated state. This restriction ensures that only authorized processes can close their file descriptors, maintaining system integrity and preventing unauthorized access.\nThe system then checks if the file descriptor is currently in use by the process. If the file descriptor is not associated with any open file, the operation is terminated with an error, as there is nothing to close. This check prevents unnecessary operations and ensures that only active file descriptors are targeted.\nIf all checks are satisfied, the system proceeds to clear the file descriptor, effectively closing it. This involves updating the process's file descriptor table to mark the descriptor as unused and decrementing the count of open file descriptors for the process. Additionally, the system updates the file's reference count to reflect the decrease of the file references. And if the file is no longer referenced by any process, it resets the file's attributes, including its type, value, offset, and mode of operation, releasing the associated resources.\nIn summary, the `sys_close` system call is an essential mechanism for managing file descriptors within a process or across processes. It ensures that all inputs are validated, permissions are enforced, and resources are securely released when a file descriptor is no longer needed. By allowing proper cleanup of file descriptors, the system call contributes to the stability and efficiency of the system's resource management, preventing resource leaks and ensuring orderly file descriptor handling.\n",
        "syscall": "sys_close",
        "declaration": "int sys_close(pid_t pid, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_close(pid_t pid, int fd)\n{\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_fd_valid(fd))\n        return -EBADF;\n    /* permission check: current or a dead pid */\n    if (pid != current && !is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_fd(pid, fd) == 0)\n        return -EBADF;\n    clear_fd(pid, fd);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void clear_fd(pid_t pid, int fd)\n{\n    struct proc *proc;\n    struct file *file;\n\n    proc = get_proc(pid);\n    file = get_file(get_fd(pid, fd));\n    proc->ofile[fd - 3] = 0;\n    --proc->nr_fds;\n    if (--file->refcnt == 0) {\n        file->type = FD_NONE;\n        file->value = 0;\n        file->offset = 0;\n        file->omode = 0;\n    }\n}\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_dup` system call provides a mechanism for duplicating a file descriptor from one process to another. This operation is essential in scenarios where a process needs to share or transfer access to a file or resource with another process. By duplicating a file descriptor, the system allows multiple processes to interact with the same underlying resource, facilitating inter-process communication and resource sharing.\nThe system call begins by validating the target process identifier to ensure it corresponds to a valid and active process. If the process identifier is invalid, the operation is terminated with an error, as the duplication cannot proceed without a valid target. Additionally, the system checks that the target process is either the current process or its embryo, ensuring that the operation respects process boundaries and permissions.\nNext, the system verifies the validity of the source file descriptor within the current process. It also validates the source file descriptor exists in the calling process. If the source file descriptor is invalid or does not exist in the calling process, the operation is rejected with an error. This check ensures that the duplication operation is based on a valid and accessible resource. \nThe system then validates the target file descriptor within the target process. It also validates the target file descriptor does not exist in the target process. If the target file descriptor is invalid or exists in the target process, the operation is terminated with an error. This step prevents accidental overwriting of existing file descriptors, maintaining the integrity of the target process's file descriptor table.\nOnce all validations are satisfied, the system proceeds to duplicate the source file descriptor. The system associates the file descriptor with the file or resource by updating the target process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. This assignment is performed atomically to ensure consistency and correctness during the operation.\nIn conclusion, the `sys_dup` system call is a vital feature for enabling file descriptor duplication across processes. It carefully validates inputs, enforces strict permissions, and ensures that the duplication is performed securely and efficiently. By providing this capability, the system call enhances the system's flexibility and robustness in managing shared resources and inter-process communication.\n",
        "syscall": "sys_dup",
        "declaration": "int sys_dup(int oldfd, pid_t pid, int newfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_dup(int oldfd, pid_t pid, int newfd)\n{\n    fn_t fn;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    /* oldfd doesn't exist  */\n    if (!is_fd_valid(oldfd))\n        return -EBADF;\n    fn = get_fd(current, oldfd);\n    if (fn == 0)\n        return -EBADF;\n    if (!is_fd_valid(newfd))\n        return -EBADF;\n    /* newfd already exists */\n    if (get_fd(pid, newfd) != 0)\n        return -EINVAL;\n\n    set_fd(pid, newfd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define NOFILE 16   /* open files per process */\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    --proc->nr_fds;\n    ++file->refcnt;\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_lseek` system call provides a mechanism for adjusting the position within a file for subsequent read or write operations. This operation is essential in file management, allowing processes to navigate through file contents efficiently without reading or writing data sequentially. By setting the file position to a specified location, processes can directly access desired portions of a file, enhancing performance and flexibility in file handling.\nThe system call begins by validating the validity of the specified file descriptor. If it is invalid, the operation is rejected with an error, preventing any further operations on an undefined or closed file. The system then retrieves the corresponding file number and validates its validity. It also ensures the file is an inode-based file, which supports seeking operations. If the conditions are not met, the operation is rejected with an error, preventing the system call from being applied to file types that do not support offset manipulation, such as sockets or pipes, which would result in undefined behavior. The system then verifies the validity of the specified offset, ensuring the correctness of the offset to be update.\nThe system then updates the file's position to the specified location. This update is performed atomically to ensure consistency during the operation. By adjusting the file position, the system enables subsequent read or write operations to occur at the new location, allowing processes to efficiently access and modify file contents as needed.\nIn conclusion, the `sys_lseek` system call is a crucial feature for enabling flexible file navigation in processes. It carefully validates inputs, enforces type restrictions, and ensures that the position adjustment is performed securely and efficiently. This design allows processes to manage file access dynamically, contributing to the overall robustness and flexibility of the system's file management architecture.\n",
        "syscall": "sys_lseek",
        "declaration": "int sys_lseek(int fd, off_t offset);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_lseek(int fd, off_t offset)\n{\n    fn_t fn;\n    struct file *file;\n\n    if (!is_fd_valid(fd))\n        return -EBADF;\n    fn = get_fd(current, fd);\n    if (!is_file_type(fn, FD_INODE))\n        return -EINVAL;\n    if (offset < 0)\n        return -EINVAL;\n\n    file->offset = offset;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_file_type(fn_t fn, enum file_type type)\n{\n    return is_fn_valid(fn) && get_file(fn)->type == type;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_pcipage` system call is designed to facilitate the mapping of PCI device memory into a process's address space. This operation is crucial in systems where processes need direct access to hardware resources, such as device drivers that interact with PCI devices. By mapping PCI pages into the process's page table, the system call enables efficient and controlled access to device memory, ensuring that processes can perform necessary I/O operations without compromising system stability or security.\nThe system call begins by verifying the validity of the specified pci page. If the pci page is not valid, the operation is terminated with an error, as the mapping cannot proceed without a valid target. Additionally, the system call checks that the current process owns the specified PCI page. If the process does not own the page, the operation is rejected with an error. This ownership check is crucial for maintaining process isolation and ensuring that only authorized processes can map and access specific hardware resources.\nOnce the validations are complete, the system call calculates the physical frame number (PFN) for the PCI page. The PFN is derived from the base address of the PCI memory region and the pci page number, providing the exact physical location of the PCI page in memory. This calculation is essential for correctly updating the process's page table with the appropriate physical address.\nThe system then establishes the mapping by updating the process's page table entry at the specified index to point to the PCI page's PFN, with the permissions specified by the caller. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page table, and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the sys_map_pcipage system call is a vital feature for enabling direct access to device memory in process page tables. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to interact with hardware components directly, which is particularly useful in scenarios requiring high-performance device communication. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's memory management architecture.\n",
        "syscall": "sys_map_pcipage",
        "declaration": "int sys_map_pcipage(pn_t pt, size_t index, pn_t pcipn, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_pcipage(pn_t pt, size_t index, pn_t pcipn, pte_t perm)\n{\n    pid_t pid = current;\n    pn_t pfn;\n\n    /* check if pcipn is valid in pci pages */\n    if (!is_pcipn_valid(pcipn))\n        return -EINVAL;\n    /* check if current owns the pcipage */\n    if (!is_pcipn_pid(pcipn, pid))\n        return -EACCES;\n\n    pfn = PCI_START / PAGE_SIZE + pcipn;\n    return map_page(pid, pt, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n#define NPAGE 8192  /* maximum number of pages */\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nextern struct proc proc_table[NPROC];\n\n/* pci hole pages: pfn -> devid */\nstruct pcipage_desc {\n    devid_t devid;\n    bool valid;\n};\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define PCI_START               UINT64_C(0xa0000000)\n#define PCI_END                 UINT64_C(0x100000000)\n#define NPCIPAGE ((PCI_END - PCI_START) / PAGE_SIZE)\n\nstatic struct pcipage_desc pcipages[NPCIPAGE];\n\nstatic int is_pcipn_valid(pn_t pcipn)\n{\n    return pcipn < NPCIPAGE && pcipages[pcipn].valid;\n}\n\nstatic int is_pcipn_pid(pn_t pcipn, pid_t pid)\n{\n    return is_pcipn_valid(pcipn) && pcipn_to_pid(pcipn) == pid;\n}\n\n#define SZ_64K UINT64_C(0x00010000)\nstatic pid_t pci_table[SZ_64K];\n\nstatic pid_t pcipn_to_pid(pn_t pcipn)\n{\n    assert(is_pcipn_valid(pcipn), \"pcipn must be valid\");\n    return pci_table[pcipages[pcipn].devid];\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define PTE_PFN_SHIFT 12\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_root` system call is designed to allocate a root entry for an IOMMU (Input-Output Memory Management Unit) page table, which is essential for managing device memory access in virtualized environments. This system call ensures that a device is correctly associated with a process and that its memory access is controlled through a dedicated page table, enhancing security and isolation in systems with multiple devices.\nThe operation begins by checking if the specified device identifier is already associated with a process in the PCI table. If the device is already in use, the system call returns an error, preventing multiple processes from controlling the same device simultaneously. This check ensures exclusive access to the device, which is crucial for maintaining system stability and preventing conflicts.\nNext, the system verifies that the specified memory location represented by the page number is valid and available for allocation. If the memory is not free, the operation is rejected with an error. This validation ensures that the page can be safely used to store the IOMMU page table root without overwriting existing data.\nOnce the initial checks are passed, the system associates the device with the current process. This association is crucial for tracking which process is responsible for managing the device's memory. The system then allocates the memory for the root table, marking it as used and updating the type of the page to the specified IOMMU PML4 table type. The allocation process also updates the process's metadata to reflect the increase in its memory usage. This step ensures that the process's resource usage is accurately tracked, preventing resource leaks and ensuring fair resource distribution. The process's metadata is also updated to reflect the addition of a new device, maintaining accurate records of the resources allocated to the process.    The system then configures the IOMMU device to use the newly allocated root table. This configuration step is essential for enabling the device to access memory through the IOMMU, ensuring that memory accesses are properly translated and protected. Finally, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors.\nIn conclusion, the `sys_alloc_iommu_root` system call is a critical component for managing IOMMU devices. It carefully checks for existing configurations, validates memory availability, and ensures that the device is correctly configured to use the allocated root table. By providing this functionality, the system call enhances the system's ability to manage device memory safely and efficiently, contributing to the overall robustness of the system's memory management architecture.\n",
        "syscall": "sys_alloc_iommu_root",
        "declaration": "int sys_alloc_iommu_root(devid_t devid, pn_t pn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_root(devid_t devid, pn_t pn)\n{\n    if (pci_table[devid])\n        return -EBUSY;\n    if (!is_page_type(pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n\n    pci_table[devid] = current;\n    alloc_page(current, PAGE_TYPE_IOMMU_PML4, pn);\n    --get_proc(current)->nr_devs;\n\n    iommu_set_dev_root(devid, (uintptr_t)get_page(pn));\n    iommu_flush();\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define SZ_64K UINT64_C(0x00010000)\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pdpt` system call is designed to allocate and map a Page Directory Pointer Table (PDPT) entry in the IOMMU (Input-Output Memory Management Unit) page table hierarchy. This operation is crucial for managing device memory access in virtualized environments, where the IOMMU provides address translation and protection for device-initiated memory accesses. The system call ensures that the IOMMU page tables are correctly configured to allow or restrict device access to specific memory regions.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, the root level of the page table hierarchy of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page directory pointer table (PDPT) page. This involves marking the page as belonging to the calling process and designating it as a PDPT page in the page descriptor table. The memory associated with the PDPT page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.   the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors.  \nBy the end of the operation, the IOMMU PDPT page is allocated and mapped, allowing devices to access the specified memory region according to the defined permissions. This setup is essential for enabling secure and efficient device memory access in virtualized systems, where the IOMMU plays a critical role in isolating device memory accesses and preventing unauthorized access.\nIn summary, the `sys_alloc_iommu_pdpt` system call provides a robust mechanism for managing IOMMU page tables, ensuring that device memory accesses are controlled and secure. By validating inputs, configuring mappings, and handling platform-specific adjustments, the system call supports the complex requirements of virtualized environments, enhancing the system's ability to manage device memory access effectively.\n",
        "syscall": "sys_alloc_iommu_pdpt",
        "declaration": "int sys_alloc_iommu_pdpt(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pdpt(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    int r;\n    extern void iommu_hack_root(physaddr_t addr4, physaddr_t addr3);\n\n    r = alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PML4,\n                                    PAGE_TYPE_IOMMU_PDPT);\n    /* hack for qemu (3-level) */\n    if (r == 0 && index == 0)\n        iommu_hack_root((uintptr_t)get_page(from), (uintptr_t)get_page(to));\n    return r;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                        enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                        enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pd` system call is designed to allocate a new page directory (PD) entry in an IOMMU (Input-Output Memory Management Unit) page table hierarchy. This operation is crucial for managing device memory access in virtualized environments, where devices require controlled access to memory regions. The system call ensures that the memory is correctly mapped and accessible with specified permissions, supporting efficient and secure device memory management.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page directory pointer table of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page directory (PD) page. This involves marking the page as belonging to the calling process and designating it as a PD page in the page descriptor table. The memory associated with the PD page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_iommu_pd` system call provides a structured and secure mechanism for allocating and mapping PD pages in an IOMMU page table hierarchy. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling devices to manage their memory access flexibly, which is a cornerstone of modern virtualized system design.\n",
        "syscall": "sys_alloc_iommu_pd",
        "declaration": "int sys_alloc_iommu_pd(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pd(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    return alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PDPT,\n                                       PAGE_TYPE_IOMMU_PD);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                       enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_pt` system call is designed to allocate and map a new page table entry within an IOMMU (Input-Output Memory Management Unit) page table. This operation is crucial for managing device memory access in virtualized environments, where the IOMMU provides isolation and protection by translating device-generated addresses to physical addresses. The system call ensures that the IOMMU page table is correctly configured, allowing devices to access memory securely and efficiently.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page directory of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the page table (PT) page. This involves marking the page as belonging to the calling process and designating it as a PT page in the page descriptor table. The memory associated with the PT page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_iommu_pt` system call provides a secure and efficient mechanism for allocating and mapping IOMMU page table entries. By validating inputs, enforcing permissions, and maintaining the integrity of the IOMMU hierarchy, the system call ensures that device memory access is managed safely and effectively. This functionality is essential for supporting virtualization and device isolation, enabling devices to interact with memory in a controlled and predictable manner.\n",
        "syscall": "sys_alloc_iommu_pt",
        "declaration": "int sys_alloc_iommu_pt(pn_t from, size_t index, pn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_pt(pn_t from, size_t index, pn_t to, iommu_pte_t perm)\n{\n    return alloc_iommu_page_table_page(from, index, to, perm, PAGE_TYPE_IOMMU_PD,\n                                       PAGE_TYPE_IOMMU_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic int alloc_iommu_page_table_page(pn_t from, size_t index, pn_t to, iommu_pte_t perm,\n                                       enum page_type from_type, enum page_type to_type)\n{\n    int r;\n\n    if (!is_page_type(to, PAGE_TYPE_FREE))\n        return -EINVAL;\n    r = map_iommu_page_table_page(from, index, kva2pa(get_page(to)), perm, from_type);\n    if (r)\n        return r;\n\n    alloc_page(current, to_type, to);\n    return 0;\n}\n\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nextern struct page_desc page_desc_table[NPAGE];\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define FREELIST_DEL(arr, member, i)                \\n({                                                  \\n    typeof(&arr->member) entry = &arr[i].member;    \\n    arr[entry->next].member.prev = entry->prev;     \\n    arr[entry->prev].member.next = entry->next;     \\n    entry->next = entry->prev = 0;                  \\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_iommu_frame` system call is used to allocate and map a frame in the IOMMU (Input-Output Memory Management Unit) page table for the current process. The IOMMU allows devices to perform Direct Memory Access (DMA) in a protected and virtualized manner by translating device-visible addresses to physical memory addresses. This system call enables the secure and precise configuration of these mappings, ensuring that devices can access only the memory explicitly permitted by the operating system.\nThe system call begins by attempting to allocate a new page table entry. It checks if the target memory region is valid and unallocated. If the region is already in use, the operation is terminated with an error, as it cannot proceed without a free memory space.\nOnce the target memory is confirmed to be free, the system proceeds to map the specified page into the IOMMU page table at the given index, using the provided permissions. The system then validates the type and ownership of the source memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, page table of an IOMMU, and is owned by the calling process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the permissions associated with the mapping. It checks that the requested permission do not include any unsafe bits in page permissions by comparing it against the permission mask with bits other than permission read and write. If it is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the IOMMU page table to reference the specified physical memory of the target page using the specified IOMMU page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. This step guarantees that devices accessing memory through the IOMMU use the updated mappings, maintaining consistency and correctness.\nOnce the mapping is successfully established, the system proceeds to allocate the frame page. This involves marking the page as belonging to the calling process and designating it as a frame page in the page descriptor table. The memory associated with the frame page is cleared to ensure that it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn summary, the `sys_alloc_iommu_frame` system call provides a secure and reliable mechanism for allocating and mapping frames in the IOMMU page table. It performs rigorous validation of the target frame, the page table, and the requested permissions to ensure correctness and security. By carefully managing the allocation and mapping process, the system call enables protected DMA operations and ensures that devices can access only the memory explicitly authorized by the operating system. This functionality is essential for maintaining memory isolation and security in systems with multiple devices performing DMA.\n",
        "syscall": "sys_alloc_iommu_frame",
        "declaration": "int sys_alloc_iommu_frame(pn_t from, size_t index, dmapn_t to, iommu_pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_iommu_frame(pn_t from, size_t index, dmapn_t to, iommu_pte_t perm)\n{\n    int r;\n    struct page_desc *desc;\n\n    /* check if `to' is free */\n    if (!is_dmapn_valid(to))\n        return -EINVAL;\n    if (!is_dmapage_type(to, PAGE_TYPE_FREE))\n        return -EBUSY;\n    r = map_iommu_page_table_page(from, index, kva2pa(&dmapages[to]), perm, PAGE_TYPE_IOMMU_PT);\n    if (r)\n        return r;\n\n    /* change the type to iommu frame */\n    desc = &dmapage_desc_table[to];\n    desc->type = PAGE_TYPE_IOMMU_FRAME;\n    desc->pid = current;\n    --get_proc(current)->nr_dmapages;\n    return 0;\n}\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\ntypedef uintptr_t physaddr_t;\n#define kva2pa(x) ((physaddr_t)(x))\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic int map_iommu_page_table_page(pn_t from, size_t index, physaddr_t pa, iommu_pte_t perm,\n                                     enum page_type from_type)\n{\n    iommu_pte_t *entries;\n    uint64_t next_level = PAGE_TYPE_IOMMU_FRAME - 1 - from_type;\n\n    if (!is_page_type(from, from_type))\n        return -EINVAL;\n    /* check if current owns from */\n    if (!is_page_pid(from, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* the same as DMAR_PTE_R | DMAR_PTE_W */\n    if (perm & ~(PTE_P | PTE_W))\n        return -EINVAL;\n\n    entries = get_page(from);\n    /* make sure the entry is empty */\n    if (entries[index])\n        return -EINVAL;\n\n    entries[index] = iommu_entry(pa, perm, next_level);\n    /* flush tlb */\n    iommu_flush();\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nuint64_t (*iommu_entry)(uint64_t addr, uint64_t perm, size_t level);\n\nvoid (*iommu_flush)(void);\n\n#define NPROC 64    /* maximum number of processes */\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\nstruct proc proc_table[NPROC] __aligned(PAGE_SIZE);\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_iommu_frame` system call is designed to facilitate the mapping of an IOMMU (Input-Output Memory Management Unit) frame into a process's page table. This operation is crucial in systems that require direct memory access (DMA) by devices, allowing them to interact with memory in a controlled and secure manner. By mapping IOMMU frames, the system ensures that devices can access the necessary memory regions without compromising the integrity or security of the system.\nThe system call begins by validating the validity of the target DMA frame page and ensuring it is of an IOMMU frame type and is owned by the current process. If the frame does not meet these criteria, the operation is terminated with an error, as the mapping cannot proceed without a valid and authorized target.\nOnce the target frame is verified, the system calculates the physical frame number corresponding to the IOMMU frame. This physical frame number represents the actual memory location of the IOMMU frame and is essential for creating the mapping. The system then proceeds to establish the mapping in the page table by updating the appropriate entry to reference the IOMMU frame.\nThe system then establishes the mapping by updating the appropriate entry in the process's page table to reference the IOMMU frame. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the current process to ensure it is valid and active. If not satisfied, the system terminates the operation and signals an error. It also confirms that the process is either the current one or its embryo process.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type, IOMMU frame, and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn summary, the `sys_map_iommu_frame` system call provides a secure and efficient mechanism for mapping IOMMU frames into a process's page table. By validating inputs, enforcing permissions, and maintaining the integrity of the page table, the system call ensures that memory management operations are performed safely and effectively. This functionality is essential for supporting DMA operations and enabling devices to interact with memory in a controlled manner, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_map_iommu_frame",
        "declaration": "int sys_map_iommu_frame(pn_t pt, size_t index, dmapn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_iommu_frame(pn_t pt, size_t index, dmapn_t to, pte_t perm)\n{\n    pn_t pfn;\n\n    /* check if `to' is an iommu frame owned by current */\n    if (is_dmapage_type(to, PAGE_TYPE_IOMMU_FRAME))\n        return -EINVAL;\n    if (!is_dmapage_pid(to, current))\n        return -EACCES;\n\n    pfn = (uintptr_t)dmapages / PAGE_SIZE + to;\n    return map_page(current, pt, index, pfn, perm, PAGE_TYPE_X86_PT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\n/* IOMMU frame pages */\nvolatile uint8_t dmapages[NDMAPAGE][PAGE_SIZE] __aligned(SZ_2M); /* 2M-aligned for PMR */\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\nstatic inline bool is_dmapage_pid(dmapn_t dmapn, pid_t pid)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].pid == pid;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_iommu_frame` system call is designed to reclaim a frame from the IOMMU (Input-Output Memory Management Unit) that was previously allocated to a process. This operation is crucial for freeing up resources that are no longer needed, particularly in scenarios where a process has terminated or is no longer using certain memory frames. The system call ensures that the reclamation process is performed safely and only under appropriate conditions, maintaining system stability and resource integrity.\nThe system call begins by validating the validity of the DMA frame page and ensuring it corresponds to a valid and active frame. If the frame is invalid or is already marked as free, the operation is terminated with an error. This initial validation step is essential to prevent erroneous operations on non-existent or already reclaimed frames.\nOnce the frame number is validated, the system call retrieves the page descriptor associated with the specified frame. This descriptor contains metadata about the frame, including its current type and the process identifier of the owning process. The system call checks the state of the owning process to ensure it is in a terminated state. If it is not satisfied, the operation is rejected with an error. This check is crucial because reclaiming frames from active processes could lead to data corruption or system instability.\nAdditionally, the system verifies that no devices are currently utilizing resources associated with the process that owns the frame. If any devices are in use, the operation is rejected with an error. This check is crucial to maintain system stability, as reclaiming frames in use by devices could lead to data corruption or device malfunctions.\nIf all conditions are satisfied, the system proceeds to reclaim the frame. It updates the target memory frame, marking it as free and removing its association with the previous owner. This update is performed atomically to ensure consistency and prevent race conditions during the operation. The system also updates the process's metadata to reflect the resource reclamation, decrementing the number of DMA pages associated with the process.\nIn conclusion, the sys_reclaim_iommu_frame system call is a vital mechanism for managing memory resources in environments involving memory management units. By enforcing strict validation and ownership checks, the system ensures that frames are reclaimed securely and efficiently, contributing to the overall robustness and flexibility of the system's memory management architecture.\n",
        "syscall": "sys_reclaim_iommu_frame",
        "declaration": "int sys_reclaim_iommu_frame(dmapn_t dmapn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_iommu_frame(dmapn_t dmapn)\n{\n    struct page_desc *desc;\n    pid_t pid;\n\n    if (!is_dmapn_valid(dmapn))\n        return -EINVAL;\n    if (is_dmapage_type(dmapn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    desc = &dmapage_desc_table[dmapn];\n    pid = desc->pid;\n    /* can reclaim pages owned by a zombie */\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    /* don't reclaim anything if any device is in use */\n    if (get_proc(pid)->nr_devs)\n        return -EBUSY;\n\n    desc->type = PAGE_TYPE_FREE;\n    desc->pid = 0;\n    ++get_proc(pid)->nr_dmapages;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_dmapn_valid(dmapn_t dmapn)\n{\n    return dmapn < NDMAPAGE;\n}\n\n#define NDMAPAGE 512 /* maximum number of DMA pages */\n/* IOMMU frame pages */\nvolatile uint8_t dmapages[NDMAPAGE][PAGE_SIZE] __aligned(SZ_2M); /* 2M-aligned for PMR */\nstatic struct page_desc dmapage_desc_table[NDMAPAGE];\n\nstatic inline bool is_dmapage_type(dmapn_t dmapn, enum page_type type)\n{\n    return is_dmapn_valid(dmapn) && dmapage_desc_table[dmapn].type == type;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_iommu_root` system call is designed to reclaim the IOMMU (Input-Output Memory Management Unit) root entry associated with a specific device, identified by its device ID (devid). This operation is crucial in systems where devices are dynamically managed, and resources need to be reallocated or cleaned up when they are no longer in use. The system call ensures that the IOMMU root entry is safely reclaimed, freeing up resources and maintaining system stability.\nThe system call begins by identifying the process associated with the specified device. It then validates the validity of the process and ensures the process is in a terminated state. This validation is essential because resources can only be safely reclaimed from processes that are no longer active, preventing potential conflicts or inconsistencies.\nAdditionally, the system call verifies that the process does not have any active interrupt remapping entries. Interrupt remapping is a feature of the IOMMU that allows interrupts to be dynamically redirected, and active entries indicate ongoing use of the device. If any interrupt remapping entries are present, the system call terminates with an error, as reclaiming the IOMMU root would disrupt active device operations.\nOnce these checks are passed, the system proceeds to decrement the count of devices associated with the process. This step is crucial for maintaining accurate bookkeeping of resources and ensuring that the process's resource usage is correctly reflected in the system's records.\nThe system then updates the device-to-process mapping to indicate that the device is no longer associated with any process. This update is essential for preventing future operations from mistakenly assuming that the device is still in use by the terminated process.\nFinally, the system resets the device's root in the IOMMU. It also invalidates and synchronizes the IOMMU's internal translation caches to ensure that any updates or changes to the IOMMU's page tables or mappings are reflected immediately in the hardware, preventing stale translations from causing errors. By performing these actions, the system ensures that the device is ready for reassignment or reuse by other processes, contributing to the overall efficiency and robustness of the system's resource management.\nIn conclusion, the `sys_reclaim_iommu_root` system call plays a vital role in managing device resources within the IOMMU. By carefully validating process states, checking for dependencies, and updating system records, it ensures that resources are reclaimed safely and efficiently. This functionality is essential for maintaining optimal resource utilization and system stability in environments where devices are frequently reassigned or reconfigured.\n",
        "syscall": "sys_reclaim_iommu_root",
        "declaration": "int sys_reclaim_iommu_root(devid_t devid);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_iommu_root(devid_t devid)\n{\n    pid_t pid = pci_table[devid];\n\n    /* can free a page of a zombie process */\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_proc(pid)->nr_intremaps)\n        return -EBUSY;\n\n    ++get_proc(pid)->nr_devs;\n    pci_table[devid] = 0;\n\n    iommu_reset_dev_root(devid);\n    iommu_flush();\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define SZ_64K UINT64_C(0x00010000)\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_vector` system call is designed to allocate an interrupt vector to the currently running process. Interrupt vectors are crucial in operating systems for handling hardware and software interrupts, allowing processes to be notified and respond to specific events. This system call ensures that a process can claim a vector for its exclusive use, facilitating efficient and organized interrupt handling.\nThe system call begins by checking if the requested vector is already in use. If the vector is occupied, the operation is terminated with an error, as each vector must be unique to ensure proper event handling. This check prevents conflicts and ensures that each process can be distinctly identified by its allocated vector.\nOnce it is confirmed that the vector is available, the system assigns it to the current process. This assignment involves updating a system-wide table that tracks which process is associated with each vector. By maintaining this mapping, the system can efficiently route events or interrupts to the correct process based on the vector.\nAfter successfully assigning the vector, the system increments a counter within the process. This counter keeps track of the number of vectors allocated to the process, providing a mechanism for resource management and ensuring that processes do not exceed their allocation limits.\nIn conclusion, the sys_alloc_vector system call is a fundamental mechanism for associating processes with unique vectors in systems that handle events or interrupts. By ensuring the uniqueness of vectors and maintaining an efficient mapping, the system call facilitates effective event handling and contributes to the overall stability and functionality of the system.\n",
        "syscall": "sys_alloc_vector",
        "declaration": "int sys_alloc_vector(uint8_t vector);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_vector(uint8_t vector)\n{\n    if (vector_table[vector])\n        return -EBUSY;\n\n    vector_table[vector - 4] = current;\n    ++get_proc(current)->nr_vectors;\n    return 0;\n}\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NOFILE 16   /* open files per process */\n/* vector -> pid */\nstatic pid_t vector_table[256];\n#define NPROC 64    /* maximum number of processes */\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_vector` system call is designed to manage interrupt vectors by reclaiming them from processes that are no longer active. This operation is crucial in systems where interrupt vectors are a limited resource, and efficient management is necessary to ensure that they are available for use by active processes. By reclaiming vectors from processes that are in a terminated state, the system can free up these resources for reassignment, maintaining optimal utilization of interrupt handling capabilities.\nThe system call begins by validating the process associated with the specified interrupt vector is valid and in a terminated state. This association is crucial as it determines the ownership and current state of the resources linked to the vector. If the process is not valid or not in a terminated state, the operation is halted with an error. This restriction ensures that only resources from processes that are no longer active can be reclaimed, maintaining system stability and preventing unintended disruptions.\nOnce the process state is verified, the system checks for any outstanding interrupt remapping operations associated with the process. If such operations are present, the system denies the reclaim request with an error. This check ensures that all interrupt remapping activities are completed before resources are reclaimed, preventing potential conflicts or inconsistencies in interrupt handling.\nUpon successful validation of the process state and absence of pending operations, the system proceeds to reclaim the resources. It resets the corresponding mapping from interrupt vectors to processes to reflect the release of the interrupt vector, effectively making it available for future allocations. Additionally, the system decrements the count of active vectors associated with the process, maintaining accurate tracking of resource usage.\nIn summary, the sys_reclaim_vector system call plays a vital role in resource management within the system. By enforcing strict checks on process state and pending operations, it ensures that resources are reclaimed safely and efficiently. This functionality contributes to the overall robustness and flexibility of the system's interrupt management architecture, allowing for dynamic allocation and reclamation of resources as needed.\n",
        "syscall": "sys_reclaim_vector",
        "declaration": "int sys_reclaim_vector(uint8_t vector);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_vector(uint8_t vector)\n{\n    pid_t pid;\n\n    pid = vector_table[vector - 5];\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n    if (get_proc(pid)->nr_intremaps)\n        return -EBUSY;\n\n    vector_table[vector] = 0;\n    --get_proc(pid)->nr_vectors;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_intremap` system call is designed to allocate an interrupt remapping entry, which is crucial for managing hardware interrupts in systems that utilize an I/O Memory Management Unit (IOMMU). This system call ensures that interrupts from specific devices are correctly mapped to the appropriate interrupt vectors, allowing processes to handle hardware events efficiently and securely.\nThe system call begins by verifying the validity and availability of the specified interrupt remapping entry. If the entry is not valid or available, the operation is terminated with an error, as the allocation cannot proceed without a free entry.\nOnce the entry's validity and availability are confirmed, the system checks the ownership of the device and the interrupt vector. It ensures that both the device and the vector are owned by the current process. If either the device or the vector is not owned by the current process, the operation is rejected with an error. This ownership verification is critical to prevent unauthorized access to hardware resources, maintaining system security and integrity.\nAfter confirming ownership, the system proceeds to allocate the interrupt remapping entry. It updates the entry's state to indicate that it is now active and associates it with the specified device and vector. This association ensures that future interrupts from the device are correctly mapped to the specified vector, allowing the process to handle them appropriately.\nThe system also updates the process to reflect the allocation of the interrupt remapping entry. This update is essential for tracking the number of active remapping entries associated with the process, facilitating resource management and accounting.\nFinally, the system configures the hardware to establish the interrupt remapping. This configuration ensures that the hardware is aware of the new mapping, allowing interrupts to be delivered according to the specified configuration. By performing this step, the system ensures that the interrupt remapping is fully operational and effective.\nIn conclusion, the sys_alloc_intremap system call provides a mechanism for processes to allocate and manage interrupt remapping entries. It enforces strict ownership checks, updates system state, and configures hardware to ensure that interrupts are correctly mapped and handled. This capability is vital for systems requiring precise control over interrupt delivery, contributing to the overall robustness and efficiency of the system's interrupt management architecture.\n",
        "syscall": "sys_alloc_intremap",
        "declaration": "int sys_alloc_intremap(size_t index, devid_t devid, uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_intremap(size_t index, devid_t devid, uint8_t vector)\n{\n    struct intremap *ir;\n\n    if (!is_intremap_state(index, IR_FREE))\n        return -EINVAL;\n    /* is the device owned by current */\n    if (pci_table[devid] != current)\n        return -EACCES;\n    /* is the vector owned by current */\n    if (vector_table[vector] != current)\n        return -EACCES;\n\n    ir = &intremap_table[index];\n    ir->state = IR_ACTIVE;\n    ir->devid = devid;\n    ir->vector = vector;\n    --get_proc(current)->nr_intremaps;\n    iommu_set_intremap(index, devid, vector);\n    return 0;\n}\n\nenum intremap_state {\n    IR_FREE = 0,\n    IR_ACTIVE,\n\n    IR_FORCE_WIDTH = ~UINT64_C(0),\n};\n\nstruct intremap {\n    enum intremap_state state;\n    devid_t devid;\n    uint8_t vector;\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define SZ_64K UINT64_C(0x00010000)\n#define NPROC 64    /* maximum number of processes */\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\n#define NINTREMAP 8 /* maximum number of interrupt remapping entries */\n\nstatic struct intremap intremap_table[NINTREMAP];\n\nstatic inline int is_intremap_state(size_t index, enum intremap_state state)\n{\n    return is_intremap_valid(index) && intremap_table[index].state == state;\n}\n\nstatic inline int is_intremap_valid(size_t index)\n{\n    return index < NINTREMAP;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_intremap` system call is designed to manage and reclaim interrupt remapping entries within the system. This operation is crucial for maintaining efficient use of interrupt remapping resources, which are essential for handling hardware interrupts in a virtualized environment. By reclaiming unused or obsolete entries, the system can optimize resource allocation and ensure that interrupt handling remains efficient and effective.\nThe system call begins by verifying the validity and the state of the specified interrupt remapping entry. It checks whether the entry is valid and currently active, as only active entries are eligible for reclamation. If the entry is not valid or active, the operation is terminated with an error, preventing any unintended modifications to inactive or already reclaimed entries.\nOnce the entry's state is validated, the system retrieves the associated process identifier from the interrupt remapping table. This identifier is crucial for determining the ownership and current state of the process linked to the entry. The system then checks the validity and the state of the process to ensure it is valid and in a terminated condition. This restriction ensures that only entries associated with processes that are no longer active can be reclaimed, maintaining system stability and preventing disruptions to active processes.\nIf the process state is verified, the system proceeds to update the interrupt remapping entry. It marks the entry as free, effectively releasing it for future use. Additionally, it clears any associated identifiers or vectors, ensuring that the entry is completely reset and ready for reassignment. This step is crucial for maintaining the integrity of the interrupt remapping table and preventing any residual data from affecting future operations.\nThe system then updates the process's metadata to reflect the decrease in the number of active interrupt remapping entries. This update ensures that the process's resource usage is accurately tracked, allowing the system to manage resources effectively and prevent any potential over-allocation or resource leaks.\nFinally, the system triggers a mechanism to reset the hardware state associated with the reclaimed entry. This step ensures that any hardware configurations related to the entry are cleared, preventing any unintended behavior or conflicts in future operations. By resetting the hardware state, the system maintains consistency between software and hardware configurations, ensuring reliable and predictable interrupt handling.\nIn conclusion, the `sys_reclaim_intremap` system call is a vital component for managing interrupt remapping resources within the system. It carefully validates the state of entries and processes, updates system tables and descriptors, and ensures hardware consistency. By providing this functionality, the system call contributes to the efficient and effective management of interrupt handling resources, enhancing the overall performance and reliability of the system's virtualized environment.\n",
        "syscall": "sys_reclaim_intremap",
        "declaration": "int sys_reclaim_intremap(size_t index);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_intremap(size_t index)\n{\n    struct intremap *ir;\n    pid_t pid;\n\n    if (!is_intremap_state(index, IR_ACTIVE))\n        return -EINVAL;\n\n    ir = &intremap_table[index - 5];\n    pid = pci_table[ir->devid];\n    /* can only reclaim a zombie's IRTE */\n    if (!is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n\n    ir->state = IR_FREE;\n    ir->devid = 0;\n    ir->vector = 0;\n    --get_proc(pid)->nr_intremaps;\n    iommu_reset_intremap(index);\n    return 0;\n}\n\nenum intremap_state {\n    IR_FREE = 0,\n    IR_ACTIVE,\n\n    IR_FORCE_WIDTH = ~UINT64_C(0),\n};\n\nstruct intremap {\n    enum intremap_state state;\n    devid_t devid;\n    uint8_t vector;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define SZ_64K UINT64_C(0x00010000)\n\n/* pci devid -> pid */\nstatic pid_t pci_table[SZ_64K];\n\n/* vector -> pid */\nstatic pid_t vector_table[256];\n\nstatic struct intremap intremap_table[NINTREMAP];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline int is_intremap_state(size_t index, enum intremap_state state)\n{\n    return is_intremap_valid(index) && intremap_table[index].state == state;\n}\n\n#define NINTREMAP 8 /* maximum number of interrupt remapping entries */\n\nstatic inline int is_intremap_valid(size_t index)\n{\n    return index < NINTREMAP;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n#define NPROC 64    /* maximum number of processes */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_ack_intr` system call is designed to acknowledge and clear a specific interrupt for the currently running process. This operation is crucial in systems where processes need to manage and respond to multiple interrupts efficiently. By acknowledging an interrupt, the process indicates that it has handled the event associated with the interrupt vector, allowing the system to clear the interrupt state and prevent redundant handling.\nThe system call begins by retrieving the descriptor of the currently executing process. This descriptor contains crucial information about the process, including its interrupt status. The interrupt status is a bitset that tracks which interrupts are currently active for the process. By accessing this status, the system can determine which interrupts need to be acknowledged and cleared.\nOnce the process descriptor is obtained, the system proceeds to clear the specified interrupt from the process's interrupt status. This is achieved by manipulating the bitset to remove the bit corresponding to the interrupt. By clearing this bit, the system effectively acknowledges that the interrupt has been handled and should no longer be considered active for the process.\nThe operation is performed atomically to ensure consistency and prevent race conditions. This atomicity is crucial in a multi-threaded or multi-core environment, where multiple processes or threads might be interacting with the interrupt status simultaneously. By ensuring that the operation is atomic, the system maintains the integrity of the interrupt status and prevents any potential conflicts or inconsistencies.\nIn conclusion, the `sys_ack_intr` system call is a vital component in the management of interrupt-driven events within a process. By providing a mechanism to acknowledge and clear interrupts, it ensures that processes can efficiently handle and respond to interrupt events without redundancy or instability. This capability contributes to the overall robustness and reliability of the system's interrupt management architecture.\n",
        "syscall": "sys_ack_intr",
        "declaration": "int sys_ack_intr(uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_ack_intr(uint8_t v)\n{\n    struct proc *proc = get_proc(current + 4);\n\n    bit_clear(v, proc->intr);\n    return 0;\n}\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPROC 64    /* maximum number of processes */\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n#define _BITSET_BITS       (sizeof(unsigned long) * 8)\n\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_clear(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] &= ~__bitset_mask(n);\n}\n```\n",
        "bug_type": "buffer overflow",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_port` system call is designed to allocate an I/O port to a process, allowing it to perform input/output operations on that port. This functionality is crucial in systems where processes need direct access to hardware resources, such as peripheral devices, through specific I/O ports. The system call ensures that port allocation is managed securely and efficiently, preventing conflicts and unauthorized access.\nThe system call begins by checking if the requested port is already in use. If the port is occupied, the operation is terminated with an error, indicating that the port is unavailable for allocation. This check prevents conflicts and ensures that each port is uniquely assigned to a single process at any given time.\nOnce the port's availability is confirmed, the system verifies whether the process is permitted to use the I/O bitmap. If the process lacks this permission, the operation is rejected with an error. This restriction ensures that only authorized processes can allocate ports, maintaining system security and stability.\nIf the process is authorized, the system proceeds to allocate the port by marking it as taken by the current process. It updates the I/O bitmap of the process to clear the bit corresponding to the allocated port, effectively granting the process access to the port. The bitmap is divided into two sections, and the system determines which section to update based on the port number. This update ensures that the process has the necessary permissions to access the allocated port.\nFinally, the system increments the count of ports allocated to the process, reflecting the successful allocation. The operation concludes with a success status, indicating that the port has been successfully allocated to the process.\nIn summary, the sys_alloc_port system call is a critical mechanism for managing I/O port allocations in a secure and efficient manner. It ensures that ports are uniquely assigned, verifies process permissions, and updates the process's I/O bitmap to reflect the allocation. By providing this functionality, the system call supports processes in performing direct hardware interactions, contributing to the overall flexibility and capability of the system's I/O management.\n",
        "syscall": "sys_alloc_port",
        "declaration": "int sys_alloc_port(uint16_t port);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_port(uint16_t port)\n{\n    struct proc *proc;\n\n    if (io_table[port])\n        return -EBUSY;\n\n    proc = get_proc(current);\n    if (!proc->use_io_bitmap)\n        return -EACCES;\n\n    io_table[port] = current;\n    if (port < 0x8000)\n        bit_clear(port, get_page(proc->io_bitmap_a));\n    else\n        bit_clear(port - 0x8000, get_page(proc->io_bitmap_b));\n    --proc->nr_ports;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define SZ_64K UINT64_C(0x00010000)\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\n/*\n * Map port to owner pid:\n * 0: free\n * -1: reserved by kernel\n * others: taken by pid\n */\nstatic pid_t io_table[SZ_64K];\n\n#define _BITSET_BITS       (sizeof(unsigned long) * 8)\n\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_clear(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] &= ~__bitset_mask(n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_reclaim_port` system call is designed to manage the ownership of I/O ports by reclaiming ports that were previously allocated to processes that are no longer active. This functionality is crucial in systems where I/O ports are a limited resource and need to be efficiently managed and reallocated as processes terminate or become inactive. The system call ensures that ports are only reclaimed from processes that are in a specific state, maintaining system integrity and preventing unauthorized access to I/O resources.\nThe system call begins by identifying the process associated with the specified resource. It retrieves the identifier of the process that currently holds the resource. This step is crucial for determining the ownership and state of the resource.\nOnce the process identifier is obtained, the system verifies the validity and the state of the process to ensure it is in a terminated condition that allows resource reclamation. If the process is not valid or in the required state, the operation is terminated with an error. This check prevents unauthorized access and ensures that only resources from processes in the appropriate state can be reclaimed.\nIf the process is in the correct state, the system proceeds to release the resource. It resets and clears the owner process of the resource to indicate that the resource is now available for allocation. This step is performed without the need to modify any additional process-specific configurations, simplifying the reclamation process.\nFinally, the system decrements the count of ports allocated to the process, reflecting the successful resource reclamation. It decrements the count of resources held by the process, ensuring that the process's resource usage is accurately tracked. This update is crucial for maintaining an accurate record of resource distribution across the system.\nIn summary, the `sys_reclaim_port` system call provides a mechanism for reclaiming resources from processes that are no longer actively using them. By enforcing strict checks on process state and updating resource management structures, the system ensures that resources are efficiently recycled and made available for future use. This contributes to the overall stability and performance of the system's resource management framework.\n",
        "syscall": "sys_reclaim_port",
        "declaration": "int sys_reclaim_port(uint16_t port);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_reclaim_port(uint16_t port)\n{\n    pid_t pid = io_table[port];\n\n    if (is_proc_state(pid, PROC_ZOMBIE))\n        return -EACCES;\n\n    io_table[port] = 0;\n    /* no need to clear per-process I/O bitmap */\n    --get_proc(pid)->nr_ports;\n    return 0;\n}\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define SZ_64K UINT64_C(0x00010000)\n#define NPROC 64    /* maximum number of processes */\n\nextern struct proc proc_table[NPROC];\n\n/*\n * Map port to owner pid:\n * 0: free\n * -1: reserved by kernel\n * others: taken by pid\n */\nstatic pid_t io_table[SZ_64K];\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_alloc_pdpt` system call is responsible for allocating a new Page Directory Pointer Table (PDPT) entry in a process's hierarchical page table, which is a critical structure in managing virtual memory. This system call involves mapping a newly allocated memory page to the next level in the page table hierarchy, ensuring that the memory is correctly configured and accessible with the specified permissions. The operation supports dynamic memory allocation for processes, enabling them to expand or modify their virtual address space as needed.\nThe operation begins by validating the target page designated for the page directory pointer table is valid and free to allocate. If not satisfied, the operation is terminated with an error, as the allocation cannot proceed without a valid target.\nOnce the target location is verified, the system calculates the physical memory location that will be used for the new page directory pointer table entry. This physical location is essential for creating the mapping and ensuring that the new entry is correctly linked within the process's memory management structure.\nThe system then establishes the mapping by updating the appropriate entry in the higher-level table, i.e. PML4, to point to the newly allocated page directory pointer table page. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page is a valid page, which corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the source page from the page number and verifies that the specified entry is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the specified physical memory using the specified page table entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nAfter successfully establishing the mapping, the system proceeds to allocate the PDPT page. This involves marking the page as belonging to the process and designating it as a PDPT in the page descriptor table. The memory associated with the page is cleared to ensure it starts in a clean state, free of any residual data that might compromise security or functionality. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nIn conclusion, the `sys_alloc_pdpt` system call provides a structured and secure mechanism for allocating and mapping PDPT pages in a process's virtual memory space. By validating inputs, enforcing permissions, and maintaining the integrity of the page table hierarchy, the system call ensures that memory management operations are performed safely and efficiently. This functionality is essential for supporting dynamic memory allocation and enabling processes to manage their virtual address space flexibly, which is a cornerstone of modern operating system design.\n",
        "syscall": "sys_alloc_pdpt",
        "declaration": "int sys_alloc_pdpt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_pdpt(pid_t pid, pn_t from, size_t index, pn_t to, pte_t perm)\n{\n    return alloc_page_table_page(pid, from, index, to, perm, PAGE_TYPE_X86_PML4,\n                                 PAGE_TYPE_X86_PDPT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic int alloc_page_table_page(pid_t pid, pn_t from_pn, size_t index, pn_t to_pn, pte_t perm,\n                                 enum page_type from_type, enum page_type to_type)\n{\n    int r;\n    pn_t pfn;\n\n    if (!is_page_type(to_pn, PAGE_TYPE_FREE))\n        return -EINVAL;\n    pfn = pn_to_pfn(to_pn);\n    r = map_page(pid, from_pn, index, pfn, perm, from_type);\n    if (r)\n        return r;\n    /* alloc_page always succeeds so it's okay to call it after map_page */\n    alloc_page(pid, to_type, to_pn);\n    return 0;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n#define PTE_PFN_SHIFT 12\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc;\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\n#define PTE_P BIT64(0)   /* present */\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* update the page table */\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe sys_free_pdpt system call is responsible for freeing a specific entry in a page table hierarchy by deallocating a page directory pointer table (PDPT) page and cleaning up its reference within a higher-level page table. This operation is an essential part of dynamic memory management in virtual memory systems, where hierarchical page tables are used to manage address mappings. The system call ensures that the memory associated with a PDPT page is properly released and no longer accessible, while maintaining the integrity of the page table structure.\nThe system call begins by validating that the source page directory pointer table is valid and is of the correct type, a Page Map Level 4 type. It also validates that the source PML4 page table belongs to the calling process. It ensures that the PML4 page table corresponds to the expected type and is owned by the current process. If these conditions are not met, the operation is terminated with an error, preventing unauthorized or incorrect modifications to the page table hierarchy.\nNext, the system verifies the validity of the specified index within the PML4 page table, each of which points to PDPT page. This check ensures that the operation targets a valid entry within the PML4 page table, preventing out-of-bounds access that could lead to memory corruption. If the index is invalid, the system rejects the operation with an error.\nThe system then validates the target page directory pointer table is valid and is of the correct type, a Page Directory Pointer Table. It ensures that the target page directory pointer table corresponds to the expected type and is owned by the current process. This step is crucial for maintaining the integrity of the memory hierarchy and preventing unauthorized access to memory regions.\nOnce all validations are complete, the system retrieves the PML4 page table entries and checks if the specified slot is valid and present. If the entry is empty, the operation is terminated with an error, as there is no mapping to release. This check prevents unnecessary operations and ensures that only valid mappings are removed.\nThe system further verifies that the existing PML4 page table entry corresponds to the specified page directory pointer table by checking if the physical frame number derived from the PML4 page table entry matches the page directory pointer table's expected physiscal address.  This ensures that the correct mapping is being released, preventing accidental removal of unrelated mappings. If the entry does not match, the operation is terminated with an error.\nOnce the validations are complete, the system proceeds to free the PDPT page. The owner process of the page is reset and the type of the freed page is set to the expected type. The free process also updates the process's metadata to reflect the decrease in its memory usage, maintaining accurate records for resource tracking and management. Furthermore, the PML4 page table entry associated with the released memory is cleared by setting the corresponding entry to zero. This effectively removes the PDPT from the page table hierarchy, invalidating any address mappings associated with it. To ensure that the changes take effect immediately, the system invalidates the Translation Lookaside Buffer (TLB) for the current process. The TLB is a cache of recently used address mappings, and invalidating it ensures that stale mappings are not used after the PD is freed.\nBy the end of the operation, the specified PDPT page is fully deallocated, and its entry in the PML4 table is cleared. This allows the resources to be reused for other purposes while maintaining the consistency of the page table hierarchy. The sys_free_pdpt system call, therefore, is a critical component of memory management, allowing processes to dynamically release memory when it is no longer needed. Its design ensures that memory is safely deallocated, preventing resource leaks and ensuring that mappings remain consistent and secure.\n",
        "syscall": "sys_free_pdpt",
        "declaration": "int sys_free_pdpt(pn_t from, size_t index, pn_t to);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_free_pdpt(pn_t from, size_t index, pn_t to)\n{\n    return free_page_table_page(from, index, to, PAGE_TYPE_X86_PML4, PAGE_TYPE_X86_PDPT);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\nstatic int free_page_table_page(pn_t from_pn, size_t index, pn_t to_pn, enum page_type from_type,\n                                enum page_type to_type)\n{\n    pte_t *entries;\n\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    if (!is_page_pid(from_pn, current))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    if (!is_page_type(to_pn, to_type))\n        return -EINVAL;\n    if (!is_page_pid(to_pn, current))\n        return -EACCES;\n\n    entries = get_page(from_pn);\n    /* check if the slot is empty */\n    if (!pte_valid(entries[index]))\n        return -EINVAL;\n    /* check if the entry matches */\n    if (pn_to_pfn(to_pn) != (PTE_ADDR(entries[index]) >> PAGE_SHIFT))\n        return -EINVAL;\n\n    /* release the next-level page */\n    free_page(to_pn);\n    /* wipe the entry */\n    entries[index] = 0;\n    hvm_invalidate_tlb(current);\n\n    return 0;\n}\n\n#define PTE_ADDR(pte) ((physaddr_t)(pte)&BITMASK64(51, 12))\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\n/* insert new after head */\n#define FREELIST_ADD(arr, member, new, head)        \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = ehead->next;                       \\\n    enew->prev = head;                              \\\n    arr[enew->next].member.prev = new;              \\\n    ehead->next = new;                              \\\n})\n\nvoid free_page(pn_t pn)\n{\n    struct page_desc *desc;\n    pid_t pid = desc->pid;\n\n    assert(!is_page_type(pn, PAGE_TYPE_FREE), \"must not be a free page\");\n    desc->pid = 0;\n    desc->type = PAGE_TYPE_FREE;\n\n    if (pn != 0)\n        FREELIST_ADD(page_desc_table, link, pn, 0);\n\n    if (pid)\n        --get_proc(pid)->nr_pages;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "incorrect pointer",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `clone_proc` system call facilitates the creation of a new process by duplicating key aspects of an existing process, such as its memory layout, execution state, and kernel stack. This functionality is fundamental to multitasking operating systems, allowing new processes to be created either as independent entities or as lightweight threads that share certain resources with their parent. The clone_proc function, which implements this system call, ensures that the new process is correctly initialized and inherits the necessary context to execute seamlessly.\nThe system call begins by allocating resources for the new process. It first validates the validity and the state of the specified process. If the process if invalid or not unused, the operation is rejected with an error. It then ensures that the necessary memory pages for the process's page table root, stack, and hardware state are valid and unallocated. If any of these resources are not valid,unavailable, or already in use, the operation is terminated with an error, preventing resource conflicts and ensuring system stability. Also, the system validates the process's page table root, stack, and hardware state are unique to each other. If any two of them are identical, the operation is rejected with an error.\nOnce the validations are complete, the system initializes the new process's descriptor, setting its parent process identifier and marking it as in the embryonic state. This state indicates that the process is in the initial stages of creation and not yet fully operational. The system also allocates and initializes pages for the page table root, stack and hvm with the corresponding page type and then updates the current process's metadata to reflect the increase of pages allocated for the specified process. The metadata of the process's parent process is also updated to reflect the increase of its child processes.\nThe system then duplicates the current process's execution context. It copies all the data of the kernel stack, which contains saved registers and execution state, to the new process's stack. This ensures that the new process begins execution with the same context as the parent process, allowing it to continue from the same point in the program.\nNext, the system copies the hardware virtual machine (HVM) state from the current process to the new process. This involves flushing the stale mappings to ensure consistency and copy data from the parent HVM to the child HVM state specified. This step is crucial for maintaining the execution environment, as it includes processor state and other critical hardware configurations.\nAfter duplicating the execution context, the system prepares the new process for execution.\nFinally, the system returns control to the user space, allowing the new process to begin execution. The new process starts with the same execution context as the parent, enabling it to perform tasks independently while sharing the same initial state.\nIn summary, the `clone_proc` system call is a vital mechanism for process creation in operating systems. It carefully allocates resources, duplicates execution context, and prepares the new process for execution, ensuring a seamless and efficient process creation experience. By providing this functionality, the system call supports multitasking and process management, contributing to the overall robustness and flexibility of the operating system.\n",
        "syscall": "clone_proc",
        "declaration": "int sys_clone(pid_t pid, pn_t pml4, pn_t stack, pn_t hvm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint clone_proc(pid_t pid, pn_t pml4, pn_t stack, pn_t hvm)\n{\n    int r;\n    struct proc *proc;\n    void *parent_hvm, *child_hvm;\n\n    r = alloc_proc(pid, pml4, stack, hvm);\n    if (r)\n        return r;\n\n    proc = get_proc(current);\n\n    /* copy the kernel stack (saved registers) */\n    memcpy(get_page(stack), get_page(proc->stack), PAGE_SIZE);\n\n    parent_hvm = get_page(proc->hvm);\n    child_hvm = get_page(hvm);\n    /* copy hvm state */\n    flush_current();\n    hvm_flush(child_hvm);\n    memcpy(child_hvm, parent_hvm, PAGE_SIZE);\n    hvm_copy(child_hvm, parent_hvm, pid);\n\n    /* will call run_current() upon return */\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nint alloc_proc(pid_t pid, pn_t page_table_root, pn_t stack, pn_t hvm)\n{\n    struct proc *proc, *parent;\n\n    if (!is_proc_state(pid, PROC_UNUSED))\n        return -ENOMEM;\n    if (is_page_type(page_table_root, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (!is_page_type(stack, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (!is_page_type(hvm, PAGE_TYPE_FREE))\n        return -ENOMEM;\n    if (page_table_root == stack)\n        return -EINVAL;\n    if (page_table_root == hvm)\n        return -EINVAL;\n    if (stack == hvm)\n        return -EINVAL;\n\n    proc = get_proc(pid);\n    bzero(proc, sizeof(*proc));\n    proc->ppid = current;\n    proc->state = PROC_EMBRYO;\n\n    alloc_page(pid, PAGE_TYPE_X86_PML4, page_table_root);\n    proc->page_table_root = page_table_root;\n\n    alloc_page(pid, PAGE_TYPE_PROC_DATA, stack);\n    proc->stack = stack;\n\n    alloc_page(pid, PAGE_TYPE_PROC_DATA, hvm);\n    proc->hvm = hvm;\n\n    parent = get_proc(current);\n    ++parent->nr_children;\n\n    return 0;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* called in entry.S */\nvoid flush_current(void)\n{\n    struct proc *proc;\n    void *hvm;\n\n    proc = get_proc(current);\n    hvm = get_page(proc->hvm);\n    hvm_flush(hvm);\n    proc->launched = 0;\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `send_proc` system call facilitates one-way interprocess communication (IPC) by enabling a process (the sender) to deliver data and control information to another process (the receiver). This mechanism is particularly useful in scenarios where a server process is waiting to handle requests or data from client processes. The system ensures secure and synchronized communication by validating inputs, transferring data, and transitioning the states of the involved processes appropriately.\nThe system call begins by validating the validity of the target process and ensuring that it is in a sleeping state. If the target process is not valid or in the appropriate state, the operation is aborted with an error, as data cannot be sent to a process that is not ready to receive it.\nOnce the target process is verified, the system checks the validity and the ownership of the memory region from which data will be sent. This involves ensuring that the memory page is valid and belongs to the sending process and that the specified size does not exceed the allowable limit. If these conditions are not met, the operation is terminated with an error, preventing unauthorized access or buffer overflows.\nIf the file descriptor is included, it must be either invalid, indicating the file descriptor is not in use, or valid and associated with an open file. If the file descriptor is valid but not associated with an open file, the operation is rejected with an error.\nAfter all validations are complete, the system retrieves the descriptors for both the sending and receiving processes. It then updates the receiving process's state to reflect the incoming data, including the source process, the data value, and the size of the data. The system ensures that the memory region designated for receiving data is valid and owned by the target process, maintaining memory integrity.\nThe data is then copied from the sending process's memory to the receiving process's designated memory region. This operation is performed securely to prevent data corruption or unauthorized access.\nIf the file descriptor provided and the receiver's file descriptor are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nFinally, the system updates the states of both processes to reflect the completion of the data transfer. The sending process is marked as ready to run, while the receiving process is transitioned to a running state. This ensures that the receiving process can immediately begin processing the received data. And then the current process is switched to the receiving process.\nIn conclusion, the `send_proc` system call is a vital mechanism for enabling efficient and secure data exchange between processes. By enforcing strict validations and ensuring proper state transitions, the system call maintains the integrity and reliability of inter-process communication within the operating system.\n",
        "syscall": "send_proc",
        "declaration": "int sys_send(pid_t pid, uint64_t val, pn_t pn, size_t size, int fd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint send_proc(pid_t pid, uint64_t val, pn_t pn, size_t size, int fd)\n{\n    struct proc *sender, *receiver;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    if (is_pn_valid(pn))\n        return -EINVAL;\n    /* pn doesn't have to be a frame */\n    if (!is_page_pid(pn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    if (is_fd_valid(fd)) {\n        if (!is_fn_valid(get_fd(current, fd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    receiver->ipc_size = size;\n    /* invariant: proc->ipc_page is a valid page owned by pid */\n    memcpy(get_page(receiver->ipc_page), get_page(pn), size);\n    /* invariant: ipc_fd is empty if it's valid */\n    if (is_fd_valid(fd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, fd));\n\n    sender->state = PROC_RUNNABLE;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    current = pid;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPROC 64    /* maximum number of processes */\n#define NPAGE 8192  /* maximum number of pages */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n\nstruct file file_table[NFILE] __aligned(PAGE_SIZE);\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `reply_wait_proc` system call implements a two-way communication mechanism between a client and a server process, enabling a client to send data and wait for a response from the server. The system ensures that the server is in a specific state to handle the request while maintaining proper synchronization and resource allocation. This functionality is crucial for interprocess communication (IPC) in operating systems where processes must exchange data or signals in a controlled and coordinated manner.\nThe system call begins by verifying the validity of the target process and ensuring it is in the sleeping state, indicating readiness to receive data. If the target process is not valid or is actively running, the system call terminates with an error.\nNext, the system validates the validity of the input page and the output page. It also validates that the input and output pages belong to the calling process. The type of the output page should be the correct frame page and the size of the data must not exceed the limits of a memory page. Any violations to these constriants will make the operation to terminate with an error.\nThe system then validates that the input and output file descriptor is either invalid or non-empty and the output file descriptor is either invalid or empty. The output file descriptor is set to invalid to indicate that no output file descriptor is used in the operation. If these conditions are not met, the operation is rejected with an error. These checks ensure that communication adheres to system constraints and prevents unauthorized access.\nThe system then sets up the communication. It sets the current process as the sender process and the target process as the receiver process. It then validates that the receiver process wants to accept the other process's requests. If the condition is not met, the operation is rejected with an error. The sender process then prepares to send its request by specifying the data to be transferred and optional resources such as file descriptors. The receiver process prepares to receive this data by specifying the source process that the data is from and the specific control value. The system then securely transfers the page of data from the input page to the designated page of the receiver process within the specified size limit and updates the transferred size for the receiver process. establishing the memory location (outpn) where the input data will be copied, ensuring that the receiver can process the request without needing additional access to the sender's resources. If the input file descriptor and the file descriptor of the receiver process are valid, the system updates the receiving process's file descriptor table to include the file descriptor from the sending process. This allows the receiving process to access the file associated with the descriptor, facilitating resource sharing between processes. Accordingly, the system updates the metadata of the process and the file to reflect the open status of the file in a new process.\nAfter the data and resources are transferred, the system transitions control between the two processes. The sender process is placed into a sleeping state, indicating that it is waiting for the receiver to complete its task. At the same time, the receiver process is transitioned to a running state, allowing it to process the request immediately. This context switch ensures that the receiver begins handling the request without delay while the sender remains blocked until the receiver completes its task. The state transition is carefully managed to maintain system stability and prevent race conditions or deadlocks.\nFinally, the system ensures the current process is set to accept IPC communication from the specified process and then switches the current process context to the specified process.\nIn summary, the `reply_wait_proc` system call is used to facilitate interprocess communication where a process replies to a waiting process (receiver) and simultaneously prepares itself to wait for further communication. It validates inputs, securely transfers data (including optional file descriptors), and updates process states to ensure the sender transitions to sleeping (waiting) while the receiver is activated. This system call is critical in managing synchronous communication between processes, enabling efficient data exchange and coordinated execution in the operating system.",
        "syscall": "reply_wait_proc",
        "declaration": "int sys_reply_wait(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint reply_wait_proc(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn)\n{\n    int r;\n\n    r = send_recv(pid, val, inpn, size, infd, outpn, -1);\n    if (r)\n        return r;\n    /* accept any ipc */\n    get_proc(current)->ipc_from = 0;\n    current = pid;\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define NPAGE 8192  /* maximum number of pages */\n\nstatic int send_recv(pid_t pid, uint64_t val, pn_t inpn, size_t size, int infd, pn_t outpn,\n                     int outfd)\n{\n    struct proc *sender, *receiver;\n\n    /* target process must be sleeping */\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_proc_state(pid, PROC_SLEEPING))\n        return -EAGAIN;\n    /* check in page */\n    if (!is_pn_valid(inpn))\n        return -EINVAL;\n    /* inpn doesn't have to be a frame */\n    if (!is_page_pid(inpn, current))\n        return -EACCES;\n    if (size > PAGE_SIZE)\n        return -EINVAL;\n    /* check in fd: either invalid or non-empty */\n    if (is_fd_valid(infd)) {\n        if (!is_fn_valid(get_fd(current, infd)))\n            return -EINVAL;\n    }\n    /* check out page */\n    if (!is_pn_valid(outpn))\n        return -EINVAL;\n    if (!is_page_pid(outpn, current))\n        return -EACCES;\n    if (!is_page_type(outpn, PAGE_TYPE_FRAME))\n        return -EINVAL;\n    /* check out fd: either invalid or empty */\n    if (is_fd_valid(outfd)) {\n        if (is_fn_valid(get_fd(current, outfd)))\n            return -EINVAL;\n    }\n\n    assert(pid != current, \"current is running and pid is sleeping\");\n\n    sender = get_proc(current);\n    receiver = get_proc(pid);\n\n    /* check if the receiver wants to accept anyone's request */\n    if (receiver->ipc_from && receiver->ipc_from != current)\n        return -EACCES;\n\n    /* client: prepare for response */\n    sender->ipc_page = outpn;\n    sender->ipc_fd = outfd;\n\n    /* server: transfer data from client */\n    receiver->ipc_from = current;\n    receiver->ipc_val = val;\n    /* transfer the page */\n    memcpy(get_page(receiver->ipc_page), get_page(inpn), size);\n    receiver->ipc_size = size;\n    /* transfer the fd */\n    if (is_fd_valid(infd) && is_fd_valid(receiver->ipc_fd))\n        set_fd(pid, receiver->ipc_fd, get_fd(current, infd));\n\n    /* switch control */\n\n    sender->state = PROC_SLEEPING;\n    receiver->state = PROC_RUNNING;\n    /* receiver: sleeping -> running */\n    proc_ready_add(receiver);\n    /* sender: running -> sleeping */\n    proc_ready_del(sender);\n    return 0;\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline bool is_proc_state(pid_t pid, enum proc_state state)\n{\n    return is_pid_valid(pid) && get_proc(pid)->state == state;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\n/* insert new before head */\n#define FREELIST_ADD_TAIL(arr, member, new, head)   \\\n({                                                  \\\n    typeof(&arr->member) enew = &arr[new].member;   \\\n    typeof(&arr->member) ehead = &arr[head].member; \\\n    enew->next = head;                              \\\n    enew->prev = ehead->prev;                       \\\n    arr[enew->prev].member.next = new;              \\\n    ehead->prev = new;                              \\\n})\n\nstatic inline void proc_ready_add(struct proc *proc)\n{\n    FREELIST_ADD_TAIL(proc_table, ready, proc - proc_table, current);\n}\n\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline void proc_ready_del(struct proc *proc)\n{\n    FREELIST_DEL(proc_table, ready, proc - proc_table);\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_dup2` system call provides a mechanism for duplicating a file descriptor from one process to another or within the same process. This operation is essential for managing file descriptor tables, allowing processes to redirect input/output streams or share file descriptors between processes. By duplicating a file descriptor, a process can create an alias for an existing file descriptor, enabling flexible file management and inter-process communication.\nThe system call begins by validating the specified process identifier to ensure it corresponds to a valid and active process. If the process identifier is invalid, the operation is terminated with an error, as the duplication cannot proceed without a valid target. The system also checks that the process is either the current one or its embryo process, ensuring that the operation is authorized.\nNext, the system verifies the validity of the source file descriptor within the current process. It also validates the source file descriptor exists in the calling process. If the source file descriptor is invalid or does not exist in the calling process, the operation is rejected with an error. This check ensures that the duplication operation is based on a valid file descriptor, preventing errors or undefined behavior.\nThe system then checks the validity of the target file descriptor. If the target file descriptor is invalid, the operation is terminated with an error. This validation ensures that the target location for the duplication is within acceptable limits, maintaining the integrity of the file descriptor table.\nIf the source and target file descriptors are the same and belong to the same process, the system call does nothing and returns successfully. This behavior aligns with the POSIX standard, which specifies that duplicating a file descriptor to itself should have no effect.\nIf the target file descriptor already exists in the target process, the system closes it before proceeding with the duplication.    Closing the file involves updating the process's file descriptor table to mark the descriptor as unused and decrementing the count of open file descriptors for the process. Additionally, the system updates the file's reference count to reflect the decrease of the file references. And if the file is no longer referenced by any process, it resets the file's attributes, including its type, value, offset, and mode of operation, releasing the associated resources. This step guarantees that newfd is free and available for duplication.\nFinally, the system proceeds to duplicate the source file descriptor. The system associates the file descriptor with the file or resource by updating the target process's file descriptor table. The reference count of the file or resource is incremented to reflect its usage, and the number of file descriptors in use by the process is also updated to show the increase of the associated file descriptors. Furthermore, the system updates the metadata of the process and the file to reflect the open status of the file in a new process. This assignment is performed atomically to ensure consistency and correctness during the operation.\nIn conclusion, the `sys_dup2` system call is a crucial feature for managing file descriptors in a flexible and efficient manner. It carefully validates inputs, enforces strict permissions, and ensures that the duplication is performed securely and accurately. This design allows processes to manage their file descriptors effectively, contributing to the overall robustness and flexibility of the system's file management architecture.\n\n",
        "syscall": "sys_dup2",
        "declaration": "int sys_dup2(int oldfd, pid_t pid, int newfd);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_dup2(int oldfd, pid_t pid, int newfd)\n{\n    fn_t fn;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    /* oldfd doesn't exist  */\n    if (is_fd_valid(oldfd))\n        return -EBADF;\n    fn = get_fd(current, oldfd);\n    if (fn == 0)\n        return -EBADF;\n    if (!is_fd_valid(newfd))\n        return -EBADF;\n\n    /* POSIX: do nothing for the same fd */\n    if ((current == pid) && (oldfd == newfd))\n        return 0;\n\n    /* close newfd if it already exists */\n    if (get_fd(pid, newfd) != 0)\n        clear_fd(pid, newfd);\n    set_fd(pid, newfd, fn);\n    return 0;\n}\n\nenum file_type {\n    FD_NONE = 0,\n    FD_PIPE,\n    FD_INODE,\n    FD_SOCKET,\n\n    FD_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct file {\n    enum file_type type;\n    size_t refcnt;\n    uint64_t value;\n    uint64_t omode;\n    size_t offset;\n};\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_fd_valid(int fd)\n{\n    return fd >= 0 && fd < NOFILE;\n}\n\nstatic inline fn_t get_fd(pid_t pid, int fd)\n{\n    assert(is_fd_valid(fd), \"fd must be valid\");\n    return get_proc(pid)->ofile[fd];\n}\n\nstatic inline void clear_fd(pid_t pid, int fd)\n{\n    struct proc *proc;\n    struct file *file;\n\n    proc = get_proc(pid);\n    file = get_file(get_fd(pid, fd));\n    proc->ofile[fd] = 0;\n    --proc->nr_fds;\n    if (--file->refcnt == 0) {\n        file->type = FD_NONE;\n        file->value = 0;\n        file->offset = 0;\n        file->omode = 0;\n    }\n}\n\nextern struct file file_table[NFILE];\n\nstatic inline struct file *get_file(fn_t fn)\n{\n    assert(is_fn_valid(fn), \"fn must be valid\");\n    return &file_table[fn];\n}\n\nstatic inline bool is_fn_valid(fn_t fn)\n{\n    return fn > 0 && fn < NFILE;\n}\n\nstatic inline void set_fd(pid_t pid, int fd, fn_t fn)\n{\n    struct proc *proc;\n    struct file *file;\n\n    assert(get_fd(pid, fd) == 0, \"fd must be valid\");\n    proc = get_proc(pid);\n    file = get_file(fn);\n    proc->ofile[fd] = fn;\n    ++proc->nr_fds;\n    ++file->refcnt;\n}\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe sys_alloc_io_bitmap system call is designed to enable a process to allocate an I/O bitmap, which controls access to I/O ports in virtualized environments. The I/O bitmap acts as a mechanism for restricting or granting access to specific I/O ports by mapping them to a bit array, where each bit corresponds to a port. This system call ensures proper setup of the I/O bitmap while adhering to security and hardware requirements, making it essential for processes that require fine-grained control over I/O port access.\nThe system call begins by validating the sequence of memory pages provided. It requires three consecutive pages to be specified, ensuring that the memory allocation is contiguous. This requirement arises because hardware virtualization, particularly in x86 architectures, demands that I/O bitmaps be stored in contiguous memory regions for efficient access. If the pages are not consecutive, the operation is terminated with an error, as the allocation cannot proceed without a valid sequence.\nOnce the sequence is verified, the system checks whether the process already has an I/O bitmap allocated. If an I/O bitmap is already in use, the operation is rejected with an error to prevent multiple allocations, which could lead to resource conflicts.\nThe system then verifies that each of the specified pages is valid and available for allocation. This check ensures that the pages are not currently in use by other processes or system components. If any page is not valid or free, the operation is terminated with an error, maintaining the integrity of the memory allocation process.\nUpon successful validation, the system allocates the pages for the process, marking them as used for process-specific data. This allocation is crucial for setting up the I/O bitmap, which will control the process's access to I/O ports. The allocation process also updates the process's metadata to reflect the increase in its memory usage, maintaining accurate records for resource tracking and management.\nThe system proceeds to initialize the allocated pages by setting all bits to one. This initialization ensures that any access to I/O ports will initially cause an exit from the virtual machine, allowing the hypervisor to manage and control port access effectively.\nFinally, the system call updates the process metadata to reflect the allocation of the I/O bitmap. It records the pages used for the bitmap and marks the process as actively using an I/O bitmap. By doing this, the system ensures that the process can manage its I/O port access through the bitmap while preventing further allocations for the same purpose. The system call then completes successfully, signaling to the caller that the I/O bitmap has been properly allocated and configured.\nIn conclusion, the sys_alloc_io_bitmap system call is a critical feature for managing I/O port access in virtualized environments. It carefully validates inputs, enforces strict allocation rules, and ensures that the I/O bitmap is configured securely and efficiently. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtualization architecture.\n",
        "syscall": "sys_alloc_io_bitmap",
        "declaration": "int sys_alloc_io_bitmap(pn_t pn1, pn_t pn2, pn_t pn3);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_alloc_io_bitmap(pn_t pn1, pn_t pn2, pn_t pn3)\n{\n    struct proc *proc;\n\n    if (!(pn1 + 1 == pn2 && pn2 + 1 == pn3))\n        return -EINVAL;\n\n    proc = get_proc(current);\n    if (proc->use_io_bitmap)\n        return -EEXIST;\n\n    /*\n     * Since svm needs 3 consecutive pages and vmx needs 2 pages,\n     * we follow the more stricted (svm) rule.  Note that we use only\n     * 2 pages for the I/O bitmap; as the 3rd page contains all 1s,\n     * any wrap-around port access will cause vmexit on svm, which\n     * matches the unconditional vmexit behavior on vmx.\n     */\n\n    if (!is_page_type(pn1, PAGE_TYPE_FREE))\n        return -EINVAL;\n    if (!is_page_type(pn2, PAGE_TYPE_FREE))\n        return -EINVAL;\n    if (!is_page_type(pn3, PAGE_TYPE_FREE))\n        return -EINVAL;\n\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn1);\n    alloc_page(current, PAGE_TYPE_PROC_DATA, pn2);\n\n    /* set all bits to 1s */\n    memset(get_page(pn1), 0xff, PAGE_SIZE);\n    memset(get_page(pn2), 0xff, PAGE_SIZE);\n    memset(get_page(pn3), 0xff, PAGE_SIZE);\n\n    hvm_set_io_bitmap(get_page(proc->hvm), get_page(pn1));\n    proc->io_bitmap_a = pn1;\n    proc->io_bitmap_b = pn2;\n    proc->use_io_bitmap = 1;\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n#define FREELIST_DEL(arr, member, i)                \\\n({                                                  \\\n    typeof(&arr->member) entry = &arr[i].member;    \\\n    arr[entry->next].member.prev = entry->prev;     \\\n    arr[entry->prev].member.next = entry->next;     \\\n    entry->next = entry->prev = 0;                  \\\n})\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\nvoid alloc_page(pid_t pid, enum page_type type, pn_t pn)\n{\n    struct page_desc *desc = get_page_desc(pn);\n\n    assert(is_page_type(pn, PAGE_TYPE_FREE), \"must be a free page\");\n    desc->pid = pid;\n    desc->type = type;\n\n    if (pn != 0)\n        FREELIST_DEL(page_desc_table, link, pn);\n\n    bzero(get_page(pn), PAGE_SIZE);\n    if (pid)\n        ++get_proc(pid)->nr_pages;\n}\n\nvoid bzero(void *s, size_t n)\n{\n    memset(s, 0, n);\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n```\n",
        "bug_type": "memory leak",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `extintr` system call is responsible for handling external interrupts by associating a specific interrupt vector with a process and ensuring that the process is notified accordingly. This mechanism is essential in systems where external events, such as hardware signals or software-generated interrupts, need to be communicated to processes in a timely and efficient manner. By updating the interrupt state of the designated process and potentially waking it up if it is sleeping, the system call ensures that the interrupt is handled effectively.\nThe system call begins by identifying the process associated with the specified interrupt vector. It retrieves the process identifier from a predefined table that maps interrupt vectors to processes. This mapping ensures that each interrupt is directed to the correct process for handling.\nOnce the process identifier is obtained, the system validates it to ensure it corresponds to a legitimate and active process. If the identifier is invalid, the operation is terminated with an error, as it cannot proceed without a valid target process.\nAfter validation, the system retrieves the process descriptor, which contains essential information about the process, including its current state and interrupt handling capabilities. The system then sets a specific bit in the process's interrupt bitmask, indicating that the process has been signaled for the interrupt by calculating the specific bit index and bit mask using the specified interrupt vector.\nIf the process is currently in a sleeping state, the system transitions it to a runnable state, enabling it to respond to the interrupt. This state change is crucial for ensuring that the process can execute and handle the interrupt promptly. Additionally, the system sets special values in the process descriptor to facilitate inter-process communication, allowing the process to identify the source and nature of the interrupt.\nIn conclusion, the `extintr` system call is a vital component for managing external interrupts in a multitasking environment. It ensures that interrupts are directed to the appropriate processes, validates process identifiers, updates process states, and facilitates communication between processes. By providing this functionality, the system call enhances the system's ability to handle asynchronous events efficiently and effectively.\n",
        "syscall": "extintr",
        "declaration": "int extintr(uint8_t irq);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint extintr(uint8_t v)\n{\n    pid_t pid = vector_table[v];\n    struct proc *proc;\n\n    /* be paranoid  */\n    if (!is_pid_valid(pid))\n        return -EINVAL;\n    proc = get_proc(pid);\n\n    bit_set(v, proc->intr);\n    /* wake up a process if a new bit is set */\n    if (proc->state != PROC_SLEEPING) {\n        proc->state = PROC_RUNNABLE;\n        /* special value for kernel */\n        proc->ipc_from = 0;\n        proc->ipc_val = v;\n        proc->ipc_size = 0;\n    }\n\n    return 0;\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nextern struct proc proc_table[NPROC];\n\nstatic pid_t vector_table[256];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */\n#define __bitset_mask(n)   (1UL << ((n) % _BITSET_BITS))\n\n#define __bitset_word(n)   ((n) / _BITSET_BITS)\n\nstatic inline void bit_set(size_t n, unsigned long *bits)\n{\n    bits[__bitset_word(n)] |= __bitset_mask(n);\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nextern struct proc proc_table[NPROC];\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n```\n",
        "bug_type": "incorrect privilege",
        "bug_num": "1"
    },
    {
        "description": "\n[Functional Description]:\nThe `sys_map_pml4` system call provides a mechanism for establishing a self-referential mapping in a process's Page Map Level 4 (PML4) table. This mapping technique is commonly used in virtual memory systems to allow a process to access its own page table hierarchy through virtual memory. By mapping the PML4 table into itself at a specific index, the process can dynamically traverse and manipulate its paging structures without requiring additional system calls or privileged operations.\nThe system call begins by validating the identifier of the target process to ensure that it corresponds to a valid and active process. If the process identifier is not valid, the operation is terminated with an error, as the mapping cannot proceed without a valid target.\nOnce the process identifier is verified, the system calculates the physical frame number corresponding to the PML4 table (page table root) using the page table root of the process. The physical frame number represents the physical memory location of the PML4 table and is essential for creating the mapping. Before proceeding, the system checks the specified permissions for the mapping. If the permissions include write access, the operation is rejected with an error. This restriction ensures the integrity of the PML4 table, as allowing write permissions could lead to accidental or malicious corruption of the page table hierarchy. By enforcing read-only or execute-only permissions, the system maintains the stability and security of the virtual memory system.\nThe system then establishes a self-referential mapping in the PML4 table by updating the appropriate entry to reference itself. It operates by performing a series of checks, updating the page table, and ensuring system consistency. The system first verifies the identity of the target process to ensure it is valid and active. It also confirms that the process is either the current one or its embryo process. If not satisfied, the system terminates the operation and signals an error.\nThe next step is to validate the validity, type and ownership of the memory region involved in the operation. The system ensures that the source page, the page table root, corresponds to the expected type and is owned by the process. Additionally, it validates the specified location in the page to ensure it falls within acceptable range of page table entries. Any mismatch in type, ownership, or boundaries results in the function rejecting the operation with an error, ensuring memory integrity.\nThe system also enforces strict validation of the new permissions to be applied to the page. It checks that the requested permissions do not include any unsafe bits in page permissions by comparing it against the page table entry permission mask and ensures the permissions are valid. If any of them is not satisfied, the system terminates the operation and signals an error. This guarantees that the resulting mapping adheres to the system's security and functionality requirements.\nThe system then retrieves the page of the page table root and verifies that the specified entry within the page is unoccupied and empty. This ensures that existing mappings are not unintentionally overwritten, maintaining the integrity of existing memory configurations. If the location is already in use, the system terminates the operation and signals an error.\nThe system then updates the page table to reference the expected physical memory of the page table root using the specified page table root entry, while applying the validated permissions. The update is performed atomically to ensure consistency during the operation. After the mapping is established, the system triggers a mechanism to invalidate Translation Lookaside Buffer entries associated with the virtual address space of the current process. This step ensures that any outdated or stale cached translations are removed, allowing the system to immediately reflect the new memory configuration.\nIn conclusion, the `sys_map_pml4` system call is a crucial feature for enabling self-referential mappings in process page tables. It carefully validates inputs, enforces strict permissions, and ensures that the mapping is established securely and efficiently. This design allows processes to access and manage their page tables directly, which is particularly useful in advanced memory management scenarios. By providing this capability, the system call contributes to the overall robustness and flexibility of the system's virtual memory architecture.\n",
        "syscall": "sys_map_pml4",
        "declaration": "int sys_map_pml4(pid_t pid, size_t index, pte_t perm);",
        "code": "[Code Implementation]:\nIts corresponding code implementation that may contain bugs is as follows: \n```c\nint sys_map_pml4(pid_t pid, size_t index, pte_t perm)\n{\n    struct proc *proc;\n    pn_t from, pfn;\n\n    if (is_pid_valid(pid))\n        return -ESRCH;\n    proc = get_proc(pid);\n    from = proc->page_table_root;\n    pfn = pn_to_pfn(from);\n    if (pte_writable(perm))\n        return -EACCES;\n    return map_page(pid, from, index, pfn, perm, PAGE_TYPE_X86_PML4);\n}\n\nenum page_type {\n    PAGE_TYPE_FREE = 0,\n    PAGE_TYPE_RESERVED,\n    PAGE_TYPE_PROC_DATA,\n    PAGE_TYPE_FRAME,\n    PAGE_TYPE_X86_PML4,\n    PAGE_TYPE_X86_PDPT,\n    PAGE_TYPE_X86_PD,\n    PAGE_TYPE_X86_PT,\n    PAGE_TYPE_IOMMU_PML4,\n    PAGE_TYPE_IOMMU_PDPT,\n    PAGE_TYPE_IOMMU_PD,\n    PAGE_TYPE_IOMMU_PT,\n    PAGE_TYPE_IOMMU_FRAME,\n\n    /* hack to force 64bit */\n    PAGE_TYPE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct page_desc {\n    enum page_type type : 64;\n    pid_t pid;\n    struct {\n        pn_t prev;\n        pn_t next;\n    } link;\n};\n\nenum proc_state {\n    PROC_UNUSED = 0,\n    PROC_EMBRYO,\n    PROC_RUNNABLE,\n    PROC_RUNNING,\n    PROC_SLEEPING,\n    PROC_ZOMBIE,\n\n    /* hack to force 64bit */\n    PROC_STATE_FORCE_WIDTH = 0xfffffffffffffffful,\n};\n\nstruct proc {\n    enum proc_state state : 64; /* process state  */\n    pid_t ppid;\n    pn_t page_table_root; /* page table root */\n    pn_t stack;           /* kernel stack */\n    pn_t hvm;\n    pn_t io_bitmap_a;\n    pn_t io_bitmap_b;\n    fn_t ofile[NOFILE]; /* open files */\n    size_t nr_children;\n    size_t nr_fds;\n    size_t nr_pages;\n    size_t nr_dmapages;\n    size_t nr_devs;\n    size_t nr_ports;\n    size_t nr_vectors;\n    size_t nr_intremaps;\n    int launched;\n    int killed;\n    int use_io_bitmap;\n    pid_t ipc_from;\n    uint64_t ipc_val;\n    pn_t ipc_page;\n    size_t ipc_size;\n    int ipc_fd;\n    BITSET_DEFINE(intr, 256);\n    uint64_t name[2]; /* process name (debugging) */\n    struct {\n        pid_t prev;\n        pid_t next;\n    } ready;      /* ready queue for runnable/running processes */\n};\n\nstruct page_desc page_desc_table[NPAGE] __aligned(PAGE_SIZE);\n\nextern struct proc proc_table[NPROC];\n\n#define NPAGE 8192  /* maximum number of pages */\n#define NPROC 64    /* maximum number of processes */\n#define NOFILE 16   /* open files per process */\n#define NFILE 128   /* open files per system */#define PAGE_SHIFT 12\n#define PAGE_SIZE (UINT64_C(1) << PAGE_SHIFT)\n\nstatic struct proc *get_proc(pid_t pid)\n{\n    assert(is_pid_valid(pid), \"pid must be valid\");\n    return &proc_table[pid];\n}\n\nstatic inline bool is_pid_valid(pid_t pid)\n{\n    return pid > 0 && pid < NPROC;\n}\n\nstatic inline pn_t pn_to_pfn(pn_t pn)\n{\n    pn_t pfn0 = (uintptr_t)pages / PAGE_SIZE;\n\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pfn0 + pn;\n}\n\nstatic inline bool is_pn_valid(pn_t pn)\n{\n    return pn < NPAGE;\n}\n\n#define PTE_W BIT64(1)   /* writable */\n\nstatic inline bool pte_writable(uintptr_t x)\n{\n    return x & PTE_W;\n}\n\nint map_page(pid_t pid, pn_t from_pn, size_t index, pn_t pfn, pte_t perm,\n             enum page_type from_type)\n{\n    pte_t *entries;\n\n    if (!is_pid_valid(pid))\n        return -ESRCH;\n    /* check if pid is current or its embryo */\n    if (!is_current_or_embryo(pid))\n        return -EACCES;\n    if (!is_page_type(from_pn, from_type))\n        return -EINVAL;\n    /* check if pid owns from_pfn */\n    if (!is_page_pid(from_pn, pid))\n        return -EACCES;\n    if (!is_page_index_valid(index))\n        return -EINVAL;\n    /* no check on pfn; left to caller */\n    /* check for unsafe bits in page permissions */\n    if (perm & ~PTE_PERM_MASK)\n        return -EINVAL;\n    /* make sure we have non-zero entries */\n    if (!pte_valid(perm))\n        return -EINVAL;\n\n    entries = get_page(from_pn);\n    /* make sure the entry is empty; may not be necessary but good to check */\n    if (pte_valid(entries[index]))\n        return -EINVAL;\n\n    /* update the page table */\n    mmio_write64(&entries[index], (pfn << PTE_PFN_SHIFT) | perm);\n    hvm_invalidate_tlb(pid);\n    return 0;\n}\n\n/* permission check: we allow a pid to modify itself or its embryo */\nstatic inline bool is_current_or_embryo(pid_t pid)\n{\n    struct proc *proc;\n\n    if (pid == current)\n        return true;\n    proc = get_proc(pid);\n    if (proc->ppid == current && proc->state == PROC_EMBRYO)\n        return true;\n    return false;\n}\n\nstatic inline bool is_page_type(pn_t pn, enum page_type type)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->type == type;\n}\n\nstatic inline bool is_page_pid(pn_t pn, pid_t pid)\n{\n    return is_pn_valid(pn) && get_page_desc(pn)->pid == pid;\n}\n\nstatic inline struct page_desc *get_page_desc(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"page number must be valid\");\n    return &page_desc_table[pn];\n}\n\nstatic inline bool is_page_index_valid(size_t index)\n{\n    return index < 512;\n}\n\nstatic inline bool pte_valid(uintptr_t x)\n{\n    return x & PTE_P;\n}\n\nstatic inline void *get_page(pn_t pn)\n{\n    assert(is_pn_valid(pn), \"pn must be valid\");\n    return pages + pn;\n}\n\nstatic inline void mmio_write64(void *addr, uint64_t val)\n{\n    volatile uint64_t *p = addr;\n\n    *p = val;\n}\n```\n",
        "bug_type": "bounds checking",
        "bug_num": "1"
    }

]
