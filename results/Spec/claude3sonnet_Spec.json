{
    "0": {
        "sys_map_page_desc": [
            "\ndef sys_map_page_desc(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate pid is valid and is either current or embryo\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate number of pages doesn't exceed page descriptor table size\n        z3.ULT(n, dt.NPAGES_PAGE_DESC_TABLE),\n\n        # Validate source page is valid PT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions - must be present but not writable\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n\n        # Validate target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page descriptor table entry\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.page_desc_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "1": {
        "sys_map_proc": [
            "\ndef sys_map_proc(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate pid is valid and is either current or embryo\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate number of pages doesn't exceed process table size\n        z3.ULT(n, dt.NPAGES_PROC_TABLE),\n\n        # Validate source page is valid PT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions - must be present and non-writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # Validate target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the process table pages by updating page table entry\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.proc_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PROC\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "2": {
        "sys_map_dev": [
            "\ndef sys_map_dev(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate pid is valid and is either current or embryo\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate number of pages doesn't exceed device table size\n        z3.ULT(n, dt.NPAGES_DEVICES),\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # Ensure target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Update page table entry to map device memory\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.devices_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_DEVICES\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "3": {
        "sys_map_file": [
            "\ndef sys_map_file(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate pid and process relationship\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate number of pages doesn't exceed file table size\n        z3.ULT(n, dt.NPAGES_FILE_TABLE),\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions - must be present and non-writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # Ensure target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Update page table entry to map file table\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.file_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_FILE_TABLE\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "4": {
        "sys_alloc_pd": [
            "\ndef sys_alloc_pd(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PDPT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check that target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page in the PDPT\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PD\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "5": {
        "sys_alloc_pt": [
            "\ndef sys_alloc_pt(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PD owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check that target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page table entry\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the new PT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PT\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Initialize the shadow state for the new PT\n    new.pages[to].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_type = dt.PGTYPE_NONE\n\n    # Invalidate TLB after page table modification\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "6": {
        "sys_alloc_frame": [
            "\ndef sys_alloc_frame(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process permissions\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Ensure target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the frame in the page table\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable state\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the frame\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FRAME\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "7": {
        "sys_copy_frame": [
            "\ndef sys_copy_frame(old, frm, pid, to):\n    cond = z3.And(\n        # Validate source frame\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[frm].owner == old.current,\n\n        # Validate target process\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Validate target frame\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[to].owner == pid,\n\n        # Check permissions (current or embryo)\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO))\n    )\n\n    new = old.copy()\n\n    # Copy the entire frame data\n    new.pages[to].data = lambda idx, oldfn: old.pages[frm].data(idx)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "8": {
        "sys_protect_frame": [
            "\ndef sys_protect_frame(old, pt, index, frame, perm):\n    cond = z3.And(\n        # Validate pt is a valid page table page owned by current process\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate frame is a valid frame page owned by current process\n        z3.ULT(frame, dt.NPAGE),\n        old.pages[frame].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[frame].owner == old.current,\n\n        # Verify the page table entry exists and is present\n        old.pages[pt].data(index) & dt.PTE_P != 0,\n\n        # Verify the physical frame number matches\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) == z3.Extract(51, 12, old.pages[pt].data(index)),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0\n    )\n\n    new = old.copy()\n\n    # Update the page table entry with new permissions while preserving the frame number\n    new.pages[pt].data[index] = (\n        (z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) << dt.PTE_PFN_SHIFT) | perm\n\n    # Update the shadow page table permission tracking\n    new.pages[pt].pgtable_perm[index] = perm\n\n    # Invalidate TLB for the current process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "9": {
        "sys_free_pd": [
            "\ndef sys_free_pd(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm page is valid PDPT owned by current process\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to page is valid PD owned by current process\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[to].owner == old.current,\n\n        # Verify entry exists and matches target page\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Check physical address matches\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the PDPT entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow pgtable entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "10": {
        "sys_free_pt": [
            "\ndef sys_free_pt(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm page is valid and of correct type\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to page is valid and of correct type\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[to].owner == old.current,\n\n        # Verify entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify physical address matches\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == \n            z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the target page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    \n    # Update process page count\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the page directory entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "11": {
        "sys_free_frame": [
            "\ndef sys_free_frame(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm page is valid PT owned by current\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to page is valid frame owned by current\n        z3.ULT(to, dt.NPAGE), \n        old.pages[to].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[to].owner == old.current,\n\n        # Entry must be present\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n\n        # Entry must point to the specified frame\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the frame page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the page table entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n\n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "12": {
        "sys_reclaim_page": [
            "\ndef sys_reclaim_page(old, pn):\n    # Validate conditions for reclaiming the page\n    cond = z3.And(\n        # Page number must be valid\n        z3.ULT(pn, dt.NPAGE),\n        \n        # Page must not already be free\n        old.pages[pn].type != dt.page_type.PAGE_TYPE_FREE,\n        \n        # Page must belong to a valid process\n        z3.And(old.pages[pn].owner > 0, old.pages[pn].owner < dt.NPROC),\n        \n        # Process must be in zombie state\n        old.procs[old.pages[pn].owner].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Process must not have any devices\n        old.procs[old.pages[pn].owner].nr_devs() == 0\n    )\n\n    new = old.copy()\n\n    # Free the page by:\n    # 1. Setting owner to 0\n    # 2. Setting type to free\n    # 3. Zeroing the page data\n    # 4. Decrementing the process's page count\n    new.pages[pn].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[pn].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[pn].data = z3.BitVecVal(0, 64)\n    new.procs[old.pages[pn].owner].nr_pages[pn] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "13": {
        "sys_set_runnable": [
            "\ndef sys_set_runnable(old, pid):\n    # Validation conditions\n    cond = z3.And(\n        # Verify pid is valid (greater than 0 and less than NPROC)\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Verify the process's parent is the current process\n        old.procs[pid].ppid == old.current,\n        \n        # Verify the process is in embryo state\n        old.procs[pid].state == dt.proc_state.PROC_EMBRYO\n    )\n\n    new = old.copy()\n\n    # Update process state to runnable\n    new.procs[pid].state = dt.proc_state.PROC_RUNNABLE\n\n    # Add to ready list by updating the ready queue links\n    # The new process is added before the current process in the ready queue\n    new.procs[pid].ready.next = old.current\n    new.procs[pid].ready.prev = old.procs[old.current].ready.prev\n    new.procs[old.procs[old.current].ready.prev].ready.next = pid\n    new.procs[old.current].ready.prev = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "14": {
        "switch_proc": [
            "\ndef switch_proc(old, pid):\n    cond = z3.And(\n        # Validate pid is valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        # Ensure target process is in RUNNABLE state\n        old.procs[pid].state == dt.proc_state.PROC_RUNNABLE\n    )\n\n    new = old.copy()\n\n    # Only perform state changes if switching to a different process\n    new.procs[old.current].state = util.If(\n        z3.And(old.current != pid, \n               old.procs[old.current].state == dt.proc_state.PROC_RUNNING),\n        util.If(old.procs[old.current].killed,\n                dt.proc_state.PROC_ZOMBIE,\n                dt.proc_state.PROC_RUNNABLE),\n        old.procs[old.current].state)\n\n    # Update ready queue links if process is killed\n    new.procs[old.current].ready.prev = util.If(\n        z3.And(old.current != pid,\n               old.procs[old.current].state == dt.proc_state.PROC_RUNNING,\n               old.procs[old.current].killed),\n        z3.BitVecVal(0, dt.pid_t),\n        old.procs[old.current].ready.prev)\n\n    new.procs[old.current].ready.next = util.If(\n        z3.And(old.current != pid,\n               old.procs[old.current].state == dt.proc_state.PROC_RUNNING,\n               old.procs[old.current].killed),\n        z3.BitVecVal(0, dt.pid_t),\n        old.procs[old.current].ready.next)\n\n    # Set new process state to RUNNING\n    new.procs[pid].state = util.If(\n        old.current != pid,\n        dt.proc_state.PROC_RUNNING,\n        old.procs[pid].state)\n\n    # Update current process\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "15": {
        "sys_kill": [
            "\ndef sys_kill(old, pid):\n    cond = z3.And(\n        # Validate pid is in valid range\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Process must not be unused or zombie\n        z3.Not(z3.Or(\n            old.procs[pid].state == dt.proc_state.PROC_UNUSED,\n            old.procs[pid].state == dt.proc_state.PROC_ZOMBIE\n        ))\n    )\n\n    new = old.copy()\n\n    # Mark process as killed\n    new.procs[pid].killed = z3.BoolVal(True)\n\n    # If process is not running, transition to zombie state and remove from ready queue\n    new.procs[pid].state = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        dt.proc_state.PROC_ZOMBIE,\n        old.procs[pid].state\n    )\n\n    # Update ready queue links only if process is not running\n    new.procs[new.procs[pid].ready.next].ready.prev = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        new.procs[pid].ready.prev,\n        new.procs[new.procs[pid].ready.next].ready.prev\n    )\n\n    new.procs[new.procs[pid].ready.prev].ready.next = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        new.procs[pid].ready.next,\n        new.procs[new.procs[pid].ready.prev].ready.next\n    )\n\n    # Clear ready queue links if process is not running\n    new.procs[pid].ready.next = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        z3.BitVecVal(0, dt.pid_t),\n        new.procs[pid].ready.next\n    )\n\n    new.procs[pid].ready.prev = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        z3.BitVecVal(0, dt.pid_t),\n        new.procs[pid].ready.prev\n    )\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "16": {
        "sys_reap": [
            "\ndef sys_reap(old, pid):\n    # Validation conditions\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Must be child of current process\n        old.procs[pid].ppid == old.current,\n        \n        # Must be in zombie state\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Must have no resources\n        old.procs[pid].nr_devs() == 0,\n        old.procs[pid].nr_children() == 0,\n        old.procs[pid].nr_fds() == 0,\n        old.procs[pid].nr_pages() == 0,\n        old.procs[pid].nr_dmapages() == 0,\n        old.procs[pid].nr_ports() == 0,\n        old.procs[pid].nr_vectors() == 0,\n        old.procs[pid].nr_intremaps() == 0\n    )\n\n    new = old.copy()\n\n    # Decrement parent's child count\n    new.procs[old.current].nr_children[pid] -= 1\n\n    # Reset process state and attributes\n    new.procs[pid].state = dt.proc_state.PROC_UNUSED\n    new.procs[pid].ppid = z3.BitVecVal(0, dt.pid_t)\n    new.procs[pid].page_table_root = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].stack = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].hvm = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].killed = z3.BoolVal(False)\n    new.procs[pid].use_io_bitmap = z3.BoolVal(False)\n    new.procs[pid].io_bitmap_a = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].io_bitmap_b = z3.BitVecVal(0, dt.pn_t)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "17": {
        "sys_reparent": [
            "\ndef sys_reparent(old, pid):\n    cond = z3.And(\n        # Validate pid is in valid range\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Parent process must be in zombie state\n        old.procs[old.procs[pid].ppid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Init process must be either runnable or running\n        z3.Or(\n            old.procs[dt.INITPID].state == dt.proc_state.PROC_RUNNABLE,\n            old.procs[dt.INITPID].state == dt.proc_state.PROC_RUNNING\n        )\n    )\n\n    new = old.copy()\n\n    old_parent = new.procs[pid].ppid\n\n    # Update parent process ID to INITPID\n    new.procs[pid].ppid = dt.INITPID\n\n    # Increment init process's child count\n    new.procs[dt.INITPID].nr_children[pid] += 1\n\n    # Decrement old parent's child count\n    new.procs[old_parent].nr_children[pid] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "18": {
        "recv_proc": [
            "\ndef recv_proc(old, pid, pn, fd):\n    cond = z3.And(\n        # Validate pid is valid and process is runnable\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_RUNNABLE,\n        \n        # Validate page number, ownership and type\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].owner == old.current,\n        old.pages[pn].type == dt.page_type.PAGE_TYPE_FRAME,\n        \n        # If fd is valid, ensure it's not already associated with a file\n        z3.Implies(\n            z3.And(fd >= 0, fd < dt.NOFILE),\n            z3.Or(\n                old.procs[old.current].ofile(fd) == 0,\n                z3.UGE(old.procs[old.current].ofile(fd), dt.NFILE)\n            )\n        ),\n        \n        # Current process cannot receive from itself\n        pid != old.current\n    )\n\n    new = old.copy()\n\n    # Update server (current process) IPC state\n    new.procs[old.current].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.procs[old.current].ipc_page = pn\n    new.procs[old.current].ipc_size = z3.BitVecVal(0, dt.size_t)\n    new.procs[old.current].ipc_fd = fd\n\n    # Update process states\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Update current process\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "19": {
        "call_proc": [
            "\ndef call_proc(old, pid, val, inpn, size, outpn, outfd):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        \n        # Validate input page\n        z3.ULT(inpn, dt.NPAGE),\n        old.pages[inpn].owner == old.current,\n        \n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n        \n        # Validate output page\n        z3.ULT(outpn, dt.NPAGE),\n        old.pages[outpn].owner == old.current,\n        old.pages[outpn].type == dt.page_type.PAGE_TYPE_FRAME,\n        \n        # Validate output fd\n        z3.Or(\n            z3.Not(z3.And(outfd >= 0, outfd < dt.NOFILE)),\n            z3.And(\n                z3.And(outfd >= 0, outfd < dt.NOFILE),\n                z3.Or(\n                    old.procs[old.current].ofile(outfd) == 0,\n                    z3.Not(z3.And(\n                        z3.UGT(old.procs[old.current].ofile(outfd), 0),\n                        z3.ULT(old.procs[old.current].ofile(outfd), dt.NFILE)\n                    ))\n                )\n            )\n        ),\n        \n        # Check if receiver accepts sender\n        z3.Or(\n            old.procs[pid].ipc_from == 0,\n            old.procs[pid].ipc_from == old.current\n        ),\n        \n        # Ensure pid != current\n        pid != old.current\n    )\n\n    new = old.copy()\n\n    # Set up sender's IPC state\n    new.procs[old.current].ipc_page = outpn\n    new.procs[old.current].ipc_fd = outfd\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n\n    # Set up receiver's IPC state\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Copy data from input page to receiver's IPC page\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == new.procs[pid].ipc_page,\n                old.pages[inpn].data(idx),\n                oldfn(pn, idx))\n\n    # Set current process to accept IPC from pid\n    new.procs[old.current].ipc_from = pid\n\n    # Switch current process to pid\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "20": {
        "sys_create": [
            "\ndef sys_create(old, fd, fn, type, value, omode):\n    cond = z3.And(\n        # Type must not be FD_NONE\n        type != dt.file_type.FD_NONE,\n        \n        # fd must be valid and unused\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        old.procs[old.current].ofile(fd) == 0,\n        \n        # fn must be valid and unused\n        z3.And(z3.UGT(fn, 0), z3.ULT(fn, dt.NFILE)),\n        old.files[fn].refcnt() == 0\n    )\n\n    new = old.copy()\n\n    # Initialize file attributes\n    new.files[fn].type = type\n    new.files[fn].value = value\n    new.files[fn].omode = omode\n    new.files[fn].offset = z3.BitVecVal(0, dt.off_t)\n\n    # Update process file descriptor table\n    new.procs[old.current].ofile[fd] = fn\n    new.procs[old.current].nr_fds[fd] += 1\n\n    # Update file reference count\n    new.files[fn].refcnt[(old.current, fd)] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "21": {
        "sys_close": [
            "\ndef sys_close(old, pid, fd):\n    # Validation conditions\n    cond = z3.And(\n        # Validate pid is in valid range\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Validate fd is in valid range\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        \n        # Permission check: either current process or zombie process\n        z3.Or(\n            pid == old.current,\n            old.procs[pid].state == dt.proc_state.PROC_ZOMBIE\n        ),\n        \n        # Check if fd exists and is valid\n        z3.And(\n            z3.UGT(old.procs[pid].ofile(fd), 0),\n            z3.ULT(old.procs[pid].ofile(fd), dt.NFILE)\n        )\n    )\n\n    new = old.copy()\n    \n    # Get the file number associated with this fd\n    fn = old.procs[pid].ofile(fd)\n    \n    # Clear the fd entry in process's ofile array\n    new.procs[pid].ofile[fd] = z3.BitVecVal(0, dt.fn_t)\n    \n    # Decrement the process's fd count\n    new.procs[pid].nr_fds[fd] -= 1\n    \n    # Decrement file's reference count\n    new.files[fn].refcnt[(pid, fd)] -= 1\n    \n    # Get the new reference count\n    ref = new.files[fn].refcnt()\n    \n    # If refcount reaches 0, clear the file slot\n    new.files[fn].type = util.If(ref == 0, \n                                dt.file_type.FD_NONE, \n                                new.files[fn].type)\n    new.files[fn].value = util.If(ref == 0,\n                                 z3.BitVecVal(0, dt.uint64_t),\n                                 new.files[fn].value)\n    new.files[fn].offset = util.If(ref == 0,\n                                  z3.BitVecVal(0, dt.off_t),\n                                  new.files[fn].offset)\n    new.files[fn].omode = util.If(ref == 0,\n                                 z3.BitVecVal(0, dt.uint64_t),\n                                 new.files[fn].omode)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "22": {
        "sys_dup": [
            "\ndef sys_dup(old, oldfd, pid, newfd):\n    cond = z3.And(\n        # Validate pid is valid and is either current process or its embryo\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate oldfd is valid and exists in current process\n        z3.And(oldfd >= 0, oldfd < dt.NOFILE),\n        z3.And(z3.UGT(old.procs[old.current].ofile(oldfd), 0), \n               z3.ULT(old.procs[old.current].ofile(oldfd), dt.NFILE)),\n\n        # Validate newfd is valid and doesn't exist in target process\n        z3.And(newfd >= 0, newfd < dt.NOFILE),\n        old.procs[pid].ofile(newfd) == 0,\n    )\n\n    new = old.copy()\n\n    # Get the file number from oldfd\n    fn = new.procs[old.current].ofile(oldfd)\n\n    # Set the new file descriptor\n    new.procs[pid].ofile[newfd] = fn\n\n    # Increment the file descriptor count for the process\n    new.procs[pid].nr_fds[newfd] += 1\n\n    # Increment the file reference count\n    new.files[fn].refcnt[(pid, newfd)] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "23": {
        "sys_lseek": [
            "\ndef sys_lseek(old, fd, offset):\n    cond = z3.And(\n        # Validate fd is within valid range\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        \n        # Get and validate the file number from current process's fd table\n        z3.And(z3.UGT(old.procs[old.current].ofile(fd), 0), \n               z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)),\n        \n        # Verify file is of type FD_INODE\n        old.files[old.procs[old.current].ofile(fd)].type == dt.file_type.FD_INODE,\n        \n        # Ensure offset is non-negative\n        offset >= 0\n    )\n\n    new = old.copy()\n    \n    # Get the file number from the current process's fd table\n    fn = new.procs[new.current].ofile(fd)\n    \n    # Update the file offset\n    new.files[fn].offset = offset\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "24": {
        "sys_map_pcipage": [
            "\ndef sys_map_pcipage(old, pt, index, pcipn, perm):\n    cond = z3.And(\n        # Validate PCI page number\n        z3.ULT(pcipn, dt.NPCIPAGE),\n        old.pcipages[pcipn].valid,\n\n        # Verify current process owns the PCI page\n        old.pcipages[pcipn].owner == old.pci[old.pcipages[pcipn].owner].owner,\n        old.pci[old.pcipages[pcipn].owner].owner == old.current,\n\n        # Validate page table\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Verify target entry is empty\n        old.pages[pt].data(index) & dt.PTE_P == 0\n    )\n\n    new = old.copy()\n\n    # Calculate PCI page physical frame number\n    pfn = z3.UDiv(dt.PCI_START, z3.BitVecVal(dt.PAGE_SIZE, 64)) + pcipn\n\n    # Update page table entry with PCI page mapping\n    new.pages[pt].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[pt].pgtable_pn[index] = pcipn\n    new.pages[pt].pgtable_perm[index] = perm\n    new.pages[pt].pgtable_type[index] = dt.PGTYPE_PCIPAGE\n\n    # Invalidate TLB for the process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "25": {
        "sys_alloc_iommu_root": [
            "\ndef sys_alloc_iommu_root(old, devid, pn):\n    # Preconditions that must be satisfied\n    cond = z3.And(\n        # Device must not be already allocated\n        old.pci[devid].owner == 0,\n        \n        # Page must be valid and free\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].type == dt.page_type.PAGE_TYPE_FREE\n    )\n\n    new = old.copy()\n\n    # Associate device with current process\n    new.pci[devid].owner = old.current\n    \n    # Set the page table root for this device\n    new.pci[devid].page_table_root = pn\n\n    # Allocate and initialize the page\n    new.pages[pn].type = dt.page_type.PAGE_TYPE_IOMMU_PML4\n    new.pages[pn].owner = old.current\n    new.pages[pn].data = z3.BitVecVal(0, 64)\n    \n    # Update process metadata\n    new.procs[old.current].nr_pages[pn] += 1\n    new.procs[old.current].nr_devs[devid] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "26": {
        "sys_alloc_iommu_pdpt": [
            "\ndef sys_alloc_iommu_pdpt(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate that target page is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate source page type and ownership\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PML4,\n        old.pages[frm].owner == old.current,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions (only PTE_P and PTE_W allowed)\n        perm & ~(dt.PTE_P | dt.PTE_W) == 0,\n\n        # Check that entry is empty\n        old.pages[frm].data(index) == 0,\n    )\n\n    new = old.copy()\n\n    # Map the PDPT page into the PML4\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n                                          z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Maintain shadow pgtable info\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Allocate the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PDPT\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "27": {
        "sys_alloc_iommu_pd": [
            "\ndef sys_alloc_iommu_pd(old, frm, index, to, perm):\n    # Calculate the next level type based on the from_type (PDPT)\n    next_level = dt.page_type.PAGE_TYPE_IOMMU_FRAME - 1 - dt.page_type.PAGE_TYPE_IOMMU_PDPT\n\n    cond = z3.And(\n        # Validate that target page is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate source page type and ownership\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PDPT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions (only PTE_P and PTE_W allowed)\n        perm & ~(dt.PTE_P | dt.PTE_W) == 0,\n\n        # Ensure target entry is empty\n        old.pages[frm].data(index) == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page table entry\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n                                          z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Maintain shadow pgtable state\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Allocate the target page as a PD\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PD\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "28": {
        "sys_alloc_iommu_pt": [
            "\ndef sys_alloc_iommu_pt(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Check that target page is free\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n        \n        # Validate source page type and ownership\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PD,\n        old.pages[frm].owner == old.current,\n        \n        # Validate index is within bounds\n        z3.ULT(index, 512),\n        \n        # Validate permissions (only PTE_P and PTE_W allowed)\n        perm & ~(dt.PTE_P | dt.PTE_W) == 0,\n        \n        # Check that target entry is empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Calculate next level type (PAGE_TYPE_IOMMU_FRAME - 1 - PAGE_TYPE_IOMMU_PD)\n    next_level = dt.page_type.PAGE_TYPE_IOMMU_FRAME - 1 - dt.page_type.PAGE_TYPE_IOMMU_PD\n\n    # Map the page table entry\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int,\n                                          z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Maintain shadow page table info\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_IOMMU_FRAME\n\n    # Allocate the target page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PT\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Flush IOTLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "29": {
        "sys_alloc_iommu_frame": [
            "\ndef sys_alloc_iommu_frame(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate DMA page number and ensure it's free\n        z3.ULT(to, dt.NDMAPAGE),\n        old.dmapages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate source page is valid IOMMU PT and owned by current process\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions (only PTE_P and PTE_W allowed)\n        perm & (dt.MAX_INT64 ^ (dt.PTE_P | dt.PTE_W)) == 0,\n\n        # Entry must be empty\n        old.pages[frm].data(index) == 0,\n    )\n\n    new = old.copy()\n\n    # Map the IOMMU page table entry\n    new.pages[frm].data[index] = ((new.dmapages_ptr_to_int + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Update the \"shadow\" pgtable metadata\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_IOMMU_FRAME\n\n    # Allocate the DMA page\n    new.dmapages[to].type = dt.page_type.PAGE_TYPE_IOMMU_FRAME\n    new.dmapages[to].owner = old.current\n    new.procs[old.current].nr_dmapages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "30": {
        "sys_map_iommu_frame": [
            "\ndef sys_map_iommu_frame(old, pt, index, to, perm):\n    cond = z3.And(\n        # Validate that 'to' is a valid IOMMU frame owned by current process\n        z3.ULT(to, dt.NDMAPAGE),\n        old.dmapages[to].type == dt.page_type.PAGE_TYPE_IOMMU_FRAME,\n        old.dmapages[to].owner == old.current,\n\n        # Validate pt is a valid page table owned by current process\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Index must be valid page table index\n        z3.ULT(index, 512),\n\n        # Entry must be empty (not present)\n        old.pages[pt].data(index) & dt.PTE_P == 0,\n\n        # Permissions must be valid and safe\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0\n    )\n\n    new = old.copy()\n\n    # Calculate physical frame number for IOMMU frame\n    pfn = z3.UDiv(new.dmapages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to\n\n    # Update page table entry with frame mapping\n    new.pages[pt].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[pt].pgtable_pn[index] = to\n    new.pages[pt].pgtable_perm[index] = perm\n    new.pages[pt].pgtable_type[index] = dt.PGTYPE_IOMMU_FRAME\n\n    # Invalidate TLB for the process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "31": {
        "sys_reclaim_iommu_frame": [
            "\ndef sys_reclaim_iommu_frame(old, dmapn):\n    cond = z3.And(\n        # Validate DMA page number\n        z3.ULT(dmapn, dt.NDMAPAGE),\n        \n        # Page must not be free\n        old.dmapages[dmapn].type != dt.page_type.PAGE_TYPE_FREE,\n        \n        # Get the owner pid and verify it's a zombie\n        z3.And(\n            z3.UGT(old.dmapages[dmapn].owner, 0),\n            z3.ULT(old.dmapages[dmapn].owner, dt.NPROC),\n            old.procs[old.dmapages[dmapn].owner].state == dt.proc_state.PROC_ZOMBIE\n        ),\n        \n        # Owner must not have any devices in use\n        old.procs[old.dmapages[dmapn].owner].nr_devs == 0\n    )\n\n    new = old.copy()\n    \n    pid = old.dmapages[dmapn].owner\n    \n    # Mark the page as free\n    new.dmapages[dmapn].type = dt.page_type.PAGE_TYPE_FREE\n    new.dmapages[dmapn].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Decrement the process's DMA page count\n    new.procs[pid].nr_dmapages[dmapn] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "32": {
        "sys_reclaim_iommu_root": [
            "\ndef sys_reclaim_iommu_root(old, devid):\n    # Get the process ID that owns the device\n    pid = old.pci[devid].owner\n\n    # Conditions that must be satisfied:\n    # 1. Process must be valid and in ZOMBIE state\n    # 2. Process must not have any active interrupt remapping entries\n    cond = z3.And(\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        old.procs[pid].nr_intremaps == 0\n    )\n\n    new = old.copy()\n\n    # Decrement the device count for the process\n    new.procs[pid].nr_devs[devid] -= 1\n\n    # Clear the device ownership\n    new.pci[devid].owner = z3.BitVecVal(0, dt.pid_t)\n\n    # Reset the device's root page table\n    new.pci[devid].page_table_root = z3.BitVecVal(0, dt.pn_t)\n\n    # Flush the IOTLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "33": {
        "sys_alloc_vector": [
            "\ndef sys_alloc_vector(old, vector):\n    # Condition: vector must be free (owner is 0)\n    cond = old.vectors[vector].owner == 0\n\n    new = old.copy()\n\n    # Assign vector ownership to current process\n    new.vectors[vector].owner = old.current\n    \n    # Increment the vector count for the current process\n    new.procs[old.current].nr_vectors[vector] += 1\n\n    # Return either the new state if condition is met, or old state if not\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "34": {
        "sys_reclaim_vector": [
            "\ndef sys_reclaim_vector(old, vector):\n    # Get the process ID that owns this vector\n    pid = old.vectors[vector].owner\n\n    # Conditions that must be satisfied:\n    # 1. The process must be valid and in ZOMBIE state\n    # 2. The process must have no active interrupt remappings\n    cond = z3.And(\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        old.procs[pid].nr_intremaps == 0\n    )\n\n    new = old.copy()\n\n    # Reset the vector ownership to 0 (free)\n    new.vectors[vector].owner = z3.BitVecVal(0, dt.pid_t)\n\n    # Decrement the process's vector count\n    new.procs[pid].nr_vectors[vector] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "35": {
        "sys_alloc_intremap": [
            "\ndef sys_alloc_intremap(old, index, devid, vector):\n    cond = z3.And(\n        # Check if index is valid and free\n        z3.ULT(index, dt.NINTREMAP),\n        old.intremaps[index].state == dt.intremap_state.IR_FREE,\n\n        # Check if device is owned by current process\n        old.pci[devid].owner == old.current,\n\n        # Check if vector is owned by current process\n        old.vectors[vector].owner == old.current\n    )\n\n    new = old.copy()\n\n    # Update intremap state\n    new.intremaps[index].state = dt.intremap_state.IR_ACTIVE\n    new.intremaps[index].devid = devid\n    new.intremaps[index].vector = vector\n\n    # Increment process's intremap count\n    new.procs[new.current].nr_intremaps[index] += 1\n\n    # Flush IOTLB to ensure changes take effect\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "36": {
        "sys_reclaim_intremap": [
            "\ndef sys_reclaim_intremap(old, index):\n    # Preconditions for valid reclamation\n    cond = z3.And(\n        # Index must be valid and entry must be active\n        z3.ULT(index, dt.NINTREMAP),\n        old.intremaps[index].state == dt.intremap_state.IR_ACTIVE,\n\n        # Get the process ID from the PCI device and verify it's a zombie\n        z3.And(\n            old.pci[old.intremaps[index].devid].owner > 0,\n            old.pci[old.intremaps[index].devid].owner < dt.NPROC,\n            old.procs[old.pci[old.intremaps[index].devid].owner].state == dt.proc_state.PROC_ZOMBIE\n        )\n    )\n\n    new = old.copy()\n\n    # Reset the interrupt remapping entry\n    new.intremaps[index].state = dt.intremap_state.IR_FREE\n    new.intremaps[index].devid = z3.BitVecVal(0, dt.devid_t)\n    new.intremaps[index].vector = z3.BitVecVal(0, dt.uint8_t)\n\n    # Decrement the process's intremap count\n    pid = old.pci[old.intremaps[index].devid].owner\n    new.procs[pid].nr_intremaps[index] -= 1\n\n    # Flush the IOTLB to ensure hardware state is updated\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "37": {
        "sys_ack_intr": [
            "\ndef sys_ack_intr(old, v):\n    # No preconditions needed since this just operates on current process's intr field\n    cond = z3.BoolVal(True)\n    \n    new = old.copy()\n    \n    # Calculate which word and bit position within the intr array\n    idx = z3.UDiv(z3.ZeroExt(64 - v.size(), v), 64)\n    mask = ~(z3.BitVecVal(1, 64) << (v % 64))\n    \n    # Clear the specific interrupt bit in the process's intr field\n    new.procs[new.current].intr[idx] = new.procs[new.current].intr(idx) & mask\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "38": {
        "sys_alloc_port": [
            "\ndef sys_alloc_port(old, port):\n    # Conditions for successful port allocation:\n    # 1. Port must be free (owner is 0)\n    # 2. Current process must have io_bitmap permission\n    cond = z3.And(\n        old.io[port].owner == 0,\n        old.procs[old.current].use_io_bitmap,\n    )\n\n    new = old.copy()\n\n    # Assign port ownership to current process\n    new.io[port].owner = old.current\n    \n    # Increment the port count for the process\n    new.procs[old.current].nr_ports[port] += 1\n\n    # Determine which bitmap page to update based on port number\n    page = util.If(z3.ULT(port, 0x8000),\n                  new.procs[new.current].io_bitmap_a,\n                  new.procs[new.current].io_bitmap_b)\n\n    # Adjust port number for bitmap_b if needed\n    port_offset = z3.ZeroExt(64 - port.size(), \n                            util.If(z3.ULT(port, 0x8000), \n                                   port, \n                                   port - 0x8000))\n\n    # Calculate word index and bit mask for bitmap update\n    idx = z3.UDiv(port_offset, 64)\n    mask = 1 << (port_offset % 64)\n\n    # Clear the corresponding bit in the bitmap\n    new.pages[page].data[idx] = new.pages[page].data(idx) & ~mask\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "39": {
        "sys_reclaim_port": [
            "\ndef sys_reclaim_port(old, port):\n    # Get the owner pid of the port\n    pid = old.io[port].owner\n\n    # Check conditions:\n    # 1. pid must be valid (> 0 and < NPROC)\n    # 2. process must be in ZOMBIE state\n    cond = z3.And(\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE\n    )\n\n    new = old.copy()\n\n    # Clear the port ownership\n    new.io[port].owner = z3.BitVecVal(0, dt.pid_t)\n\n    # Decrement the process's port count\n    new.procs[pid].nr_ports[port] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "40": {
        "sys_alloc_pdpt": [
            "\ndef sys_alloc_pdpt(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid is valid and is either current or embryo\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is valid PML4 owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Ensure target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page in the page table\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PDPT\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Initialize the \"shadow\" pgtable for the new page\n    new.pages[to].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_type = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "41": {
        "sys_free_pdpt": [
            "\ndef sys_free_pdpt(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm is a valid PML4 page owned by current process\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to is a valid PDPT page owned by current process\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[to].owner == old.current,\n\n        # Verify the entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify physical address in PML4 entry matches the PDPT page\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the PML4 entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow pgtable entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "42": {
        "clone_proc": [
            "\ndef clone_proc(old, pid, pml4, stack, hvm):\n    # Validation conditions\n    cond = z3.And(\n        # Validate pid is valid and process is unused\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_UNUSED,\n\n        # Validate all pages exist and are free\n        z3.ULT(pml4, dt.NPAGE),\n        old.pages[pml4].type == dt.page_type.PAGE_TYPE_FREE,\n\n        z3.ULT(stack, dt.NPAGE),\n        old.pages[stack].type == dt.page_type.PAGE_TYPE_FREE,\n\n        z3.ULT(hvm, dt.NPAGE),\n        old.pages[hvm].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Ensure pages are distinct\n        z3.Distinct(pml4, stack, hvm)\n    )\n\n    new = old.copy()\n\n    # Initialize the new process\n    new.procs[pid].ppid = new.current\n    new.procs[pid].state = dt.proc_state.PROC_EMBRYO\n    new.procs[pid].killed = z3.BoolVal(False)\n    new.procs[pid].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.procs[pid].ipc_val = z3.BitVecVal(0, dt.uint64_t)\n    new.procs[pid].ipc_page = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].ipc_size = z3.BitVecVal(0, dt.size_t)\n    new.procs[pid].ipc_fd = z3.BitVecVal(0, dt.fd_t)\n    new.procs[pid].use_io_bitmap = z3.BoolVal(False)\n    new.procs[pid].io_bitmap_a = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].io_bitmap_b = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].ofile = z3.BitVecVal(0, dt.fn_t)\n    new.procs[pid].intr = z3.BitVecVal(0, 64)\n\n    # Initialize page table metadata\n    new.pages[pml4].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[pml4].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[pml4].pgtable_type = dt.PGTYPE_NONE\n\n    # Allocate and initialize PML4 page\n    new.pages[pml4].type = dt.page_type.PAGE_TYPE_X86_PML4\n    new.pages[pml4].owner = pid\n    new.pages[pml4].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[pml4] += 1\n\n    # Allocate and initialize stack page\n    new.pages[stack].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[stack].owner = pid\n    new.pages[stack].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[stack] += 1\n\n    # Allocate and initialize HVM page\n    new.pages[hvm].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[hvm].owner = pid\n    new.pages[hvm].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[hvm] += 1\n\n    # Set process page references\n    new.procs[pid].page_table_root = pml4\n    new.procs[pid].stack = stack\n    new.procs[pid].hvm = hvm\n\n    # Update parent's child count\n    new.procs[new.current].nr_children[pid] += 1\n\n    # Copy parent's stack data to child's stack\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == stack,\n                oldfn(new.procs[new.current].stack, idx),\n                oldfn(pn, idx))\n\n    # Copy parent's HVM data to child's HVM\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == hvm,\n                oldfn(new.procs[new.current].hvm, idx),\n                oldfn(pn, idx))\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "43": {
        "send_proc": [
            "\ndef send_proc(old, pid, val, pn, size, fd):\n    cond = z3.And(\n        # Validate pid is valid and process is sleeping\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        \n        # Validate page number and ownership\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].owner == old.current,\n        \n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n        \n        # Validate fd if provided\n        util.If(z3.And(fd >= 0, fd < dt.NOFILE),\n               z3.And(\n                   z3.UGT(old.procs[old.current].ofile(fd), 0),\n                   z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)\n               ),\n               z3.BoolVal(True)),\n        \n        # Current process cannot be the target\n        pid != old.current\n    )\n\n    new = old.copy()\n\n    # Update receiver's IPC state\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n\n    # Copy data from sender's page to receiver's IPC page\n    new.pages[new.procs[pid].ipc_page].data = lambda idx, oldfn: \\\n        util.If(z3.ULT(idx, z3.UDiv(size + 7, 8)),\n               old.pages[pn].data(idx),\n               oldfn(idx))\n\n    # Handle file descriptor transfer if both fds are valid\n    cond_fd = z3.And(\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        z3.And(new.procs[pid].ipc_fd >= 0, new.procs[pid].ipc_fd < dt.NOFILE)\n    )\n\n    # If fd transfer conditions met, update file descriptors\n    fn = old.procs[old.current].ofile(fd)\n    new.procs[pid].ofile[new.procs[pid].ipc_fd] = util.If(cond_fd, fn, new.procs[pid].ofile(new.procs[pid].ipc_fd))\n    new.procs[pid].nr_fds[new.procs[pid].ipc_fd] = util.If(cond_fd, \n        new.procs[pid].nr_fds(new.procs[pid].ipc_fd) + 1,\n        new.procs[pid].nr_fds(new.procs[pid].ipc_fd))\n    new.files[fn].refcnt[(pid, new.procs[pid].ipc_fd)] = util.If(cond_fd,\n        new.files[fn].refcnt((pid, new.procs[pid].ipc_fd)) + 1,\n        new.files[fn].refcnt((pid, new.procs[pid].ipc_fd)))\n\n    # Update process states\n    new.procs[old.current].state = dt.proc_state.PROC_RUNNABLE\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Switch current process to receiver\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "44": {
        "reply_wait_proc": [
            "\ndef reply_wait_proc(old, pid, val, inpn, size, infd, outpn):\n    # Validate conditions for the operation\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n\n        # Validate input page\n        z3.ULT(inpn, dt.NPAGE),\n        old.pages[inpn].owner == old.current,\n\n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n\n        # Validate input fd if valid\n        z3.Implies(z3.And(infd >= 0, infd < dt.NOFILE),\n                  z3.And(z3.UGT(old.procs[old.current].ofile(infd), 0),\n                        z3.ULT(old.procs[old.current].ofile(infd), dt.NFILE))),\n\n        # Validate output page\n        z3.ULT(outpn, dt.NPAGE),\n        old.pages[outpn].owner == old.current,\n        old.pages[outpn].type == dt.page_type.PAGE_TYPE_FRAME,\n\n        # Ensure pid != current (one sleeping, one running)\n        pid != old.current,\n\n        # Check if receiver accepts sender\n        z3.Or(old.procs[pid].ipc_from == 0,\n              old.procs[pid].ipc_from == old.current)\n    )\n\n    new = old.copy()\n\n    # Set up sender (current process) for response\n    new.procs[old.current].ipc_page = outpn\n    new.procs[old.current].ipc_fd = z3.BitVecVal(-1, dt.fd_t)\n\n    # Set up receiver with data from sender\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n\n    # Copy data from input page to receiver's page\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(z3.And(pn == new.procs[pid].ipc_page,\n                      z3.ULT(idx, (size + 7) / 8)),\n               oldfn(inpn, idx),\n               oldfn(pn, idx))\n\n    new.procs[pid].ipc_size = size\n\n    # Transfer fd if both infd and receiver's ipc_fd are valid\n    cond_fd = z3.And(\n        z3.And(infd >= 0, infd < dt.NOFILE),\n        z3.And(new.procs[pid].ipc_fd >= 0, new.procs[pid].ipc_fd < dt.NOFILE)\n    )\n\n    # If fd transfer conditions met, update file descriptors\n    fn = new.procs[old.current].ofile(infd)\n    new.procs[pid].ofile = lambda fd, oldfn: \\\n        util.If(z3.And(cond_fd, fd == new.procs[pid].ipc_fd),\n               fn, oldfn(fd))\n\n    new.procs[pid].nr_fds = lambda fd, oldfn: \\\n        util.If(z3.And(cond_fd, fd == new.procs[pid].ipc_fd),\n               oldfn(fd) + 1, oldfn(fd))\n\n    new.files[fn].refcnt = lambda pid_fd, oldfn: \\\n        util.If(z3.And(cond_fd,\n                      pid_fd[0] == pid,\n                      pid_fd[1] == new.procs[pid].ipc_fd),\n               oldfn(pid_fd) + 1, oldfn(pid_fd))\n\n    # Switch process states\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Accept any IPC and switch current process\n    new.procs[old.current].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "45": {
        "sys_dup2": [
            "\ndef sys_dup2(old, oldfd, pid, newfd):\n    # Validation conditions\n    cond = z3.And(\n        # Validate pid is valid\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # Validate pid is either current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate oldfd is valid and exists\n        z3.And(oldfd >= 0, oldfd < dt.NOFILE),\n        z3.And(z3.UGT(old.procs[old.current].ofile(oldfd), 0), \n               z3.ULT(old.procs[old.current].ofile(oldfd), dt.NFILE)),\n\n        # Validate newfd is valid\n        z3.And(newfd >= 0, newfd < dt.NOFILE),\n    )\n\n    new = old.copy()\n\n    # POSIX: If fds are the same in same process, do nothing\n    same_fd = z3.And(old.current == pid, oldfd == newfd)\n    \n    # Get the file number from oldfd\n    fn = new.procs[old.current].ofile(oldfd)\n    \n    # Handle case where newfd exists (needs to be closed first)\n    newfn = new.procs[pid].ofile(newfd)\n    has_newfd = z3.And(z3.UGT(newfn, 0), z3.ULT(newfn, dt.NFILE))\n\n    # Clear existing newfd if it exists\n    new.procs[pid].ofile[newfd] = util.If(has_newfd,\n        z3.BitVecVal(0, dt.fn_t),\n        new.procs[pid].ofile(newfd))\n    \n    new.procs[pid].nr_fds[newfd] = util.If(has_newfd,\n        new.procs[pid].nr_fds(newfd) - 1,\n        new.procs[pid].nr_fds(newfd))\n\n    # Update file refcount for closed fd\n    new.files[newfn].refcnt[(pid, newfd)] = util.If(has_newfd,\n        new.files[newfn].refcnt() - 1,\n        new.files[newfn].refcnt())\n\n    # Clear file if refcount reaches 0\n    ref = new.files[newfn].refcnt()\n    new.files[newfn].type = util.If(z3.And(has_newfd, ref == 0),\n        dt.file_type.FD_NONE,\n        new.files[newfn].type)\n    new.files[newfn].value = util.If(z3.And(has_newfd, ref == 0),\n        z3.BitVecVal(0, dt.uint64_t),\n        new.files[newfn].value)\n    new.files[newfn].offset = util.If(z3.And(has_newfd, ref == 0),\n        z3.BitVecVal(0, dt.size_t),\n        new.files[newfn].offset)\n    new.files[newfn].omode = util.If(z3.And(has_newfd, ref == 0),\n        z3.BitVecVal(0, dt.uint64_t),\n        new.files[newfn].omode)\n\n    # Set up new file descriptor\n    new.procs[pid].ofile[newfd] = util.If(same_fd,\n        new.procs[pid].ofile(newfd),\n        fn)\n    \n    new.procs[pid].nr_fds[newfd] = util.If(same_fd,\n        new.procs[pid].nr_fds(newfd),\n        new.procs[pid].nr_fds(newfd) + 1)\n\n    # Update file refcount for new fd\n    new.files[fn].refcnt[(pid, newfd)] = util.If(same_fd,\n        new.files[fn].refcnt(),\n        new.files[fn].refcnt() + 1)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "46": {
        "sys_alloc_io_bitmap": [
            "\ndef sys_alloc_io_bitmap(old, pn1, pn2, pn3):\n    # Validation conditions\n    cond = z3.And(\n        # Pages must be consecutive\n        pn2 == pn1 + 1,\n        pn3 == pn2 + 1,\n\n        # Pages must be valid\n        z3.ULT(pn1, dt.NPAGE),\n        z3.ULT(pn2, dt.NPAGE),\n        z3.ULT(pn3, dt.NPAGE),\n\n        # Pages must be free\n        old.pages[pn1].type == dt.page_type.PAGE_TYPE_FREE,\n        old.pages[pn2].type == dt.page_type.PAGE_TYPE_FREE,\n        old.pages[pn3].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Process must not already have an I/O bitmap\n        z3.Not(old.procs[old.current].use_io_bitmap),\n    )\n\n    new = old.copy()\n\n    # Allocate the pages\n    new.pages[pn1].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn1].owner = old.current\n    new.procs[old.current].nr_pages[pn1] += 1\n\n    new.pages[pn2].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn2].owner = old.current\n    new.procs[old.current].nr_pages[pn2] += 1\n\n    new.pages[pn3].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn3].owner = old.current\n    new.procs[old.current].nr_pages[pn3] += 1\n\n    # Set all bits to 1s in the pages\n    new.pages[pn1].data = lambda idx, oldfn: dt.MAX_INT64\n    new.pages[pn2].data = lambda idx, oldfn: dt.MAX_INT64\n    new.pages[pn3].data = lambda idx, oldfn: dt.MAX_INT64\n\n    # Update process metadata\n    new.procs[old.current].io_bitmap_a = pn1\n    new.procs[old.current].io_bitmap_b = pn2\n    new.procs[old.current].use_io_bitmap = z3.BoolVal(True)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "47": {
        "extintr": [
            "\ndef extintr(old, v):\n    # Get the process ID from the vector table\n    pid = old.vectors[v].owner\n\n    # Validate the process ID\n    cond = z3.And(\n        z3.And(pid > 0, pid < dt.NPROC)\n    )\n\n    new = old.copy()\n\n    # Calculate bit index and mask for interrupt vector\n    idx = z3.UDiv(z3.ZeroExt(64 - v.size(), v), 64)\n    mask = 1 << (z3.ZeroExt(64 - v.size(), v) % 64)\n\n    # Set the interrupt bit in process's intr field\n    new.procs[pid].intr[idx] = new.procs[pid].intr(idx) | mask\n\n    # If process is sleeping, wake it up and set IPC values\n    new.procs[pid].state = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        dt.proc_state.PROC_RUNNABLE,\n        old.procs[pid].state\n    )\n\n    new.procs[pid].ipc_from = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.BitVecVal(0, dt.pid_t),\n        old.procs[pid].ipc_from\n    )\n\n    new.procs[pid].ipc_val = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.ZeroExt(64 - v.size(), v),\n        old.procs[pid].ipc_val\n    )\n\n    new.procs[pid].ipc_size = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.BitVecVal(0, dt.size_t),\n        old.procs[pid].ipc_size\n    )\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "48": {
        "sys_map_pml4": [
            "\ndef sys_map_pml4(old, pid, index, perm):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # The pid is either current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n        \n        # Get the page table root and validate it\n        z3.ULT(old.procs[pid].page_table_root, dt.NPAGE),\n        old.pages[old.procs[pid].page_table_root].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[old.procs[pid].page_table_root].owner == pid,\n        \n        # Index is a valid page index\n        z3.ULT(index, 512),\n        \n        # No unsafe bits in perm and P bit is set\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        \n        # Perm must not be writable\n        perm & dt.PTE_W == 0,\n        \n        # Entry must be empty (not present)\n        old.pages[old.procs[pid].page_table_root].data(index) & dt.PTE_P == 0\n    )\n    \n    new = old.copy()\n    \n    # Calculate physical frame number for the PML4\n    pfn = z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + old.procs[pid].page_table_root\n    \n    # Update the page table entry to point to itself with the given permissions\n    new.pages[old.procs[pid].page_table_root].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n    \n    # Maintain the \"shadow\" pgtable\n    new.pages[old.procs[pid].page_table_root].pgtable_pn[index] = old.procs[pid].page_table_root\n    new.pages[old.procs[pid].page_table_root].pgtable_perm[index] = perm\n    new.pages[old.procs[pid].page_table_root].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n    \n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "49": {
        "sys_map_page_desc": [
            "\ndef sys_map_page_desc(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate n is not too large\n        z3.ULT(n, dt.NPAGES_PAGE_DESC_TABLE),\n\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # Verify pid is either current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate frm is a valid page table of correct type owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions - no unsafe bits and must be present\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        \n        # Validate permissions - must not be writable\n        perm & dt.PTE_W == 0,\n\n        # Verify target entry is empty (not present)\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Update the page table entry to map the page descriptor\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.page_desc_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" page table state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Invalidate TLB after mapping\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "50": {
        "sys_map_proc": [
            "\ndef sys_map_proc(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        z3.ULT(n, dt.NPAGES_PROC_TABLE),\n\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # the pid is either current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # frm is a valid pn of type PT whose owner is pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Index is a valid page index\n        z3.ULT(index, 512),\n\n        # perm has no unsafe bits on it and it is present and writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W != 0,\n\n        # index does not have the P bit in the from page\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.proc_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PROC\n\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "51": {
        "sys_map_dev": [
            "\ndef sys_map_dev(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        z3.ULT(n, dt.NPAGES_DEVICES),\n\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # the pid is either current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # frm is a valid pn of type PT whose owner is pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Index is a valid page index\n        z3.ULT(index, 512),\n\n        # perm has no unsafe bits on it and it is present and non-writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # index does not have the P bit in the from page\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.devices_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_DEVICES\n\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "52": {
        "sys_map_file": [
            "\ndef sys_map_file(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate pid and process relationship\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate number of pages\n        z3.ULT(n, dt.NPAGES_FILE_TABLE),\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions - must be present and non-writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # Ensure target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Update page table entry to map the file table\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.file_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_FILE_TABLE\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "53": {
        "sys_alloc_pd": [
            "\ndef sys_alloc_pd(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PDPT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check that target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page in the PDPT\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PD\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "54": {
        "sys_alloc_pt": [
            "\ndef sys_alloc_pt(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid is valid and is either current or embryo\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is valid PD owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate entry is empty (not present)\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n    )\n\n    new = old.copy()\n\n    # Map the page table in the page directory\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the new page table page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PT\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Initialize shadow state for new PT\n    new.pages[to].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_perm = z3.BitVecVal(0, 64) \n    new.pages[to].pgtable_type = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "55": {
        "sys_alloc_frame": [
            "\ndef sys_alloc_frame(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process permissions\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Ensure target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Update page table entry to map the new frame\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the frame page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FRAME\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)  # Zero the page contents\n    new.procs[pid].nr_pages[to] += 1\n\n    # Invalidate TLB after mapping\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "56": {
        "sys_copy_frame": [
            "\ndef sys_copy_frame(old, frm, pid, to):\n    cond = z3.And(\n        # Validate source frame\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[frm].owner == old.current,\n\n        # Validate target process\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Validate target frame\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[to].owner == pid,\n\n        # Check permissions (current or embryo)\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO))\n    )\n\n    new = old.copy()\n\n    # Copy the entire page data from source to target\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == to,\n               old.pages[frm].data(idx),\n               oldfn(pn, idx))\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "57": {
        "sys_protect_frame": [
            "\ndef sys_protect_frame(old, pt, index, frame, perm):\n    cond = z3.And(\n        # Validate pt is a valid page table page owned by current process\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate frame is a valid frame page owned by current process\n        z3.ULT(frame, dt.NPAGE),\n        old.pages[frame].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[frame].owner == old.current,\n\n        # Verify the page table entry exists and is present\n        old.pages[pt].data(index) & dt.PTE_P != 0,\n\n        # Verify the physical frame number matches\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) == z3.Extract(51, 12, old.pages[pt].data(index)),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0\n    )\n\n    new = old.copy()\n\n    # Update the page table entry with new permissions while preserving the frame number\n    new.pages[pt].data[index] = (\n        (z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) << dt.PTE_PFN_SHIFT) | perm\n\n    # Update the shadow page table permission tracking\n    new.pages[pt].pgtable_perm[index] = perm\n\n    # Invalidate TLB for the current process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "58": {
        "sys_free_pd": [
            "\ndef sys_free_pd(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm page is a valid PDPT owned by current process\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to page is a valid PD owned by current process\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[to].owner == old.current,\n\n        # Verify entry exists and matches target page\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify physical address matches\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the PDPT entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow pgtable entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "59": {
        "sys_free_pt": [
            "\ndef sys_free_pt(old, frm, index, to):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Validate page types\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PT,\n        \n        # Validate ownership\n        old.pages[frm].owner == old.current,\n        old.pages[to].owner == old.current,\n        \n        # Validate index\n        z3.ULT(index, 512),\n        \n        # Validate entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify the physical address in the PD entry matches the PT page\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == \n            z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the PT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    \n    # Decrement the page count for the process\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the PD entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "60": {
        "sys_free_frame": [
            "\ndef sys_free_frame(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm page is valid PT owned by current\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to page is valid frame owned by current\n        z3.ULT(to, dt.NPAGE), \n        old.pages[to].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[to].owner == old.current,\n\n        # Entry must be present\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n\n        # Entry must point to the specified frame\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the frame page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the page table entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "61": {
        "sys_reclaim_page": [
            "\ndef sys_reclaim_page(old, pn):\n    # Validate conditions for reclaiming the page\n    cond = z3.And(\n        # Page number must be valid\n        z3.ULT(pn, dt.NPAGE),\n        \n        # Page must not already be free\n        old.pages[pn].type != dt.page_type.PAGE_TYPE_FREE,\n        \n        # Owner process must exist and be in zombie state\n        z3.And(\n            z3.ULT(old.pages[pn].owner, dt.NPROC),\n            z3.UGT(old.pages[pn].owner, 0),\n            old.procs[old.pages[pn].owner].state == dt.proc_state.PROC_ZOMBIE\n        ),\n        \n        # Process must not have any devices in use\n        old.procs[old.pages[pn].owner].nr_devs == 0\n    )\n\n    new = old.copy()\n    \n    pid = old.pages[pn].owner\n\n    # Free the page by:\n    # 1. Clear owner\n    new.pages[pn].owner = z3.BitVecVal(0, dt.pid_t)\n    # 2. Set type to free\n    new.pages[pn].type = dt.page_type.PAGE_TYPE_FREE\n    # 3. Zero the page data\n    new.pages[pn].data = z3.BitVecVal(0, 64)\n    # 4. Decrement the process's page count\n    new.procs[pid].nr_pages[pn] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "62": {
        "sys_set_runnable": [
            "\ndef sys_set_runnable(old, pid):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check parent relationship\n        old.procs[pid].ppid == old.current,\n        \n        # Check process is in embryo state\n        old.procs[pid].state == dt.proc_state.PROC_EMBRYO\n    )\n\n    new = old.copy()\n\n    # Update process state to runnable\n    new.procs[pid].state = dt.proc_state.PROC_RUNNABLE\n\n    # Add to ready list by updating the ready list pointers\n    # Insert before current process\n    new.procs[pid].ready.next = new.current\n    new.procs[pid].ready.prev = new.procs[new.current].ready.prev\n    new.procs[new.procs[new.current].ready.prev].ready.next = pid\n    new.procs[new.current].ready.prev = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "63": {
        "switch_proc": [
            "\ndef switch_proc(old, pid):\n    cond = z3.And(\n        # Validate pid is valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if process is in RUNNABLE state\n        old.procs[pid].state == dt.proc_state.PROC_RUNNABLE\n    )\n\n    new = old.copy()\n\n    # Only perform state changes if switching to a different process\n    new = util.If(old.current != pid,\n        util.If(old.procs[old.current].state == dt.proc_state.PROC_RUNNING,\n            # Update old process state based on killed flag\n            util.If(old.procs[old.current].killed,\n                # If killed, transition to zombie state\n                new.copy().update(\n                    procs={old.current: {\n                        'state': dt.proc_state.PROC_ZOMBIE\n                    }}\n                ),\n                # If not killed, transition to runnable state\n                new.copy().update(\n                    procs={old.current: {\n                        'state': dt.proc_state.PROC_RUNNABLE\n                    }}\n                )\n            ),\n            # If current process not running, no state change needed\n            new\n        ).update(\n            # Update new process state and current process\n            procs={pid: {'state': dt.proc_state.PROC_RUNNING}},\n            current=pid\n        ),\n        # If switching to same process, no changes needed\n        old\n    )\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "64": {
        "sys_kill": [
            "\ndef sys_kill(old, pid):\n    cond = z3.And(\n        # Validate pid is in valid range\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Process must not be unused or zombie\n        z3.Not(z3.Or(\n            old.procs[pid].state == dt.proc_state.PROC_UNUSED,\n            old.procs[pid].state == dt.proc_state.PROC_ZOMBIE\n        ))\n    )\n\n    new = old.copy()\n    \n    # Mark process as killed\n    new.procs[pid].killed = z3.BoolVal(True)\n\n    # If process is not running, transition to zombie state and remove from ready queue\n    new.procs[pid].state = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        dt.proc_state.PROC_ZOMBIE,\n        old.procs[pid].state\n    )\n\n    # Update ready queue links only if process is not running\n    new.procs[new.procs[pid].ready.next].ready.prev = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        new.procs[pid].ready.prev,\n        new.procs[new.procs[pid].ready.next].ready.prev\n    )\n\n    new.procs[new.procs[pid].ready.prev].ready.next = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        new.procs[pid].ready.next,\n        new.procs[new.procs[pid].ready.prev].ready.next\n    )\n\n    # Clear ready queue links if process is not running\n    new.procs[pid].ready.next = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        z3.BitVecVal(0, dt.pid_t),\n        new.procs[pid].ready.next\n    )\n\n    new.procs[pid].ready.prev = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        z3.BitVecVal(0, dt.pid_t),\n        new.procs[pid].ready.prev\n    )\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "65": {
        "sys_reap": [
            "\ndef sys_reap(old, pid):\n    cond = z3.And(\n        # pid must be valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # must be child of current process\n        old.procs[pid].ppid == old.current,\n        \n        # must be zombie\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # must have no resources\n        old.procs[pid].nr_devs == 0,\n        old.procs[pid].nr_children == 0,\n        old.procs[pid].nr_fds == 0,\n        old.procs[pid].nr_pages == 0,\n        old.procs[pid].nr_dmapages == 0,\n        old.procs[pid].nr_ports == 0,\n        old.procs[pid].nr_vectors == 0,\n        old.procs[pid].nr_intremaps == 0\n    )\n\n    new = old.copy()\n\n    # Decrement parent's child count\n    new.procs[old.current].nr_children[pid] -= 1\n\n    # Reset process state\n    new.procs[pid].state = dt.proc_state.PROC_UNUSED\n    new.procs[pid].ppid = z3.BitVecVal(0, dt.pid_t)\n    new.procs[pid].page_table_root = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].stack = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].hvm = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].launched = z3.BoolVal(False)\n    new.procs[pid].killed = z3.BoolVal(False)\n    new.procs[pid].use_io_bitmap = z3.BoolVal(False)\n    new.procs[pid].io_bitmap_a = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].io_bitmap_b = z3.BitVecVal(0, dt.pn_t)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "66": {
        "sys_reparent": [
            "\ndef sys_reparent(old, pid):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Parent must be zombie\n        old.procs[old.procs[pid].ppid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Init process must be runnable or running\n        z3.Or(\n            old.procs[dt.INITPID].state == dt.proc_state.PROC_RUNNABLE,\n            old.procs[dt.INITPID].state == dt.proc_state.PROC_RUNNING\n        )\n    )\n\n    new = old.copy()\n\n    old_parent = new.procs[pid].ppid\n    \n    # Decrement old parent's children count\n    new.procs[old_parent].nr_children[pid] -= 1\n    \n    # Update parent to INITPID\n    new.procs[pid].ppid = dt.INITPID\n    \n    # Increment INITPID's children count\n    new.procs[dt.INITPID].nr_children[pid] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "67": {
        "recv_proc": [
            "\ndef recv_proc(old, pid, pn, fd):\n    cond = z3.And(\n        # Validate pid is valid and process is runnable\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_RUNNABLE,\n        \n        # Validate page number\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].owner == old.current,\n        old.pages[pn].type == dt.page_type.PAGE_TYPE_FRAME,\n        \n        # Validate file descriptor if provided\n        z3.Implies(\n            z3.And(fd >= 0, fd < dt.NOFILE),\n            old.procs[old.current].ofile(fd) == 0\n        ),\n        \n        # Current process cannot receive from itself\n        pid != old.current\n    )\n\n    new = old.copy()\n\n    # Update current process (server) IPC state\n    new.procs[old.current].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.procs[old.current].ipc_page = pn\n    new.procs[old.current].ipc_size = z3.BitVecVal(0, dt.size_t)\n    new.procs[old.current].ipc_fd = fd\n\n    # Update process states\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n    \n    # Update current process\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "68": {
        "call_proc": [
            "\ndef call_proc(old, pid, val, inpn, size, outpn, outfd):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        \n        # Validate input page\n        z3.ULT(inpn, dt.NPAGE),\n        old.pages[inpn].owner == old.current,\n        \n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n        \n        # Validate output page\n        z3.ULT(outpn, dt.NPAGE),\n        old.pages[outpn].owner == old.current,\n        old.pages[outpn].type == dt.page_type.PAGE_TYPE_FRAME,\n        \n        # Validate output fd\n        z3.Or(\n            z3.Not(z3.And(outfd >= 0, outfd < dt.NOFILE)),\n            z3.And(\n                z3.And(outfd >= 0, outfd < dt.NOFILE),\n                z3.Or(\n                    old.procs[old.current].ofile(outfd) == 0,\n                    z3.And(\n                        z3.UGT(old.procs[old.current].ofile(outfd), 0),\n                        z3.ULT(old.procs[old.current].ofile(outfd), dt.NFILE)\n                    )\n                )\n            )\n        ),\n        \n        # Verify receiver accepts sender\n        z3.Or(\n            old.procs[pid].ipc_from == 0,\n            old.procs[pid].ipc_from == old.current\n        )\n    )\n\n    new = old.copy()\n    \n    # Set up sender's IPC state\n    new.procs[old.current].ipc_page = outpn\n    new.procs[old.current].ipc_fd = outfd\n    \n    # Set up receiver's IPC state\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n    \n    # Copy data from input page to receiver's page\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == new.procs[pid].ipc_page,\n                old.pages[inpn].data(idx),\n                oldfn(pn, idx))\n    \n    # Update process states\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n    \n    # Update current process\n    new.current = pid\n    \n    # Reset current process's IPC state\n    new.procs[old.current].ipc_from = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "69": {
        "sys_create": [
            "\ndef sys_create(old, fd, fn, type, value, omode):\n    cond = z3.And(\n        # type must not be FD_NONE\n        type != dt.file_type.FD_NONE,\n\n        # fd must be valid\n        z3.And(fd >= 0, fd < dt.NOFILE),\n\n        # fd must be empty in current process\n        old.procs[old.current].ofile(fd) == 0,\n\n        # fn must be valid\n        z3.And(z3.UGT(fn, 0), z3.ULT(fn, dt.NFILE)),\n\n        # fn must be unused (refcount = 0)\n        old.files[fn].refcnt() == 0\n    )\n\n    new = old.copy()\n\n    # Initialize the file\n    new.files[fn].type = type\n    new.files[fn].value = value\n    new.files[fn].omode = omode\n    new.files[fn].offset = z3.BitVecVal(0, dt.off_t)\n\n    # Set the file descriptor\n    new.procs[old.current].ofile[fd] = fn\n    new.procs[old.current].nr_fds[fd] += 1\n    new.files[fn].refcnt[(old.current, fd)] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "70": {
        "sys_close": [
            "\ndef sys_close(old, pid, fd):\n    cond = z3.And(\n        # Valid pid check\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Valid fd check\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        \n        # Permission check: either current process or zombie process\n        z3.Or(pid == old.current,\n              old.procs[pid].state == dt.proc_state.PROC_ZOMBIE),\n        \n        # File descriptor must be in use\n        z3.And(z3.UGT(old.procs[pid].ofile(fd), 0), \n               z3.ULT(old.procs[pid].ofile(fd), dt.NFILE))\n    )\n\n    new = old.copy()\n    \n    # Get the file number before clearing\n    fn = old.procs[pid].ofile(fd)\n    \n    # Clear the file descriptor\n    new.procs[pid].ofile[fd] = z3.BitVecVal(0, dt.fn_t)\n    \n    # Decrement the process's fd count\n    new.procs[pid].nr_fds[fd] -= 1\n    \n    # Decrement file refcount\n    new.files[fn].refcnt[(pid, fd)] -= 1\n    \n    # Get the new refcount\n    ref = new.files[fn].refcnt()\n    \n    # If refcount reaches 0, clear the file slot\n    new.files[fn].type = util.If(ref == 0, dt.file_type.FD_NONE, new.files[fn].type)\n    new.files[fn].value = util.If(ref == 0, z3.BitVecVal(0, dt.uint64_t), new.files[fn].value)\n    new.files[fn].offset = util.If(ref == 0, z3.BitVecVal(0, dt.off_t), new.files[fn].offset)\n    new.files[fn].omode = util.If(ref == 0, z3.BitVecVal(0, dt.uint64_t), new.files[fn].omode)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "71": {
        "sys_dup": [
            "\ndef sys_dup(old, oldfd, pid, newfd):\n    cond = z3.And(\n        # Validate pid is valid and is either current process or its embryo\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate oldfd is valid and exists in current process\n        z3.And(oldfd >= 0, oldfd < dt.NOFILE),\n        z3.And(z3.UGT(old.procs[old.current].ofile(oldfd), 0), \n               z3.ULT(old.procs[old.current].ofile(oldfd), dt.NFILE)),\n\n        # Validate newfd is valid and doesn't exist in target process\n        z3.And(newfd >= 0, newfd < dt.NOFILE),\n        old.procs[pid].ofile(newfd) == 0\n    )\n\n    new = old.copy()\n\n    # Get the file number from oldfd\n    fn = new.procs[old.current].ofile(oldfd)\n\n    # Update the target process's file descriptor table\n    new.procs[pid].ofile[newfd] = fn\n\n    # Increment the process's fd count\n    new.procs[pid].nr_fds[newfd] += 1\n\n    # Increment the file's reference count\n    new.files[fn].refcnt[(pid, newfd)] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "72": {
        "sys_lseek": [
            "\ndef sys_lseek(old, fd, offset):\n    # Validate fd is in valid range\n    # Validate file number exists and is valid\n    # Validate file is an inode type\n    # Validate offset is non-negative\n    cond = z3.And(\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        \n        # Get and validate the file number\n        z3.And(\n            z3.UGT(old.procs[old.current].ofile(fd), 0),\n            z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)\n        ),\n        \n        # File must be an inode type\n        old.files[old.procs[old.current].ofile(fd)].type == dt.file_type.FD_INODE,\n        \n        # Offset must be non-negative\n        offset >= 0\n    )\n\n    new = old.copy()\n    \n    # Update the file offset\n    fn = new.procs[new.current].ofile(fd)\n    new.files[fn].offset = offset\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "73": {
        "sys_map_pcipage": [
            "\ndef sys_map_pcipage(old, pt, index, pcipn, perm):\n    cond = z3.And(\n        # Validate PCI page number\n        z3.ULT(pcipn, dt.NPCIPAGE),\n        old.pcipages[pcipn].valid,\n\n        # Verify current process owns the PCI page\n        old.pcipages[pcipn].owner == old.pci[old.pcipages[pcipn].owner].owner,\n        old.pci[old.pcipages[pcipn].owner].owner == old.current,\n\n        # Validate page table\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Verify target entry is empty\n        old.pages[pt].data(index) & dt.PTE_P == 0\n    )\n\n    new = old.copy()\n\n    # Calculate PCI page physical frame number\n    pfn = z3.UDiv(dt.PCI_START, z3.BitVecVal(dt.PAGE_SIZE, 64)) + pcipn\n\n    # Update page table entry with PCI page mapping\n    new.pages[pt].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[pt].pgtable_pn[index] = pcipn\n    new.pages[pt].pgtable_perm[index] = perm\n    new.pages[pt].pgtable_type[index] = dt.PGTYPE_PCIPAGE\n\n    # Invalidate TLB for the process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "74": {
        "sys_alloc_iommu_root": [
            "\ndef sys_alloc_iommu_root(old, devid, pn):\n    cond = z3.And(\n        # Device ID should not be already allocated\n        old.pci[devid].owner == 0,\n        \n        # Page number should be valid and free\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].type == dt.page_type.PAGE_TYPE_FREE,\n    )\n\n    new = old.copy()\n\n    # Associate device with current process\n    new.pci[devid].owner = old.current\n    \n    # Set the page table root for the device\n    new.pci[devid].page_table_root = pn\n\n    # Allocate and initialize the page\n    new.pages[pn].type = dt.page_type.PAGE_TYPE_IOMMU_PML4\n    new.pages[pn].owner = old.current\n    new.pages[pn].data = z3.BitVecVal(0, 64)\n    \n    # Update process metadata\n    new.procs[old.current].nr_pages[pn] += 1\n    new.procs[old.current].nr_devs[devid] += 1\n\n    # Flush IOTLB to ensure changes are visible\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "75": {
        "sys_alloc_iommu_pdpt": [
            "\ndef sys_alloc_iommu_pdpt(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate that target page is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate source page type and ownership\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PML4,\n        old.pages[frm].owner == old.current,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions (only PTE_P and PTE_W allowed)\n        perm & (dt.MAX_INT64 ^ (dt.PTE_P | dt.PTE_W)) == 0,\n\n        # Check that entry is empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Map the PDPT page into the PML4\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Maintain shadow pgtable info\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Allocate the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PDPT\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "76": {
        "sys_alloc_iommu_pd": [
            "\ndef sys_alloc_iommu_pd(old, frm, index, to, perm):\n    # Conditions for valid execution\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Check source page type and ownership\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PDPT,\n        old.pages[frm].owner == old.current,\n        \n        # Check target page is free\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n        \n        # Validate index is within bounds\n        z3.ULT(index, 512),\n        \n        # Check permissions only include read/write bits\n        perm & (dt.MAX_INT64 ^ (dt.PTE_P | dt.PTE_W)) == 0,\n        \n        # Verify entry is empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Map the page table entry\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Update the shadow IOMMU page table metadata\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Allocate the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PD\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "77": {
        "sys_alloc_iommu_pt": [
            "\ndef sys_alloc_iommu_pt(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Verify source page type and ownership\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PD,\n        old.pages[frm].owner == old.current,\n        \n        # Verify target page is free\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n        \n        # Validate index is within bounds\n        z3.ULT(index, 512),\n        \n        # Verify entry is empty\n        old.pages[frm].data(index) == 0,\n        \n        # Check permissions (only PTE_P and PTE_W allowed)\n        perm & ~(dt.PTE_P | dt.PTE_W) == 0,\n    )\n    \n    new = old.copy()\n    \n    # Calculate next level type for IOMMU hierarchy\n    next_level = dt.page_type.PAGE_TYPE_IOMMU_FRAME - 1 - dt.page_type.PAGE_TYPE_IOMMU_PD\n    \n    # Map the page table entry\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n                                          z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n    \n    # Maintain shadow page table info\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n    \n    # Allocate the target page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PT\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n    \n    # Flush IOMMU TLB\n    new.flush_iotlb()\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "78": {
        "sys_alloc_iommu_frame": [
            "\ndef sys_alloc_iommu_frame(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate DMA page number\n        z3.ULT(to, dt.NDMAPAGE),\n        old.dmapages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions (only PTE_P and PTE_W allowed)\n        perm & (dt.MAX_INT64 ^ (dt.PTE_P | dt.PTE_W)) == 0,\n\n        # Entry must be empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Update the IOMMU page table entry\n    new.pages[frm].data[index] = ((new.dmapages_ptr_to_int + \n        (to << dt.DMAR_PTE_ADDR_SHIFT)) | perm)\n\n    # Update the \"shadow\" page table info\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_IOMMU_FRAME\n\n    # Update DMA page metadata\n    new.dmapages[to].type = dt.page_type.PAGE_TYPE_IOMMU_FRAME\n    new.dmapages[to].owner = old.current\n\n    # Update process DMA page count\n    new.procs[old.current].nr_dmapages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "79": {
        "sys_map_iommu_frame": [
            "\ndef sys_map_iommu_frame(old, pt, index, to, perm):\n    cond = z3.And(\n        # Validate pt is a valid page number and is a page table owned by current\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to is a valid DMA page number and is an IOMMU frame owned by current\n        z3.ULT(to, dt.NDMAPAGE),\n        old.dmapages[to].type == dt.page_type.PAGE_TYPE_IOMMU_FRAME,\n        old.dmapages[to].owner == old.current,\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Ensure target entry is empty\n        old.pages[pt].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Calculate physical frame number for the IOMMU frame\n    pfn = z3.UDiv(new.dmapages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to\n\n    # Update the page table entry with the physical frame number and permissions\n    new.pages[pt].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable for verification\n    new.pages[pt].pgtable_pn[index] = to\n    new.pages[pt].pgtable_perm[index] = perm\n    new.pages[pt].pgtable_type[index] = dt.PGTYPE_IOMMU_FRAME\n\n    # Invalidate TLB for the process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "80": {
        "sys_reclaim_iommu_frame": [
            "\ndef sys_reclaim_iommu_frame(old, dmapn):\n    # Validation conditions\n    cond = z3.And(\n        # Check if dmapn is valid\n        z3.ULT(dmapn, dt.NDMAPAGE),\n        \n        # Check if page is not free\n        old.dmapages[dmapn].type != dt.page_type.PAGE_TYPE_FREE,\n        \n        # Get the owner pid and verify it's a zombie process\n        z3.And(\n            z3.UGT(old.dmapages[dmapn].owner, 0),\n            z3.ULT(old.dmapages[dmapn].owner, dt.NPROC),\n            old.procs[old.dmapages[dmapn].owner].state == dt.proc_state.PROC_ZOMBIE\n        ),\n        \n        # Check that the process has no devices in use\n        old.procs[old.dmapages[dmapn].owner].nr_devs() == 0\n    )\n\n    new = old.copy()\n    \n    pid = old.dmapages[dmapn].owner\n\n    # Update the page type to free\n    new.dmapages[dmapn].type = dt.page_type.PAGE_TYPE_FREE\n    \n    # Clear the owner\n    new.dmapages[dmapn].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Decrement the process's DMA page count\n    new.procs[pid].nr_dmapages[dmapn] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "81": {
        "sys_reclaim_iommu_root": [
            "\ndef sys_reclaim_iommu_root(old, devid):\n    # Conditions for valid execution\n    cond = z3.And(\n        # Get the process that owns the device\n        z3.ULT(devid, dt.NPCIDEV),\n        old.pci[devid].owner != 0,\n        \n        # Process must be in zombie state\n        old.procs[old.pci[devid].owner].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Process must not have any active interrupt remappings\n        old.procs[old.pci[devid].owner].nr_intremaps() == 0\n    )\n\n    new = old.copy()\n\n    pid = new.pci[devid].owner\n\n    # Decrement the device count for the process\n    new.procs[pid].nr_devs[devid] -= 1\n\n    # Clear the device ownership\n    new.pci[devid].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Reset the device's IOMMU root page table\n    new.pci[devid].page_table_root = z3.BitVecVal(0, dt.pn_t)\n\n    # Flush the IOTLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "82": {
        "sys_alloc_vector": [
            "\ndef sys_alloc_vector(old, vector):\n    cond = z3.And(\n        # Check if vector is free (owner is 0)\n        old.vectors[vector].owner == 0\n    )\n\n    new = old.copy()\n\n    # Assign the vector to current process\n    new.vectors[vector].owner = old.current\n    \n    # Increment the vector count for the current process\n    new.procs[old.current].nr_vectors[vector] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "83": {
        "sys_reclaim_vector": [
            "\ndef sys_reclaim_vector(old, vector):\n    # Get the owner of the vector\n    pid = old.vectors[vector].owner\n    \n    cond = z3.And(\n        # Vector must be valid\n        z3.ULT(vector, 256),\n        \n        # Vector must be owned by a valid process\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Process must be in ZOMBIE state (terminated)\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Process must not have any interrupt remappings\n        old.procs[pid].nr_intremaps == 0\n    )\n\n    new = old.copy()\n    \n    # Clear the vector ownership\n    new.vectors[vector].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Decrement the process's vector count\n    new.procs[pid].nr_vectors[vector] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "84": {
        "sys_alloc_intremap": [
            "\ndef sys_alloc_intremap(old, index, devid, vector):\n    cond = z3.And(\n        # Check if index is valid and free\n        z3.ULT(index, dt.NINTREMAP),\n        old.intremaps[index].state == dt.intremap_state.IR_FREE,\n\n        # Check if device is owned by current process\n        old.pci[devid].owner == old.current,\n\n        # Check if vector is owned by current process\n        old.vectors[vector].owner == old.current\n    )\n\n    new = old.copy()\n\n    # Update intremap state and metadata\n    new.intremaps[index].state = dt.intremap_state.IR_ACTIVE\n    new.intremaps[index].devid = devid\n    new.intremaps[index].vector = vector\n\n    # Update process intremap count\n    new.procs[new.current].nr_intremaps[index] += 1\n\n    # Flush IOTLB to ensure changes take effect\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "85": {
        "sys_reclaim_intremap": [
            "\ndef sys_reclaim_intremap(old, index):\n    # Conditions for valid reclamation:\n    # 1. Index must be valid (< NINTREMAP)\n    # 2. Entry must be active\n    # 3. Associated process must be in zombie state\n    cond = z3.And(\n        z3.ULT(index, dt.NINTREMAP),\n        old.intremaps[index].state == dt.intremap_state.IR_ACTIVE,\n        \n        # Get the process ID from the PCI device associated with this interrupt\n        z3.And(\n            z3.ULT(old.intremaps[index].devid, dt.NPCIDEV),\n            old.pci[old.intremaps[index].devid].owner != 0,\n            old.procs[old.pci[old.intremaps[index].devid].owner].state == dt.proc_state.PROC_ZOMBIE\n        )\n    )\n\n    new = old.copy()\n\n    # Get the process ID that owns this interrupt mapping\n    pid = new.pci[old.intremaps[index].devid].owner\n\n    # Reset the interrupt remapping entry\n    new.intremaps[index].state = dt.intremap_state.IR_FREE\n    new.intremaps[index].devid = z3.BitVecVal(0, dt.devid_t)\n    new.intremaps[index].vector = z3.BitVecVal(0, dt.uint8_t)\n\n    # Decrement the process's interrupt remapping count\n    new.procs[pid].nr_intremaps[index] -= 1\n\n    # Flush the IOTLB to ensure hardware state is updated\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "86": {
        "sys_ack_intr": [
            "\ndef sys_ack_intr(old, vector):\n    # Condition: vector must be valid (0-255 for 256-bit intr field)\n    cond = z3.ULT(vector, 256)\n\n    new = old.copy()\n\n    # Calculate the word index and bit mask for the interrupt vector\n    idx = z3.UDiv(z3.ZeroExt(64 - vector.size(), vector), 64)\n    mask = 1 << (vector % 64)\n\n    # Clear the interrupt bit in the current process's intr field\n    new.procs[new.current].intr[idx] = new.procs[new.current].intr(idx) & ~mask\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "87": {
        "sys_alloc_port": [
            "\ndef sys_alloc_port(old, port):\n    # Conditions for successful port allocation:\n    # 1. Port must be free (owner is 0)\n    # 2. Current process must have io_bitmap permission\n    cond = z3.And(\n        old.io[port].owner == 0,\n        old.procs[old.current].use_io_bitmap,\n    )\n\n    new = old.copy()\n\n    # Assign port ownership to current process\n    new.io[port].owner = old.current\n    \n    # Increment the port count for the current process\n    new.procs[old.current].nr_ports[port] += 1\n\n    # Calculate which bitmap page to use and the offset within it\n    page = util.If(z3.ULT(port, 0x8000),\n            new.procs[new.current].io_bitmap_a,\n            new.procs[new.current].io_bitmap_b)\n\n    # Adjust port number for bitmap_b\n    port = z3.ZeroExt(64 - port.size(), util.If(z3.ULT(port, 0x8000), port, port - 0x8000))\n\n    # Calculate word index and bit mask within the bitmap\n    idx = z3.UDiv(port, 64)\n    mask = 1 << (port % 64)\n\n    # Clear the bit in the appropriate bitmap\n    new.pages[page].data[idx] = new.pages[page].data(idx) & ~mask\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "88": {
        "sys_reclaim_port": [
            "\ndef sys_reclaim_port(old, port):\n    # Get the owner pid of the port\n    pid = old.io[port].owner\n\n    # Conditions for valid reclamation:\n    # - pid must be valid (> 0 and < NPROC)\n    # - process must be in ZOMBIE state\n    cond = z3.And(\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE\n    )\n\n    new = old.copy()\n\n    # Clear the port ownership\n    new.io[port].owner = z3.BitVecVal(0, dt.pid_t)\n\n    # Decrement the process's port count\n    new.procs[pid].nr_ports[port] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "89": {
        "sys_alloc_pdpt": [
            "\ndef sys_alloc_pdpt(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is valid PML4 owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Check entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0\n    )\n\n    new = old.copy()\n\n    # Map the page in the page table\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PDPT\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Initialize shadow page table state for new PDPT\n    new.pages[to].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_type = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "90": {
        "sys_free_pdpt": [
            "\ndef sys_free_pdpt(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm is a valid PML4 page owned by current process\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to is a valid PDPT page owned by current process\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[to].owner == old.current,\n\n        # Verify the entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify the physical address in the entry matches the target page\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the entry in PML4\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "91": {
        "clone_proc": [
            "\ndef clone_proc(old, pid, pml4, stack, hvm):\n    # Validation conditions\n    cond = z3.And(\n        # Validate pid is valid and process is unused\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_UNUSED,\n\n        # Validate all pages exist and are free\n        z3.ULT(pml4, dt.NPAGE),\n        old.pages[pml4].type == dt.page_type.PAGE_TYPE_FREE,\n\n        z3.ULT(stack, dt.NPAGE),\n        old.pages[stack].type == dt.page_type.PAGE_TYPE_FREE,\n\n        z3.ULT(hvm, dt.NPAGE),\n        old.pages[hvm].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Ensure pages are distinct\n        z3.Distinct(pml4, stack, hvm)\n    )\n\n    new = old.copy()\n\n    # Initialize the new process\n    new.procs[pid].ppid = new.current\n    new.procs[pid].state = dt.proc_state.PROC_EMBRYO\n    new.procs[pid].killed = z3.BoolVal(False)\n    new.procs[pid].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.procs[pid].ipc_val = z3.BitVecVal(0, dt.uint64_t)\n    new.procs[pid].ipc_page = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].ipc_size = z3.BitVecVal(0, dt.size_t)\n    new.procs[pid].ipc_fd = z3.BitVecVal(0, dt.fd_t)\n    new.procs[pid].use_io_bitmap = z3.BoolVal(False)\n    new.procs[pid].io_bitmap_a = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].io_bitmap_b = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].ofile = z3.BitVecVal(0, dt.fn_t)\n    new.procs[pid].intr = z3.BitVecVal(0, 64)\n\n    # Initialize page table metadata\n    new.pages[pml4].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[pml4].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[pml4].pgtable_type = dt.PGTYPE_NONE\n\n    # Allocate and initialize PML4 page\n    new.pages[pml4].type = dt.page_type.PAGE_TYPE_X86_PML4\n    new.pages[pml4].owner = pid\n    new.pages[pml4].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[pml4] += 1\n\n    # Allocate and initialize stack page\n    new.pages[stack].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[stack].owner = pid\n    new.pages[stack].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[stack] += 1\n\n    # Allocate and initialize HVM page\n    new.pages[hvm].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[hvm].owner = pid\n    new.pages[hvm].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[hvm] += 1\n\n    # Set process page references\n    new.procs[pid].page_table_root = pml4\n    new.procs[pid].stack = stack\n    new.procs[pid].hvm = hvm\n\n    # Update parent's child count\n    new.procs[new.current].nr_children[pid] += 1\n\n    # Copy parent's stack data to child's stack\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == stack,\n                oldfn(new.procs[new.current].stack, idx),\n                oldfn(pn, idx))\n\n    # Copy parent's HVM data to child's HVM\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == hvm,\n                oldfn(new.procs[new.current].hvm, idx),\n                oldfn(pn, idx))\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "92": {
        "send_proc": [
            "\ndef send_proc(old, pid, val, pn, size, fd):\n    # Validate inputs and check conditions\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check process state\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        \n        # Validate page number and ownership\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].owner == old.current,\n        \n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n        \n        # Validate fd if provided\n        util.If(z3.And(fd >= 0, fd < dt.NOFILE),\n               z3.And(z3.UGT(old.procs[old.current].ofile(fd), 0),\n                     z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)),\n               z3.BoolVal(True)),\n        \n        # Current process cannot send to itself\n        pid != old.current\n    )\n\n    new = old.copy()\n\n    # Update IPC state for receiver\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n\n    # Copy data from sender's page to receiver's IPC page\n    new.pages.data = lambda pn_arg, idx, oldfn: \\\n        util.If(z3.And(pn_arg == new.procs[pid].ipc_page,\n                      z3.ULT(idx, z3.UDiv(size + 7, 8))),\n               oldfn(pn, idx),\n               oldfn(pn_arg, idx))\n\n    # Handle file descriptor transfer if both fds are valid\n    new_state = util.If(\n        z3.And(z3.And(fd >= 0, fd < dt.NOFILE),\n               z3.And(new.procs[pid].ipc_fd >= 0,\n                     new.procs[pid].ipc_fd < dt.NOFILE)),\n        lambda s: (\n            # Set new fd in receiver's fd table\n            s.procs[pid].ofile.update(\n                new.procs[pid].ipc_fd,\n                new.procs[old.current].ofile(fd)\n            ),\n            # Update fd count and file refcount\n            s.procs[pid].nr_fds.update(\n                new.procs[pid].ipc_fd,\n                s.procs[pid].nr_fds(new.procs[pid].ipc_fd) + 1\n            ),\n            s.files[new.procs[old.current].ofile(fd)].refcnt.update(\n                (pid, new.procs[pid].ipc_fd),\n                s.files[new.procs[old.current].ofile(fd)].refcnt() + 1\n            )\n        )[0],\n        lambda s: s\n    )(new)\n\n    # Update process states\n    new_state.procs[old.current].state = dt.proc_state.PROC_RUNNABLE\n    new_state.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Switch current process\n    new_state.current = pid\n\n    return cond, util.If(cond, new_state, old)\n"
        ]
    },
    "93": {
        "reply_wait_proc": [
            "\ndef reply_wait_proc(old, pid, val, inpn, size, infd, outpn):\n    # Validate conditions for the operation\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n\n        # Validate input page\n        z3.ULT(inpn, dt.NPAGE),\n        old.pages[inpn].owner == old.current,\n        \n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n\n        # Validate input fd if valid\n        z3.Implies(z3.And(infd >= 0, infd < dt.NOFILE),\n                  z3.And(z3.UGT(old.procs[old.current].ofile(infd), 0),\n                        z3.ULT(old.procs[old.current].ofile(infd), dt.NFILE))),\n\n        # Validate output page\n        z3.ULT(outpn, dt.NPAGE),\n        old.pages[outpn].owner == old.current,\n        old.pages[outpn].type != dt.page_type.PAGE_TYPE_FRAME,\n\n        # Ensure pid is not current\n        pid != old.current,\n\n        # Check if receiver accepts sender\n        z3.Or(old.procs[pid].ipc_from == 0,\n              old.procs[pid].ipc_from == old.current)\n    )\n\n    new = old.copy()\n\n    # Set up sender (current process) for waiting\n    new.procs[old.current].ipc_page = outpn\n    new.procs[old.current].ipc_fd = -1  # outfd is always -1 in reply_wait\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n    new.procs[old.current].ipc_from = 0  # Accept any IPC\n\n    # Set up receiver with data\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n    \n    # Copy page data from sender to receiver's ipc_page\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == new.procs[pid].ipc_page,\n               old.pages[inpn].data(idx),\n               oldfn(pn, idx))\n\n    # Handle file descriptor transfer if both infd and receiver's ipc_fd are valid\n    valid_fd_transfer = z3.And(\n        z3.And(infd >= 0, infd < dt.NOFILE),\n        z3.And(old.procs[pid].ipc_fd >= 0, old.procs[pid].ipc_fd < dt.NOFILE)\n    )\n\n    # If fd transfer is valid, update receiver's fd table and file refcounts\n    new.procs[pid].ofile = lambda fd, oldfn: \\\n        util.If(z3.And(valid_fd_transfer, fd == old.procs[pid].ipc_fd),\n               old.procs[old.current].ofile(infd),\n               oldfn(fd))\n\n    new.procs[pid].nr_fds = lambda fd, oldfn: \\\n        util.If(z3.And(valid_fd_transfer, fd == old.procs[pid].ipc_fd),\n               oldfn(fd) + 1,\n               oldfn(fd))\n\n    fn = old.procs[old.current].ofile(infd)\n    new.files[fn].refcnt = lambda pid_fd, oldfn: \\\n        util.If(z3.And(valid_fd_transfer,\n                      pid_fd == (pid, old.procs[pid].ipc_fd)),\n               oldfn(pid_fd) + 1,\n               oldfn(pid_fd))\n\n    # Update process states and ready queue\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "94": {
        "sys_dup2": [
            "\ndef sys_dup2(old, oldfd, pid, newfd):\n    # Validate inputs and check permissions\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or embryo of current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n        \n        # Validate oldfd and newfd\n        z3.And(oldfd >= 0, oldfd < dt.NOFILE),\n        z3.And(newfd >= 0, newfd < dt.NOFILE),\n        \n        # Check if oldfd exists and is valid\n        z3.And(z3.UGT(old.procs[old.current].ofile(oldfd), 0),\n               z3.ULT(old.procs[old.current].ofile(oldfd), dt.NFILE))\n    )\n\n    new = old.copy()\n    \n    # Get the file number from oldfd\n    fn = new.procs[old.current].ofile(oldfd)\n    \n    # Handle case where newfd already exists\n    newfn = new.procs[pid].ofile(newfd)\n    \n    # Clear existing newfd if it exists\n    new_after_clear = new.copy()\n    new_after_clear.procs[pid].ofile[newfd] = z3.BitVecVal(0, dt.fn_t)\n    new_after_clear.procs[pid].nr_fds[newfd] -= 1\n    new_after_clear.files[newfn].refcnt[(pid, newfd)] -= 1\n    \n    # Reset file if refcount becomes 0\n    ref = new_after_clear.files[newfn].refcnt()\n    new_after_clear.files[newfn].type = util.If(ref == 0, \n                                               dt.file_type.FD_NONE, \n                                               new_after_clear.files[newfn].type)\n    new_after_clear.files[newfn].value = util.If(ref == 0,\n                                                z3.BitVecVal(0, dt.uint64_t),\n                                                new_after_clear.files[newfn].value)\n    new_after_clear.files[newfn].offset = util.If(ref == 0,\n                                                 z3.BitVecVal(0, dt.size_t),\n                                                 new_after_clear.files[newfn].offset)\n    new_after_clear.files[newfn].omode = util.If(ref == 0,\n                                                z3.BitVecVal(0, dt.uint64_t),\n                                                new_after_clear.files[newfn].omode)\n    \n    # Set up new file descriptor\n    new_after_set = new_after_clear.copy()\n    new_after_set.procs[pid].ofile[newfd] = fn\n    new_after_set.procs[pid].nr_fds[newfd] += 1\n    new_after_set.files[fn].refcnt[(pid, newfd)] += 1\n    \n    # Handle POSIX case: do nothing if same fd in same process\n    final = util.If(z3.And(old.current == pid, oldfd == newfd),\n                   old,\n                   util.If(z3.And(z3.UGT(newfn, 0), z3.ULT(newfn, dt.NFILE)),\n                          new_after_set,\n                          new_after_set))\n\n    return cond, util.If(cond, final, old)\n"
        ]
    },
    "95": {
        "sys_alloc_io_bitmap": [
            "\ndef sys_alloc_io_bitmap(old, pn1, pn2, pn3):\n    cond = z3.And(\n        # Pages must be valid\n        z3.ULT(pn1, dt.NPAGE),\n        z3.ULT(pn2, dt.NPAGE),\n        z3.ULT(pn3, dt.NPAGE),\n        \n        # Pages must be consecutive\n        pn1 + 1 == pn2,\n        pn2 + 1 == pn3,\n        \n        # Process must not already have an I/O bitmap\n        z3.Not(old.procs[old.current].use_io_bitmap),\n        \n        # Pages must be free\n        old.pages[pn1].type == dt.page_type.PAGE_TYPE_FREE,\n        old.pages[pn2].type == dt.page_type.PAGE_TYPE_FREE,\n        old.pages[pn3].type == dt.page_type.PAGE_TYPE_FREE,\n    )\n    \n    new = old.copy()\n    \n    # Allocate the pages\n    new.pages[pn1].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn1].owner = old.current\n    new.pages[pn1].data = z3.BitVecVal(-1, dt.uint64_t)  # All bits set to 1\n    new.procs[old.current].nr_pages[pn1] += 1\n    \n    new.pages[pn2].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn2].owner = old.current\n    new.pages[pn2].data = z3.BitVecVal(-1, dt.uint64_t)  # All bits set to 1\n    new.procs[old.current].nr_pages[pn2] += 1\n    \n    new.pages[pn3].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn3].owner = old.current\n    new.pages[pn3].data = z3.BitVecVal(-1, dt.uint64_t)  # All bits set to 1\n    new.procs[old.current].nr_pages[pn3] += 1\n    \n    # Update process I/O bitmap state\n    new.procs[old.current].io_bitmap_a = pn1\n    new.procs[old.current].io_bitmap_b = pn2\n    new.procs[old.current].use_io_bitmap = z3.BoolVal(True)\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "96": {
        "extintr": [
            "\ndef extintr(old, v):\n    pid = old.vectors[v].owner\n    \n    cond = z3.And(\n        # Check that pid is valid (fixing the bug in the original code)\n        z3.And(pid > 0, pid < dt.NPROC)\n    )\n\n    new = old.copy()\n\n    # Set the interrupt bit in the process's intr bitmap\n    # Calculate word index and bit mask for the interrupt vector\n    word_idx = z3.UDiv(z3.ZeroExt(64 - v.size(), v), 64)\n    bit_mask = 1 << (v % 64)\n    \n    # Update the interrupt bitmap\n    new.procs[pid].intr = new.procs[pid].intr | bit_mask\n\n    # If process is sleeping, wake it up and set IPC values\n    new.procs[pid].state = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        dt.proc_state.PROC_RUNNABLE,\n        old.procs[pid].state\n    )\n\n    new.procs[pid].ipc_from = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.BitVecVal(0, dt.pid_t),\n        old.procs[pid].ipc_from\n    )\n\n    new.procs[pid].ipc_val = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.ZeroExt(64 - v.size(), v),\n        old.procs[pid].ipc_val\n    )\n\n    new.procs[pid].ipc_size = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.BitVecVal(0, dt.size_t),\n        old.procs[pid].ipc_size\n    )\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "97": {
        "sys_map_pml4": [
            "\ndef sys_map_pml4(old, pid, index, perm):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # the pid is either current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # from is the process's page table root\n        z3.ULT(old.procs[pid].page_table_root, dt.NPAGE),\n        old.pages[old.procs[pid].page_table_root].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[old.procs[pid].page_table_root].owner == pid,\n\n        # Index is a valid page index\n        z3.ULT(index, 512),\n\n        # perm has no unsafe bits and is present and non-writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # index does not have the P bit in the page table root\n        old.pages[old.procs[pid].page_table_root].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the PML4 to itself at the specified index\n    new.pages[new.procs[pid].page_table_root].data[index] = (\n        (z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + \n         new.procs[pid].page_table_root) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[new.procs[pid].page_table_root].pgtable_pn[index] = new.procs[pid].page_table_root\n    new.pages[new.procs[pid].page_table_root].pgtable_perm[index] = perm\n    new.pages[new.procs[pid].page_table_root].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "98": {
        "sys_map_page_desc": [
            "\ndef sys_map_page_desc(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate pid is valid and is either current or embryo\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate number of pages doesn't exceed page descriptor table size\n        z3.ULT(n, dt.NPAGES_PAGE_DESC_TABLE),\n\n        # Validate source page is valid PT and owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions - must be present but not writable\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n\n        # Validate target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0\n    )\n\n    new = old.copy()\n\n    # Calculate physical frame number for page descriptor table\n    pfn = z3.UDiv(new.page_desc_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n\n\n    # Update page table entry\n    new.pages[frm].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "99": {
        "sys_map_proc": [
            "\ndef sys_map_proc(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate number of pages doesn't exceed process table size\n        z3.ULT(n, dt.NPAGES_PROC_TABLE),\n\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # Check if pid is current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index is within page table bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions - no unsafe bits and must be present\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        # Must not be writable\n        perm & dt.PTE_W == 0,\n\n        # Entry must be empty (not present)\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Calculate physical frame number for proc_table + offset\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.proc_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PROC\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "100": {
        "sys_map_dev": [
            "\ndef sys_map_dev(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate pid and process relationship\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate number of pages\n        z3.ULT(n, dt.NPAGES_DEVICES),\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # Ensure target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Calculate physical frame number for device mapping\n    # pfn = (uintptr_t)devices / PAGE_SIZE + n + 4\n    pfn = z3.UDiv(new.devices_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n + 4\n\n    # Update page table entry\n    new.pages[frm].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_DEVICES\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "101": {
        "sys_map_file": [
            "\ndef sys_map_file(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        z3.ULT(n, dt.NPAGES_FILE_TABLE),\n\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # the pid is either current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # frm is a valid pn of type PT whose owner is pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Index is a valid page index\n        z3.ULT(index, 512),\n\n        # perm has no unsafe bits on it and it is present and non-writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # index does not have the P bit in the from page\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.file_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_FILE_TABLE\n\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "102": {
        "sys_alloc_pd": [
            "\ndef sys_alloc_pd(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PDPT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check that the slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page in the PDPT\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PD\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "103": {
        "sys_alloc_pt": [
            "\ndef sys_alloc_pt(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PD owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check that the target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page table entry\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the page table page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PT\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "104": {
        "sys_alloc_frame": [
            "\ndef sys_alloc_frame(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process permissions\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Ensure target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Update page table entry to map the new frame\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the frame page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FRAME\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)  # Zero the page contents\n    new.procs[pid].nr_pages[to] += 1\n\n    # Invalidate TLB after mapping\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "105": {
        "sys_copy_frame": [
            "\ndef sys_copy_frame(old, frm, pid, to):\n    cond = z3.And(\n        # Validate source frame\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[frm].owner == old.current,\n\n        # Validate target process\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Validate target frame\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[to].owner == pid,\n\n        # Check permissions (current or embryo)\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO))\n    )\n\n    new = old.copy()\n\n    # Copy all data from source frame to target frame\n    new.pages[to].data = lambda idx, oldfn: old.pages[frm].data(idx)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "106": {
        "sys_protect_frame": [
            "\ndef sys_protect_frame(old, pt, index, frame, perm):\n    cond = z3.And(\n        # Validate pt is a valid page table page owned by current process\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate frame is a valid frame page owned by current process\n        z3.ULT(frame, dt.NPAGE), \n        old.pages[frame].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[frame].owner == old.current,\n\n        # Validate the page table entry exists and is present\n        old.pages[pt].data(index) & dt.PTE_P != 0,\n\n        # Validate the entry matches the specified frame\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) == z3.Extract(51, 12, old.pages[pt].data(index)),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0\n    )\n\n    new = old.copy()\n\n    # Update the page table entry with new permissions while preserving frame number\n    new.pages[pt].data[index] = (\n        (z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) << dt.PTE_PFN_SHIFT) | perm\n\n    # Update the shadow permission tracking\n    new.pages[pt].pgtable_perm[index] = perm\n\n    # Invalidate TLB for the current process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "107": {
        "sys_free_pd": [
            "\ndef sys_free_pd(old, frm, index, to):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Check page types\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PD,\n        \n        # Check ownership\n        old.pages[frm].owner == old.current,\n        old.pages[to].owner == old.current,\n        \n        # Validate index\n        z3.ULT(index, 512),\n        \n        # Check if entry is present\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify the entry matches the expected page\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == \n            z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n    \n    new = old.copy()\n    \n    # Free the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] -= 1\n    \n    # Clear the PDPT entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow pgtable entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n    \n    # Invalidate TLB\n    new.flush_tlb(old.current)\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "108": {
        "sys_free_pt": [
            "\ndef sys_free_pt(old, frm, index, to):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Validate page types\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PT,\n        \n        # Validate ownership\n        old.pages[frm].owner == old.current,\n        old.pages[to].owner == old.current,\n        \n        # Validate index\n        z3.ULT(index, 512),\n        \n        # Validate entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify the physical address in the PD entry matches the PT page\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == \n            z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the PT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    \n    # Decrement the page count for the process\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the PD entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "109": {
        "sys_free_frame": [
            "\ndef sys_free_frame(old, frm, index, to):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Check page types\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FRAME,\n        \n        # Check ownership\n        old.pages[frm].owner == old.current,\n        old.pages[to].owner == old.current,\n        \n        # Validate index\n        z3.ULT(index, 512),\n        \n        # Check if entry is present\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify the entry matches the frame\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == \n            z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the frame page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the page table entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "110": {
        "sys_reclaim_page": [
            "\ndef sys_reclaim_page(old, pn):\n    # Validate page number and check conditions\n    cond = z3.And(\n        # Page number must be valid\n        z3.ULT(pn, dt.NPAGE),\n        \n        # Page must not already be free\n        old.pages[pn].type != dt.page_type.PAGE_TYPE_FREE,\n        \n        # Owner pid must be valid and process must be zombie\n        z3.And(\n            z3.UGT(old.pages[pn].owner, 0),\n            z3.ULT(old.pages[pn].owner, dt.NPROC),\n            old.procs[old.pages[pn].owner].state == dt.proc_state.PROC_ZOMBIE\n        ),\n        \n        # Process must not have any devices\n        old.procs[old.pages[pn].owner].nr_devs == 0\n    )\n\n    new = old.copy()\n\n    # Update page metadata\n    new.pages[pn].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[pn].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[pn].data = z3.BitVecVal(0, 64)\n\n    # Decrement the process's page count\n    pid = old.pages[pn].owner\n    new.procs[pid].nr_pages[pn] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "111": {
        "sys_set_runnable": [
            "\ndef sys_set_runnable(old, pid):\n    cond = z3.And(\n        # Check pid is valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check parent relationship\n        old.procs[pid].ppid == old.current,\n        \n        # Check process is in embryo state\n        old.procs[pid].state == dt.proc_state.PROC_EMBRYO\n    )\n\n    new = old.copy()\n\n    # Update process state to runnable\n    new.procs[pid].state = dt.proc_state.PROC_RUNNABLE\n\n    # Add to ready list by updating ready queue links\n    new.procs[pid].ready.next = old.current\n    new.procs[pid].ready.prev = old.procs[old.current].ready.prev\n    new.procs[old.procs[old.current].ready.prev].ready.next = pid\n    new.procs[old.current].ready.prev = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "112": {
        "switch_proc": [
            "\ndef switch_proc(old, pid):\n    # Validate pid and process state\n    cond = z3.And(\n        # Check pid is valid (note: original code had incorrect logic)\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check process is runnable (note: original code had incorrect logic)\n        old.procs[pid].state == dt.proc_state.PROC_RUNNABLE\n    )\n\n    new = old.copy()\n\n    # Only perform state changes if switching to a different process\n    new.procs = lambda p, oldfn: util.If(old.current != pid,\n        util.If(p == old.current,\n            # Update old process state\n            util.If(oldfn(p).state == dt.proc_state.PROC_RUNNING,\n                util.If(oldfn(p).killed,\n                    # If killed, transition to zombie\n                    z3.Store(oldfn(p), 'state', dt.proc_state.PROC_ZOMBIE),\n                    # Otherwise transition to runnable\n                    z3.Store(oldfn(p), 'state', dt.proc_state.PROC_RUNNABLE)\n                ),\n                oldfn(p)\n            ),\n            util.If(p == pid,\n                # Update new process state\n                z3.Store(oldfn(p), 'state', dt.proc_state.PROC_RUNNING),\n                oldfn(p))\n        ),\n        oldfn(p)\n    )\n\n    # Update current process\n    new.current = util.If(old.current != pid, pid, old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "113": {
        "sys_kill": [
            "\ndef sys_kill(old, pid):\n    cond = z3.And(\n        # Validate pid is in valid range\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Process must not be unused or zombie\n        z3.Not(z3.Or(\n            old.procs[pid].state == dt.proc_state.PROC_UNUSED,\n            old.procs[pid].state == dt.proc_state.PROC_ZOMBIE\n        ))\n    )\n\n    new = old.copy()\n\n    # Mark process as killed\n    new.procs[pid].killed = z3.BoolVal(True)\n\n    # If process is running, transition to zombie and remove from ready queue\n    new.procs[pid].state = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_RUNNING,\n        dt.proc_state.PROC_ZOMBIE,\n        old.procs[pid].state\n    )\n\n    # Remove from ready queue if running (by zeroing next/prev pointers)\n    new.procs[pid].ready.next = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_RUNNING,\n        z3.BitVecVal(0, dt.pid_t),\n        old.procs[pid].ready.next\n    )\n    new.procs[pid].ready.prev = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_RUNNING,\n        z3.BitVecVal(0, dt.pid_t),\n        old.procs[pid].ready.prev\n    )\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "114": {
        "sys_reap": [
            "\ndef sys_reap(old, pid):\n    cond = z3.And(\n        # Valid pid check\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Parent process check\n        old.procs[pid].ppid == old.current,\n        \n        # Process must be zombie\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # All resources must be freed\n        old.procs[pid].nr_devs == 0,\n        old.procs[pid].nr_children == 0,\n        old.procs[pid].nr_fds == 0,\n        old.procs[pid].nr_pages == 0,\n        old.procs[pid].nr_dmapages == 0,\n        old.procs[pid].nr_ports == 0,\n        old.procs[pid].nr_vectors == 0,\n        old.procs[pid].nr_intremaps == 0\n    )\n\n    new = old.copy()\n\n    # Decrement parent's child count\n    new.procs[old.current].nr_children[pid] -= 1\n\n    # Reset process state and attributes\n    new.procs[pid].state = dt.proc_state.PROC_UNUSED\n    new.procs[pid].ppid = z3.BitVecVal(0, dt.pid_t)\n    new.procs[pid].page_table_root = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].stack = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].hvm = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].launched = z3.BoolVal(False)\n    new.procs[pid].killed = z3.BoolVal(False)\n    new.procs[pid].use_io_bitmap = z3.BoolVal(False)\n    new.procs[pid].io_bitmap_a = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].io_bitmap_b = z3.BitVecVal(0, dt.pn_t)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "115": {
        "sys_reparent": [
            "\ndef sys_reparent(old, pid):\n    cond = z3.And(\n        # Validate pid exists\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Parent must be in zombie state\n        old.procs[old.procs[pid].ppid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Init process must be runnable or running\n        z3.Or(\n            old.procs[dt.INITPID].state == dt.proc_state.PROC_RUNNABLE,\n            old.procs[dt.INITPID].state == dt.proc_state.PROC_RUNNING\n        )\n    )\n\n    new = old.copy()\n\n    old_parent = old.procs[pid].ppid\n\n    # Update parent pointer\n    new.procs[pid].ppid = dt.INITPID\n\n    # Decrement old parent's child count\n    new.procs[old_parent].nr_children[pid] -= 1\n\n    # Increment init's child count\n    new.procs[dt.INITPID].nr_children[pid] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "116": {
        "recv_proc": [
            "\ndef recv_proc(old, pid, pn, fd):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_RUNNABLE,\n        \n        # Validate page number and ownership\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].owner == old.current,\n        old.pages[pn].type == dt.page_type.PAGE_TYPE_FRAME,\n        \n        # Validate file descriptor\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        z3.Or(\n            old.procs[old.current].ofile(fd) == 0,\n            z3.Not(z3.And(\n                z3.UGT(old.procs[old.current].ofile(fd), 0),\n                z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)\n            ))\n        ),\n        \n        # Current process must be different from pid\n        old.current != pid\n    )\n\n    new = old.copy()\n\n    # Update IPC state for current process\n    new.procs[old.current].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.procs[old.current].ipc_page = pn\n    new.procs[old.current].ipc_size = z3.BitVecVal(0, dt.size_t)\n    new.procs[old.current].ipc_fd = fd\n\n    # Update process states\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n    \n    # Update current process\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "117": {
        "call_proc": [
            "\ndef call_proc(old, pid, val, inpn, size, outpn, outfd):\n    # Validate inputs and check conditions\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        \n        # Validate input page\n        z3.ULT(inpn, dt.NPAGE),\n        old.pages[inpn].owner == old.current,\n        z3.ULE(size, dt.PAGE_SIZE),\n        \n        # Validate output page\n        z3.ULT(outpn, dt.NPAGE),\n        old.pages[outpn].owner == old.current,\n        old.pages[outpn].type == dt.page_type.PAGE_TYPE_FRAME,\n        \n        # Validate output fd\n        z3.Or(\n            outfd < 0,\n            z3.And(\n                z3.And(outfd >= 0, outfd < dt.NOFILE),\n                old.procs[old.current].ofile(outfd) == 0\n            )\n        ),\n        \n        # Ensure target process accepts our IPC\n        z3.Or(\n            old.procs[pid].ipc_from == 0,\n            old.procs[pid].ipc_from == old.current\n        ),\n        \n        # Ensure pid != current\n        pid != old.current\n    )\n\n    new = old.copy()\n\n    # Update sender's IPC state\n    new.procs[old.current].ipc_page = outpn\n    new.procs[old.current].ipc_fd = outfd\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n\n    # Update receiver's IPC state\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Copy data from input page to receiver's IPC page\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == new.procs[pid].ipc_page,\n                old.pages[inpn].data(idx),\n                oldfn(pn, idx))\n\n    # Set current process to target process\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "118": {
        "sys_create": [
            "\ndef sys_create(old, fd, fn, type, value, omode):\n    cond = z3.And(\n        # Type must not be FD_NONE\n        type != dt.file_type.FD_NONE,\n\n        # fd must be valid\n        z3.And(fd >= 0, fd < dt.NOFILE),\n\n        # fd must be empty in current process\n        old.procs[old.current].ofile(fd) == 0,\n\n        # fn must be valid\n        z3.And(z3.UGT(fn, 0), z3.ULT(fn, dt.NFILE)),\n\n        # fn must be unused (refcount == 0)\n        old.files[fn].refcnt() == 0\n    )\n\n    new = old.copy()\n\n    # Initialize file attributes\n    new.files[fn].type = type\n    new.files[fn].value = value\n    new.files[fn].omode = omode\n    new.files[fn].offset = z3.BitVecVal(0, dt.off_t)\n\n    # Update process file descriptor table\n    new.procs[old.current].ofile[fd] = fn\n    new.procs[old.current].nr_fds[fd] += 1\n\n    # Update file reference count\n    new.files[fn].refcnt[(old.current, fd)] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "119": {
        "sys_close": [
            "\ndef sys_close(old, pid, fd):\n    cond = z3.And(\n        # pid must be valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # fd must be valid\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        \n        # permission check: either current process or zombie process\n        z3.Or(pid == old.current,\n              old.procs[pid].state == dt.proc_state.PROC_ZOMBIE),\n        \n        # fd must exist\n        z3.And(z3.UGT(old.procs[pid].ofile(fd), 0),\n               z3.ULT(old.procs[pid].ofile(fd), dt.NFILE))\n    )\n\n    new = old.copy()\n    \n    # Get the file number before clearing\n    fn = old.procs[pid].ofile(fd)\n    \n    # Clear the fd entry\n    new.procs[pid].ofile[fd] = z3.BitVecVal(0, dt.fn_t)\n    \n    # Decrement the process's fd count\n    new.procs[pid].nr_fds[fd] -= 1\n    \n    # Decrement file refcount\n    new.files[fn].refcnt[(pid, fd)] -= 1\n    \n    # Get the new refcount\n    ref = new.files[fn].refcnt()\n    \n    # If refcount reaches 0, clear the file slot\n    new.files[fn].type = util.If(ref == 0, dt.file_type.FD_NONE, new.files[fn].type)\n    new.files[fn].value = util.If(ref == 0, z3.BitVecVal(0, dt.uint64_t), new.files[fn].value)\n    new.files[fn].offset = util.If(ref == 0, z3.BitVecVal(0, dt.off_t), new.files[fn].offset)\n    new.files[fn].omode = util.If(ref == 0, z3.BitVecVal(0, dt.uint64_t), new.files[fn].omode)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "120": {
        "sys_dup": [
            "\ndef sys_dup(old, oldfd, pid, newfd):\n    cond = z3.And(\n        # pid must be valid\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # pid must be current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # oldfd must be valid and exist in current process\n        z3.And(oldfd >= 0, oldfd < dt.NOFILE),\n        z3.And(z3.UGT(old.procs[old.current].ofile(oldfd), 0), \n               z3.ULT(old.procs[old.current].ofile(oldfd), dt.NFILE)),\n\n        # newfd must be valid and not exist in target process\n        z3.And(newfd >= 0, newfd < dt.NOFILE),\n        old.procs[pid].ofile(newfd) == 0,\n    )\n\n    new = old.copy()\n\n    # Get the file number from the old fd\n    fn = new.procs[old.current].ofile(oldfd)\n\n    # Set the new file descriptor\n    new.procs[pid].ofile[newfd] = fn\n\n    # Increment the process's fd count\n    new.procs[pid].nr_fds[newfd] += 1\n\n    # Increment the file's reference count\n    new.files[fn].refcnt[(pid, newfd)] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "121": {
        "sys_lseek": [
            "\ndef sys_lseek(old, fd, offset):\n    # Validate fd is within bounds and get the file number\n    cond = z3.And(\n        # fd must be valid\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        \n        # file number must exist and be valid\n        z3.And(z3.UGT(old.procs[old.current].ofile(fd), 0), \n               z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)),\n        \n        # file must be an inode\n        old.files[old.procs[old.current].ofile(fd)].type == dt.file_type.FD_INODE,\n        \n        # offset must be non-negative\n        offset >= 0\n    )\n\n    new = old.copy()\n    \n    # Get the file number from the process's fd table\n    fn = old.procs[old.current].ofile(fd)\n    \n    # Update the file offset\n    new.files[fn].offset = offset\n    \n    # Return the new offset value\n    return cond, util.If(cond, new, old), offset\n"
        ]
    },
    "122": {
        "sys_map_pcipage": [
            "\ndef sys_map_pcipage(old, pt, index, pcipn, perm):\n    cond = z3.And(\n        # Check if pcipn is valid and the page is marked as valid\n        z3.ULT(pcipn, dt.NPCIPAGE),\n        old.pcipages[pcipn].valid,\n\n        # Check if current process owns the pci page through device ownership\n        old.pci[old.pcipages[pcipn].devid].owner == old.current,\n\n        # Validate pt is a valid page number\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Index is a valid page index\n        z3.ULT(index, 512),\n\n        # Check permissions are valid\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check if the target entry is empty\n        old.pages[pt].data(index) & dt.PTE_P == 0\n    )\n\n    new = old.copy()\n\n    # Calculate PCI page physical frame number\n    pfn = z3.UDiv(dt.PCI_START, dt.PAGE_SIZE) + pcipn\n\n    # Update the page table entry with the PCI page mapping\n    new.pages[pt].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[pt].pgtable_pn[index] = pcipn\n    new.pages[pt].pgtable_perm[index] = perm\n    new.pages[pt].pgtable_type[index] = dt.PGTYPE_PCIPAGE\n\n    # Invalidate TLB for the current process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "123": {
        "sys_alloc_iommu_root": [
            "\ndef sys_alloc_iommu_root(old, devid, pn):\n    cond = z3.And(\n        # Device ID should not be already allocated\n        old.pci[devid].owner == 0,\n        \n        # Page number should be valid and free\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].type == dt.page_type.PAGE_TYPE_FREE,\n    )\n\n    new = old.copy()\n\n    # Associate device with current process\n    new.pci[devid].owner = old.current\n    new.pci[devid].page_table_root = pn\n\n    # Allocate and initialize the page\n    new.pages[pn].type = dt.page_type.PAGE_TYPE_IOMMU_PML4\n    new.pages[pn].owner = old.current\n    new.pages[pn].data = z3.BitVecVal(0, 64)\n\n    # Update process device count\n    new.procs[old.current].nr_devs[devid] += 1\n    # Update process page count\n    new.procs[old.current].nr_pages[pn] += 1\n\n    # Flush IOTLB to ensure changes are visible\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "124": {
        "sys_alloc_iommu_pdpt": [
            "\ndef sys_alloc_iommu_pdpt(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Check source page type and ownership\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PML4,\n        old.pages[frm].owner == old.current,\n        \n        # Check target page is free\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n        \n        # Validate index\n        z3.ULT(index, 512),\n        \n        # Check permissions - only allow read/write bits\n        perm & (dt.MAX_INT64 ^ (dt.PTE_P | dt.PTE_W)) == 0,\n        \n        # Check entry is empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Map the page table entry\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n                                          z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Maintain shadow page table info\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Allocate the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PDPT\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Maintain shadow page table for new PDPT\n    new.pages[to].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_perm = z3.BitVecVal(0, 64) \n    new.pages[to].pgtable_type = dt.PGTYPE_NONE\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "125": {
        "sys_alloc_iommu_pd": [
            "\ndef sys_alloc_iommu_pd(old, frm, index, to, perm):\n    # Validation conditions\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Check source page type and ownership\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PDPT,\n        old.pages[frm].owner == old.current,\n        \n        # Check target page is free\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n        \n        # Validate index is within bounds\n        z3.ULT(index, 512),\n        \n        # Check permissions - only PTE_P and PTE_W allowed\n        perm & ~(dt.PTE_P | dt.PTE_W) == 0,\n        \n        # Check entry is empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Calculate next level for IOMMU entry\n    next_level = dt.page_type.PAGE_TYPE_IOMMU_FRAME - 1 - dt.page_type.PAGE_TYPE_IOMMU_PDPT\n\n    # Map the page table entry\n    new.pages[frm].data[index] = (z3.UDiv(new.pages_ptr_to_int, \n                                         z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.DMAR_PTE_ADDR_SHIFT | perm\n\n    # Update shadow page table metadata\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Allocate the target page as IOMMU PD\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PD\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "126": {
        "sys_alloc_iommu_pt": [
            "\ndef sys_alloc_iommu_pt(old, frm, index, to, perm):\n    # Preconditions that must be satisfied\n    cond = z3.And(\n        # Validate page numbers are in range\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Verify source page is IOMMU PD type and owned by current process\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PD,\n        old.pages[frm].owner == old.current,\n        \n        # Verify target page is free\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n        \n        # Validate index is within bounds\n        z3.ULT(index, 512),\n        \n        # Verify permissions only include read/write bits\n        perm & (dt.MAX_INT64 ^ (dt.DMAR_PTE_R | dt.DMAR_PTE_W)) == 0,\n        \n        # Verify the entry is empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Calculate next level type (PT is one level below PD)\n    next_level = dt.page_type.PAGE_TYPE_IOMMU_FRAME - 1 - dt.page_type.PAGE_TYPE_IOMMU_PD\n\n    # Map the page table entry\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n                                          z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Maintain shadow page table metadata\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Allocate the target page as IOMMU PT\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PT\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "127": {
        "sys_alloc_iommu_frame": [
            "\ndef sys_alloc_iommu_frame(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate DMA page number\n        z3.ULT(to, dt.NDMAPAGE),\n        old.dmapages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions (only PTE_P and PTE_W allowed)\n        perm & (dt.MAX_INT64 ^ (dt.PTE_P | dt.PTE_W)) == 0,\n\n        # Entry must be empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Map the page in IOMMU page table\n    new.pages[frm].data[index] = ((new.dmapages_ptr_to_int + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Update the \"shadow\" pgtable metadata\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_IOMMU_FRAME\n\n    # Change DMA page type and ownership\n    new.dmapages[to].type = dt.page_type.PAGE_TYPE_IOMMU_FRAME\n    new.dmapages[to].owner = old.current\n\n    # Update process DMA page count\n    new.procs[old.current].nr_dmapages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "128": {
        "sys_map_iommu_frame": [
            "\ndef sys_map_iommu_frame(old, pt, index, to, perm):\n    cond = z3.And(\n        # Validate the IOMMU frame\n        z3.ULT(to, dt.NDMAPAGE),\n        old.dmapages[to].type == dt.page_type.PAGE_TYPE_IOMMU_FRAME,\n        old.dmapages[to].owner == old.current,\n\n        # Validate the page table\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Entry must be empty\n        old.pages[pt].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Calculate physical frame number for the IOMMU frame\n    pfn = z3.UDiv(new.dmapages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to\n\n    # Update the page table entry\n    new.pages[pt].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[pt].pgtable_pn[index] = to\n    new.pages[pt].pgtable_perm[index] = perm\n    new.pages[pt].pgtable_type[index] = dt.PGTYPE_IOMMU_FRAME\n\n    # Invalidate TLB for the current process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "129": {
        "sys_reclaim_iommu_frame": [
            "\ndef sys_reclaim_iommu_frame(old, dmapn):\n    cond = z3.And(\n        # Check if dmapn is valid\n        z3.ULT(dmapn, dt.NDMAPAGE),\n        \n        # Check if page is NOT free (bug in original code had incorrect logic)\n        old.dmapages[dmapn].type != dt.page_type.PAGE_TYPE_FREE,\n        \n        # Get owner pid and verify it's a valid pid\n        z3.And(old.dmapages[dmapn].owner > 0, \n               old.dmapages[dmapn].owner < dt.NPROC),\n        \n        # Check if process is in zombie state\n        old.procs[old.dmapages[dmapn].owner].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Check if process has no devices\n        old.procs[old.dmapages[dmapn].owner].nr_devs() == 0\n    )\n\n    new = old.copy()\n\n    pid = old.dmapages[dmapn].owner\n\n    # Mark page as free\n    new.dmapages[dmapn].type = dt.page_type.PAGE_TYPE_FREE\n    new.dmapages[dmapn].owner = z3.BitVecVal(0, dt.pid_t)\n\n    # Decrement process's dmapage count (bug in original code incremented instead)\n    new.procs[pid].nr_dmapages[dmapn] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "130": {
        "sys_reclaim_iommu_root": [
            "\ndef sys_reclaim_iommu_root(old, devid):\n    pid = old.pci[devid].owner\n\n    cond = z3.And(\n        # Check if pid is valid and process is in zombie state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Check that there are no active interrupt remapping entries\n        old.procs[pid].nr_intremaps() == 0\n    )\n\n    new = old.copy()\n\n    # Decrement (not increment) the device count for the process\n    new.procs[pid].nr_devs[devid] -= 1\n\n    # Clear the device ownership\n    new.pci[devid].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Clear the page table root for the device\n    new.pci[devid].page_table_root = z3.BitVecVal(0, dt.pn_t)\n\n    # Flush the IOTLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "131": {
        "sys_alloc_vector": [
            "\ndef sys_alloc_vector(old, vector):\n    cond = z3.And(\n        # Check that vector is free (owner is 0)\n        old.vectors[vector].owner == 0\n    )\n\n    new = old.copy()\n\n    # Assign the vector to current process\n    new.vectors[vector].owner = old.current\n    \n    # Increment the vector count for the current process\n    new.procs[old.current].nr_vectors[vector] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "132": {
        "sys_reclaim_vector": [
            "\ndef sys_reclaim_vector(old, vector):\n    # Get the owner of the vector\n    pid = old.vectors[vector].owner\n    \n    cond = z3.And(\n        # Verify pid is valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Vector must be owned by a process\n        pid != 0,\n        \n        # Process must be in zombie state\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Process must not have any interrupt remappings\n        old.procs[pid].nr_intremaps == 0\n    )\n\n    new = old.copy()\n    \n    # Clear vector ownership\n    new.vectors[vector].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Decrement vector count for the process\n    new.procs[pid].nr_vectors[vector] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "133": {
        "sys_alloc_intremap": [
            "\ndef sys_alloc_intremap(old, index, devid, vector):\n    cond = z3.And(\n        # Index must be valid and the entry must be free\n        z3.ULT(index, dt.NINTREMAP),\n        old.intremaps[index].state == dt.intremap_state.IR_FREE,\n        \n        # Device must be owned by current process\n        old.pci[devid].owner == old.current,\n        \n        # Vector must be owned by current process\n        old.vectors[vector].owner == old.current\n    )\n\n    new = old.copy()\n\n    # Update intremap entry state\n    new.intremaps[index].state = dt.intremap_state.IR_ACTIVE\n    new.intremaps[index].devid = devid\n    new.intremaps[index].vector = vector\n\n    # Update process intremap count\n    new.procs[old.current].nr_intremaps[index] += 1\n\n    # Flush IOTLB to ensure changes take effect\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "134": {
        "sys_reclaim_intremap": [
            "\ndef sys_reclaim_intremap(old, index):\n    # Condition checks:\n    # 1. Index must be valid (< NINTREMAP)\n    # 2. Entry must be in ACTIVE state\n    # 3. Associated process must be in ZOMBIE state\n    cond = z3.And(\n        z3.ULT(index, dt.NINTREMAP),\n        old.intremaps[index].state == dt.intremap_state.IR_ACTIVE,\n        \n        # Get the process ID from the PCI device and verify it's a zombie\n        z3.And(\n            old.pci[old.intremaps[index].devid].owner > 0,\n            old.pci[old.intremaps[index].devid].owner < dt.NPROC,\n            old.procs[old.pci[old.intremaps[index].devid].owner].state == dt.proc_state.PROC_ZOMBIE\n        )\n    )\n\n    new = old.copy()\n\n    # Get the process ID that owns this interrupt remapping entry\n    pid = new.pci[new.intremaps[index].devid].owner\n\n    # Update the interrupt remapping entry state\n    new.intremaps[index].state = dt.intremap_state.IR_FREE\n    new.intremaps[index].devid = z3.BitVecVal(0, dt.devid_t)\n    new.intremaps[index].vector = z3.BitVecVal(0, dt.uint8_t)\n\n    # Decrement the process's interrupt remapping count\n    new.procs[pid].nr_intremaps[index] -= 1\n\n    # Flush the IOTLB to ensure hardware state is updated\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "135": {
        "sys_ack_intr": [
            "\ndef sys_ack_intr(old, v):\n    # No preconditions needed as this only operates on the current process's interrupt state\n    cond = z3.BoolVal(True)\n    \n    new = old.copy()\n    \n    # Calculate which word and bit position in the interrupt bitset to clear\n    word_index = z3.UDiv(z3.ZeroExt(64 - v.size(), v), 64)\n    bit_pos = v % 64\n    mask = ~(z3.BitVecVal(1, 64) << bit_pos)\n    \n    # Clear the specific interrupt bit in the process's interrupt bitset\n    new.procs[new.current].intr[word_index] = new.procs[new.current].intr(word_index) & mask\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "136": {
        "sys_alloc_port": [
            "\ndef sys_alloc_port(old, port):\n    cond = z3.And(\n        # Check port is free\n        old.io[port].owner == 0,\n        # Check process has io_bitmap permission\n        old.procs[old.current].use_io_bitmap,\n    )\n\n    new = old.copy()\n\n    # Mark port as owned by current process\n    new.io[port].owner = old.current\n    \n    # Increment port count for process\n    new.procs[old.current].nr_ports[port] += 1\n\n    # Calculate which bitmap and bit position to update\n    page = util.If(z3.ULT(port, 0x8000),\n            new.procs[new.current].io_bitmap_a,\n            new.procs[new.current].io_bitmap_b)\n\n    # Adjust port number for second bitmap\n    port = z3.ZeroExt(64 - port.size(), util.If(z3.ULT(port, 0x8000), port, port - 0x8000))\n\n    # Calculate word and bit position\n    idx = z3.UDiv(port, 64)\n    mask = 1 << (port % 64)\n\n    # Clear the bit in the appropriate bitmap\n    new.pages[page].data[idx] = new.pages[page].data(idx) & ~mask\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "137": {
        "sys_reclaim_port": [
            "\ndef sys_reclaim_port(old, port):\n    # Get the owner of the port\n    pid = old.io[port].owner\n    \n    cond = z3.And(\n        # Port must be valid\n        z3.ULT(port, dt.SZ_64K),\n        \n        # Process must be valid and in zombie state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Port must be owned by the process\n        old.io[port].owner == pid\n    )\n\n    new = old.copy()\n    \n    # Clear the port ownership\n    new.io[port].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Decrement the process's port count\n    new.procs[pid].nr_ports[port] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "138": {
        "sys_alloc_pdpt": [
            "\ndef sys_alloc_pdpt(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PML4 owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check that target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page in the page table\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PDPT\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Initialize the \"shadow\" pgtable for the new page\n    new.pages[to].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_type = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "139": {
        "sys_free_pdpt": [
            "\ndef sys_free_pdpt(old, frm, index, to):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Validate page types\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        \n        # Validate ownership\n        old.pages[frm].owner == old.current,\n        old.pages[to].owner == old.current,\n        \n        # Validate index\n        z3.ULT(index, 512),\n        \n        # Validate entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify the physical address matches\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == \n            z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n    \n    new = old.copy()\n    \n    # Free the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    \n    # Update process page count\n    new.procs[old.current].nr_pages[to] -= 1\n    \n    # Clear the PML4 entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n    \n    # Invalidate TLB\n    new.flush_tlb(old.current)\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "140": {
        "clone_proc": [
            "\ndef clone_proc(old, pid, pml4, stack, hvm):\n    # Validation conditions\n    cond = z3.And(\n        # Valid PID range\n        z3.And(pid > 0, pid < dt.NPROC),\n        # Process must be unused\n        old.procs[pid].state == dt.proc_state.PROC_UNUSED,\n\n        # All pages must be valid and free\n        z3.ULT(pml4, dt.NPAGE),\n        old.pages[pml4].type == dt.page_type.PAGE_TYPE_FREE,\n\n        z3.ULT(stack, dt.NPAGE),\n        old.pages[stack].type == dt.page_type.PAGE_TYPE_FREE,\n\n        z3.ULT(hvm, dt.NPAGE),\n        old.pages[hvm].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Pages must be distinct\n        z3.Distinct(pml4, stack, hvm)\n    )\n\n    new = old.copy()\n\n    # Initialize the new process\n    new.procs[pid].ppid = new.current\n    new.procs[pid].state = dt.proc_state.PROC_EMBRYO\n    new.procs[pid].killed = z3.BoolVal(False)\n    new.procs[pid].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.procs[pid].ipc_val = z3.BitVecVal(0, dt.uint64_t)\n    new.procs[pid].ipc_page = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].ipc_size = z3.BitVecVal(0, dt.size_t)\n    new.procs[pid].ipc_fd = z3.BitVecVal(0, dt.fd_t)\n    new.procs[pid].use_io_bitmap = z3.BoolVal(False)\n    new.procs[pid].io_bitmap_a = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].io_bitmap_b = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].ofile = z3.BitVecVal(0, dt.fn_t)\n    new.procs[pid].intr = z3.BitVecVal(0, 64)\n\n    # Initialize page table root\n    new.pages[pml4].type = dt.page_type.PAGE_TYPE_X86_PML4\n    new.pages[pml4].owner = pid\n    new.pages[pml4].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[pml4] += 1\n    new.procs[pid].page_table_root = pml4\n\n    # Initialize stack\n    new.pages[stack].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[stack].owner = pid\n    new.pages[stack].data = old.pages[old.procs[old.current].stack].data\n    new.procs[pid].nr_pages[stack] += 1\n    new.procs[pid].stack = stack\n\n    # Initialize HVM\n    new.pages[hvm].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[hvm].owner = pid\n    new.pages[hvm].data = old.pages[old.procs[old.current].hvm].data\n    new.procs[pid].nr_pages[hvm] += 1\n    new.procs[pid].hvm = hvm\n\n    # Update parent's child count\n    new.procs[new.current].nr_children[pid] += 1\n\n    # Maintain shadow page table\n    new.pages[pml4].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[pml4].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[pml4].pgtable_type = dt.PGTYPE_NONE\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "141": {
        "send_proc": [
            "\ndef send_proc(old, pid, val, pn, size, fd):\n    cond = z3.And(\n        # Validate pid is valid and process is sleeping\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        \n        # Validate source page number\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].owner == old.current,\n        \n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n        \n        # Validate file descriptor if provided\n        util.If(z3.And(fd >= 0, fd < dt.NOFILE),\n               z3.And(z3.UGT(old.procs[old.current].ofile(fd), 0),\n                     z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)),\n               z3.BoolVal(True)),\n        \n        # Current process cannot send to itself\n        pid != old.current\n    )\n\n    new = old.copy()\n\n    # Update receiver's IPC state\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n\n    # Copy data from sender's page to receiver's IPC page\n    new.pages.data = lambda pn_arg, idx, oldfn: \\\n        util.If(z3.And(pn_arg == new.procs[pid].ipc_page,\n                      z3.ULT(idx, z3.UDiv(size + 7, 8))),\n               oldfn(pn, idx),\n               oldfn(pn_arg, idx))\n\n    # Handle file descriptor transfer if both FDs are valid\n    new2 = util.If(\n        z3.And(\n            z3.And(fd >= 0, fd < dt.NOFILE),\n            z3.And(new.procs[pid].ipc_fd >= 0, new.procs[pid].ipc_fd < dt.NOFILE)\n        ),\n        lambda: (\n            # Set new file descriptor\n            new.procs[pid].ofile[new.procs[pid].ipc_fd] = new.procs[old.current].ofile(fd),\n            # Update file descriptor count\n            new.procs[pid].nr_fds[new.procs[pid].ipc_fd] += 1,\n            # Update file reference count\n            new.files[new.procs[old.current].ofile(fd)].refcnt[(pid, new.procs[pid].ipc_fd)] += 1\n        )[0],\n        new\n    )\n\n    # Update process states\n    new2.procs[old.current].state = dt.proc_state.PROC_RUNNABLE\n    new2.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Set new current process\n    new2.current = pid\n\n    return cond, util.If(cond, new2, old)\n"
        ]
    },
    "142": {
        "reply_wait_proc": [
            "\ndef reply_wait_proc(old, pid, val, inpn, size, infd, outpn):\n    # Validate process, pages, and file descriptors\n    cond = z3.And(\n        # Valid pid and must be sleeping\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        \n        # Input page validation\n        z3.ULT(inpn, dt.NPAGE),\n        old.pages[inpn].owner == old.current,\n        \n        # Size validation\n        z3.ULE(size, dt.PAGE_SIZE),\n        \n        # Input fd validation - either invalid or valid with non-empty file\n        z3.Implies(z3.And(infd >= 0, infd < dt.NOFILE),\n                  z3.And(z3.UGT(old.procs[old.current].ofile(infd), 0),\n                        z3.ULT(old.procs[old.current].ofile(infd), dt.NFILE))),\n        \n        # Output page validation\n        z3.ULT(outpn, dt.NPAGE),\n        old.pages[outpn].owner == old.current,\n        old.pages[outpn].type == dt.page_type.PAGE_TYPE_FRAME,\n        \n        # Receiver must accept sender's IPC\n        z3.Or(old.procs[pid].ipc_from == 0,\n              old.procs[pid].ipc_from == old.current),\n        \n        # Sender and receiver must be different\n        pid != old.current\n    )\n\n    new = old.copy()\n\n    # Set up sender (current process)\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n    new.procs[old.current].ipc_page = outpn\n    new.procs[old.current].ipc_fd = z3.BitVecVal(-1, dt.fd_t)\n    \n    # Set up receiver\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n\n    # Copy data from input page to receiver's IPC page\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == new.procs[pid].ipc_page,\n               old.pages[inpn].data(idx),\n               oldfn(pn, idx))\n\n    # Transfer file descriptor if both infd and receiver's ipc_fd are valid\n    cond_fd = z3.And(\n        z3.And(infd >= 0, infd < dt.NOFILE),\n        z3.And(old.procs[pid].ipc_fd >= 0, old.procs[pid].ipc_fd < dt.NOFILE)\n    )\n\n    # If fd transfer conditions met, update receiver's fd table and refcounts\n    new_with_fd = new.copy()\n    fn = old.procs[old.current].ofile(infd)\n    new_with_fd.procs[pid].ofile[new.procs[pid].ipc_fd] = fn\n    new_with_fd.procs[pid].nr_fds[new.procs[pid].ipc_fd] += 1\n    new_with_fd.files[fn].refcnt[(pid, new.procs[pid].ipc_fd)] += 1\n\n    new = util.If(cond_fd, new_with_fd, new)\n\n    # Accept any IPC and switch current process\n    new.procs[old.current].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "143": {
        "sys_dup2": [
            "\ndef sys_dup2(old, oldfd, pid, newfd):\n    # Validation conditions - note the code has bugs in these checks\n    # that need to be fixed in the specification\n    cond = z3.And(\n        # Check pid is valid (code has incorrect logic)\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # Check pid is current or embryo (code has incorrect logic)\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate oldfd and newfd\n        z3.And(oldfd >= 0, oldfd < dt.NOFILE),\n        z3.And(newfd >= 0, newfd < dt.NOFILE),\n        \n        # Check oldfd exists in current process\n        z3.And(z3.UGT(old.procs[old.current].ofile(oldfd), 0), \n               z3.ULT(old.procs[old.current].ofile(oldfd), dt.NFILE))\n    )\n\n    new1 = old.copy()\n\n    # Get existing file at newfd if any\n    newfn = new1.procs[pid].ofile(newfd)\n\n    # If newfd exists, clear it first\n    new1.procs[pid].ofile[newfd] = z3.BitVecVal(0, dt.fn_t)\n    new1.procs[pid].nr_fds[newfd] -= 1\n    new1.files[newfn].refcnt[(pid, newfd)] -= 1\n\n    ref = new1.files[newfn].refcnt()\n\n    # If refcount reaches 0, clear the file slot\n    new1.files[newfn].type = util.If(ref == 0, dt.file_type.FD_NONE, new1.files[newfn].type)\n    new1.files[newfn].value = util.If(ref == 0, z3.BitVecVal(0, dt.uint64_t), new1.files[newfn].value)\n    new1.files[newfn].offset = util.If(ref == 0, z3.BitVecVal(0, dt.off_t), new1.files[newfn].offset)\n    new1.files[newfn].omode = util.If(ref == 0, z3.BitVecVal(0, dt.uint64_t), new1.files[newfn].omode)\n\n    # Only clear newfd if it existed\n    new2 = util.If(z3.And(z3.UGT(old.procs[pid].ofile(newfd), 0), \n                         z3.ULT(old.procs[pid].ofile(newfd), dt.NFILE)), \n                  new1, old.copy())\n\n    # Get file to duplicate\n    fn = new2.procs[old.current].ofile(oldfd)\n\n    # Set up new file descriptor\n    new2.procs[pid].ofile[newfd] = fn\n    new2.procs[pid].nr_fds[newfd] += 1\n    new2.files[fn].refcnt[(pid, newfd)] += 1\n\n    # POSIX: if fds are the same in same process, do nothing\n    new3 = util.If(z3.And(old.current == pid, oldfd == newfd),\n                   old.copy(), new2)\n\n    return cond, util.If(cond, new3, old)\n"
        ]
    },
    "144": {
        "sys_alloc_io_bitmap": [
            "\ndef sys_alloc_io_bitmap(old, pn1, pn2, pn3):\n    cond = z3.And(\n        # Pages must be valid\n        z3.ULT(pn1, dt.NPAGE),\n        z3.ULT(pn2, dt.NPAGE),\n        z3.ULT(pn3, dt.NPAGE),\n\n        # Pages must be consecutive\n        pn1 + 1 == pn2,\n        pn2 + 1 == pn3,\n\n        # Process must not already have an I/O bitmap\n        z3.Not(old.procs[old.current].use_io_bitmap),\n\n        # All pages must be free\n        old.pages[pn1].type == dt.page_type.PAGE_TYPE_FREE,\n        old.pages[pn2].type == dt.page_type.PAGE_TYPE_FREE,\n        old.pages[pn3].type == dt.page_type.PAGE_TYPE_FREE,\n    )\n\n    new = old.copy()\n\n    # Allocate the pages\n    new.pages[pn1].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn1].owner = old.current\n    new.pages[pn1].data = z3.BitVecVal(0, dt.uint64_t)\n    new.procs[old.current].nr_pages[pn1] += 1\n\n    new.pages[pn2].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn2].owner = old.current\n    # Set all bits to 1s\n    new.pages[pn2].data = z3.BitVecVal(0xffffffffffffffff, dt.uint64_t)\n    new.procs[old.current].nr_pages[pn2] += 1\n\n    new.pages[pn3].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn3].owner = old.current\n    # Set all bits to 1s\n    new.pages[pn3].data = z3.BitVecVal(0xffffffffffffffff, dt.uint64_t)\n    new.procs[old.current].nr_pages[pn3] += 1\n\n    # Update process I/O bitmap state\n    new.procs[old.current].io_bitmap_a = pn1\n    new.procs[old.current].io_bitmap_b = pn2\n    new.procs[old.current].use_io_bitmap = z3.BoolVal(True)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "145": {
        "extintr": [
            "\ndef extintr(old, v):\n    # Get the process ID from the vector table (adding 2 to match implementation)\n    pid = old.vectors[v + 2].owner\n\n    # Validate the process ID\n    cond = z3.And(\n        z3.And(pid > 0, pid < dt.NPROC)\n    )\n\n    new = old.copy()\n\n    # Set the interrupt bit in the process's interrupt mask\n    # Calculate word index and bit mask for the interrupt vector\n    word_idx = z3.UDiv(z3.ZeroExt(64 - v.size(), v), 64)\n    bit_mask = 1 << (v % 64)\n    \n    # Update the interrupt bit\n    new.procs[pid].intr[word_idx] = new.procs[pid].intr(word_idx) | bit_mask\n\n    # If process is sleeping, wake it up and set IPC values\n    new.procs[pid].state = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        dt.proc_state.PROC_RUNNABLE,\n        old.procs[pid].state\n    )\n\n    new.procs[pid].ipc_from = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.BitVecVal(0, dt.pid_t),\n        old.procs[pid].ipc_from\n    )\n\n    new.procs[pid].ipc_val = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.ZeroExt(64 - v.size(), v),\n        old.procs[pid].ipc_val\n    )\n\n    new.procs[pid].ipc_size = util.If(\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.BitVecVal(0, dt.size_t),\n        old.procs[pid].ipc_size\n    )\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "146": {
        "sys_map_pml4": [
            "\ndef sys_map_pml4(old, pid, index, perm):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # The pid is either current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n        \n        # Get the page table root and validate it\n        z3.ULT(old.procs[pid].page_table_root, dt.NPAGE),\n        old.pages[old.procs[pid].page_table_root].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[old.procs[pid].page_table_root].owner == pid,\n        \n        # Index is a valid page index\n        z3.ULT(index, 512),\n        \n        # No unsafe bits in perm and P bit is set\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        \n        # Not writable\n        perm & dt.PTE_W == 0,\n        \n        # Entry must be empty (not present)\n        old.pages[old.procs[pid].page_table_root].data(index) & dt.PTE_P == 0,\n    )\n    \n    new = old.copy()\n    \n    pml4 = new.procs[pid].page_table_root\n    \n    # Map the PML4 to itself at the specified index\n    new.pages[pml4].data[index] = (\n        (z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + pml4) << dt.PTE_PFN_SHIFT) | perm\n    \n    # Maintain the \"shadow\" pgtable\n    new.pages[pml4].pgtable_pn[index] = pml4\n    new.pages[pml4].pgtable_perm[index] = perm\n    new.pages[pml4].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n    \n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "147": {
        "sys_map_page_desc": [
            "\ndef sys_map_page_desc(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # n must be less than the number of pages needed for page descriptors\n        z3.ULT(n, dt.NPAGES_PAGE_DESC_TABLE),\n\n        # pid must be valid and either current or an embryo of current\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # frm must be a valid page table owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Index must be valid and entry must be empty\n        z3.ULT(index, 512),\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n\n        # Permissions must be valid but not writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page descriptor table entry\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.page_desc_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable metadata\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Invalidate TLB after mapping\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "148": {
        "sys_map_proc": [
            "\ndef sys_map_proc(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate number of pages doesn't exceed process table size\n        z3.ULT(n, dt.NPAGES_PROC_TABLE),\n\n        # Validate pid and process ownership\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index is within page table bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # Verify target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Update page table entry to map to process table\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.proc_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PROC\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "149": {
        "sys_map_dev": [
            "\ndef sys_map_dev(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate pid and process relationship\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate number of pages for device mapping\n        z3.ULT(n, dt.NPAGES_DEVICES),\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions - must be present and non-writable\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n\n        # Ensure target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Update page table entry with device mapping\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.devices_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_DEVICES\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "150": {
        "sys_map_file": [
            "\ndef sys_map_file(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate pid and process relationship\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate number of pages\n        z3.ULT(n, dt.NPAGES_FILE_TABLE),\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions - must be present and non-writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # Ensure target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Update page table entry to map the file table\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.file_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_FILE_TABLE\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "151": {
        "sys_alloc_pd": [
            "\ndef sys_alloc_pd(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PDPT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check that the target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page in the PDPT\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PD\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Initialize the \"shadow\" pgtable for the new PD\n    new.pages[to].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_type = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "152": {
        "sys_alloc_pt": [
            "\ndef sys_alloc_pt(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process permissions\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PD owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Validate target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page table in the directory\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the page table page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PT\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Initialize the new page table's \"shadow\" state\n    new.pages[to].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_type = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "153": {
        "sys_alloc_frame": [
            "\ndef sys_alloc_frame(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process relationship\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Ensure target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page in the page table\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable state\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the frame\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FRAME\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Invalidate TLB after mapping\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "154": {
        "sys_copy_frame": [
            "\ndef sys_copy_frame(old, frm, pid, to):\n    cond = z3.And(\n        # Validate source frame\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[frm].owner == old.current,\n\n        # Validate target process\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # Validate target frame\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[to].owner == pid,\n\n        # Permission check: pid must be current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n    )\n\n    new = old.copy()\n\n    # Copy the entire frame data\n    new.pages[to].data = lambda idx, oldfn: old.pages[frm].data(idx)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "155": {
        "sys_protect_frame": [
            "\ndef sys_protect_frame(old, pt, index, frame, perm):\n    cond = z3.And(\n        # Validate pt is a valid page table page owned by current\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate frame is a valid frame page owned by current\n        z3.ULT(frame, dt.NPAGE),\n        old.pages[frame].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[frame].owner == old.current,\n\n        # Validate the page table entry exists and is present\n        old.pages[pt].data(index) & dt.PTE_P != 0,\n\n        # Validate the entry matches the frame\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) == z3.Extract(51, 12, old.pages[pt].data(index)),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0\n    )\n\n    new = old.copy()\n\n    # Update the page table entry with new permissions while preserving the frame address\n    new.pages[pt].data[index] = (\n        (z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) << dt.PTE_PFN_SHIFT) | perm\n\n    # Update the shadow permission tracking\n    new.pages[pt].pgtable_perm[index] = perm\n\n    # Invalidate TLB after permission change\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "156": {
        "sys_free_pd": [
            "\ndef sys_free_pd(old, frm, index, to):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Validate page types\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PD,\n        \n        # Validate ownership\n        old.pages[frm].owner == old.current,\n        old.pages[to].owner == old.current,\n        \n        # Validate index\n        z3.ULT(index, 512),\n        \n        # Validate entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify the physical address matches\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == \n            z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n    \n    new = old.copy()\n    \n    # Free the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    \n    # Update process page count\n    new.procs[old.current].nr_pages[to] -= 1\n    \n    # Clear the PDPT entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n    \n    # Invalidate TLB\n    new.flush_tlb(old.current)\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "157": {
        "sys_free_pt": [
            "\ndef sys_free_pt(old, frm, index, to):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Validate page types\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PT,\n        \n        # Validate ownership\n        old.pages[frm].owner == old.current,\n        old.pages[to].owner == old.current,\n        \n        # Validate index\n        z3.ULT(index, 512),\n        \n        # Validate entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify the physical address in the PD entry matches the PT page\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n    \n    new = old.copy()\n    \n    # Free the PT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    \n    # Update process page count\n    new.procs[old.current].nr_pages[to] -= 1\n    \n    # Clear the PD entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow pgtable entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n    \n    # Invalidate TLB\n    new.flush_tlb(old.current)\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "158": {
        "sys_free_frame": [
            "\ndef sys_free_frame(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm page is valid and of correct type\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to page is valid and of correct type\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[to].owner == old.current,\n\n        # Verify the page table entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify the physical frame number matches\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the frame page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the page table entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "159": {
        "sys_reclaim_page": [
            "\ndef sys_reclaim_page(old, pn):\n    cond = z3.And(\n        # Page number must be valid\n        z3.ULT(pn, dt.NPAGE),\n        \n        # Page must not be already free\n        old.pages[pn].type != dt.page_type.PAGE_TYPE_FREE,\n        \n        # Owner pid must be valid\n        z3.And(old.pages[pn].owner > 0, old.pages[pn].owner < dt.NPROC),\n        \n        # Owner process must be in zombie state\n        old.procs[old.pages[pn].owner].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Process must not have any devices\n        old.procs[old.pages[pn].owner].nr_devs == 0\n    )\n\n    new = old.copy()\n\n    # Reset page ownership\n    new.pages[pn].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Mark page as free\n    new.pages[pn].type = dt.page_type.PAGE_TYPE_FREE\n    \n    # Zero out page data\n    new.pages[pn].data = z3.BitVecVal(0, 64)\n    \n    # Decrement page count for the owner process\n    pid = old.pages[pn].owner\n    new.procs[pid].nr_pages[pn] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "160": {
        "sys_set_runnable": [
            "\ndef sys_set_runnable(old, pid):\n    cond = z3.And(\n        # Validate pid is in valid range\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check parent relationship\n        old.procs[pid].ppid == old.current,\n        \n        # Verify process is in embryo state\n        old.procs[pid].state == dt.proc_state.PROC_EMBRYO\n    )\n\n    new = old.copy()\n\n    # Update process state to runnable\n    new.procs[pid].state = dt.proc_state.PROC_RUNNABLE\n\n    # Add to ready list by updating prev/next pointers\n    # The process is added before the current process in the ready list\n    new.procs[pid].ready.next = new.current\n    new.procs[pid].ready.prev = new.procs[new.current].ready.prev\n    new.procs[new.procs[new.current].ready.prev].ready.next = pid\n    new.procs[new.current].ready.prev = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "161": {
        "switch_proc": [
            "\ndef switch_proc(old, pid):\n    cond = z3.And(\n        # Validate pid is valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Verify target process is runnable\n        old.procs[pid].state == dt.proc_state.PROC_RUNNABLE,\n        \n        # Must be switching to a different process\n        old.current != pid\n    )\n\n    new = old.copy()\n\n    # Update old process state if it was running\n    new.procs[old.current].state = util.If(\n        old.procs[old.current].state == dt.proc_state.PROC_RUNNING,\n        util.If(old.procs[old.current].killed,\n            dt.proc_state.PROC_ZOMBIE,\n            dt.proc_state.PROC_RUNNABLE),\n        old.procs[old.current].state)\n\n    # Set new process as running\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n    \n    # Update current process\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "162": {
        "sys_kill": [
            "\ndef sys_kill(old, pid):\n    cond = z3.And(\n        # Valid pid check\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Process must not be unused or zombie\n        z3.Not(z3.Or(\n            old.procs[pid].state == dt.proc_state.PROC_UNUSED,\n            old.procs[pid].state == dt.proc_state.PROC_ZOMBIE\n        ))\n    )\n\n    new = old.copy()\n\n    # Mark process as killed\n    new.procs[pid].killed = z3.BoolVal(True)\n\n    # If process is running or runnable, transition to zombie and remove from ready queue\n    is_active = z3.Or(\n        old.procs[pid].state == dt.proc_state.PROC_RUNNING,\n        old.procs[pid].state == dt.proc_state.PROC_RUNNABLE\n    )\n\n    new.procs[pid].state = util.If(is_active,\n                                  dt.proc_state.PROC_ZOMBIE,\n                                  old.procs[pid].state)\n\n    # Clear ready queue links if process was active\n    new.procs[pid].ready.prev = util.If(is_active,\n                                       z3.BitVecVal(0, dt.pid_t),\n                                       old.procs[pid].ready.prev)\n    new.procs[pid].ready.next = util.If(is_active,\n                                       z3.BitVecVal(0, dt.pid_t),\n                                       old.procs[pid].ready.next)\n\n    # Update links in ready queue for adjacent processes\n    new.procs[old.procs[pid].ready.prev].ready.next = util.If(is_active,\n                                                             old.procs[pid].ready.next,\n                                                             old.procs[old.procs[pid].ready.prev].ready.next)\n    new.procs[old.procs[pid].ready.next].ready.prev = util.If(is_active,\n                                                             old.procs[pid].ready.prev,\n                                                             old.procs[old.procs[pid].ready.next].ready.prev)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "163": {
        "sys_reap": [
            "\ndef sys_reap(old, pid):\n    cond = z3.And(\n        # pid must be valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # must be child of current process\n        old.procs[pid].ppid == old.current,\n        \n        # must be zombie\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # must have no resources\n        old.procs[pid].nr_devs == 0,\n        old.procs[pid].nr_children == 0,\n        old.procs[pid].nr_fds == 0,\n        old.procs[pid].nr_pages == 0,\n        old.procs[pid].nr_dmapages == 0,\n        old.procs[pid].nr_ports == 0,\n        old.procs[pid].nr_vectors == 0,\n        old.procs[pid].nr_intremaps == 0\n    )\n\n    new = old.copy()\n\n    # Decrement parent's child count\n    new.procs[old.current].nr_children[pid] -= 1\n\n    # Reset process state\n    new.procs[pid].state = dt.proc_state.PROC_UNUSED\n    new.procs[pid].ppid = z3.BitVecVal(0, dt.pid_t)\n    new.procs[pid].page_table_root = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].stack = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].hvm = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].launched = z3.BoolVal(False)\n    new.procs[pid].killed = z3.BoolVal(False)\n    new.procs[pid].use_io_bitmap = z3.BoolVal(False)\n    new.procs[pid].io_bitmap_a = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].io_bitmap_b = z3.BitVecVal(0, dt.pn_t)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "164": {
        "sys_reparent": [
            "\ndef sys_reparent(old, pid):\n    # Validate pid and check process states\n    cond = z3.And(\n        # pid must be valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # parent must be zombie\n        old.procs[old.procs[pid].ppid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # init process must be either runnable or running\n        z3.Or(\n            old.procs[dt.INITPID].state == dt.proc_state.PROC_RUNNABLE,\n            old.procs[dt.INITPID].state == dt.proc_state.PROC_RUNNING\n        )\n    )\n\n    new = old.copy()\n\n    # Get the old parent pid\n    old_ppid = old.procs[pid].ppid\n\n    # Update the parent-child relationships\n    new.procs[pid].ppid = dt.INITPID\n    new.procs[old_ppid].nr_children[pid] -= 1\n    new.procs[dt.INITPID].nr_children[pid] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "165": {
        "recv_proc": [
            "\ndef recv_proc(old, pid, pn, fd):\n    cond = z3.And(\n        # Validate pid is valid and process is runnable\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_RUNNABLE,\n        \n        # Validate page number and ownership\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].owner == old.current,\n        old.pages[pn].type == dt.page_type.PAGE_TYPE_FRAME,\n        \n        # Validate file descriptor if provided\n        z3.Implies(\n            z3.And(fd >= 0, fd < dt.NOFILE),\n            old.procs[old.current].ofile(fd) == 0\n        ),\n        \n        # Current process must be different from target\n        pid != old.current\n    )\n\n    new = old.copy()\n    \n    # Update receiver's IPC state\n    new.procs[old.current].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.procs[old.current].ipc_page = pn\n    new.procs[old.current].ipc_size = z3.BitVecVal(0, dt.size_t)\n    new.procs[old.current].ipc_fd = fd\n    \n    # Update process states\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n    \n    # Update current process\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "166": {
        "call_proc": [
            "\ndef call_proc(old, pid, val, inpn, size, outpn, outfd):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n\n        # Validate input page\n        z3.ULT(inpn, dt.NPAGE),\n        old.pages[inpn].owner == old.current,\n        \n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n\n        # Validate output page\n        z3.ULT(outpn, dt.NPAGE),\n        old.pages[outpn].owner == old.current,\n        old.pages[outpn].type == dt.page_type.PAGE_TYPE_FRAME,\n\n        # Validate output fd\n        z3.Or(\n            outfd < 0,\n            z3.And(\n                outfd >= 0,\n                outfd < dt.NOFILE,\n                old.procs[old.current].ofile(outfd) == 0\n            )\n        ),\n\n        # Check if receiver accepts sender\n        z3.Or(\n            old.procs[pid].ipc_from == 0,\n            old.procs[pid].ipc_from == old.current\n        ),\n\n        # Ensure pid != current\n        pid != old.current\n    )\n\n    new = old.copy()\n\n    # Set up sender's IPC state\n    new.procs[old.current].ipc_page = outpn\n    new.procs[old.current].ipc_fd = outfd\n\n    # Set up receiver's IPC state\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n\n    # Copy data from input page to receiver's IPC page\n    new.pages[new.procs[pid].ipc_page].data = lambda idx, oldfn: \\\n        util.If(z3.ULT(idx, z3.UDiv(size + 7, 8)),\n               old.pages[inpn].data(idx),\n               oldfn(idx))\n\n    # Update process states\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Reset IPC state of current-4 process\n    new.procs[old.current - 4].ipc_from = pid\n\n    # Switch current process\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "167": {
        "sys_create": [
            "\ndef sys_create(old, fd, fn, type, value, omode):\n    cond = z3.And(\n        # type must not be FD_NONE\n        type != dt.file_type.FD_NONE,\n\n        # fd must be valid\n        z3.And(fd >= 0, fd < dt.NOFILE),\n\n        # fd must be empty in current process\n        old.procs[old.current].ofile(fd) == 0,\n\n        # fn must be valid\n        z3.And(z3.UGT(fn, 0), z3.ULT(fn, dt.NFILE)),\n\n        # fn must be unused (refcount == 0)\n        old.files[fn].refcnt() == 0,\n    )\n\n    new = old.copy()\n\n    # Initialize file attributes\n    new.files[fn].type = type\n    new.files[fn].value = value\n    new.files[fn].omode = omode\n    new.files[fn].offset = z3.BitVecVal(0, dt.off_t)\n\n    # Set file descriptor and update refcounts\n    new.procs[old.current].ofile[fd] = fn\n    new.procs[old.current].nr_fds[fd] += 1\n    new.files[fn].refcnt[(old.current, fd)] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "168": {
        "sys_close": [
            "\ndef sys_close(old, pid, fd):\n    cond = z3.And(\n        # Valid pid check\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Valid fd check\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        \n        # Permission check: either current process or zombie process\n        z3.Or(pid == old.current,\n              old.procs[pid].state == dt.proc_state.PROC_ZOMBIE),\n        \n        # File descriptor must exist and be valid\n        z3.And(z3.UGT(old.procs[pid].ofile(fd), 0),\n               z3.ULT(old.procs[pid].ofile(fd), dt.NFILE))\n    )\n\n    new = old.copy()\n    \n    # Get the file number before clearing\n    fn = old.procs[pid].ofile(fd)\n    \n    # Clear the file descriptor\n    new.procs[pid].ofile[fd] = z3.BitVecVal(0, dt.fn_t)\n    \n    # Decrement the process's fd count\n    new.procs[pid].nr_fds[fd] -= 1\n    \n    # Decrement file refcount\n    new.files[fn].refcnt[(pid, fd)] -= 1\n    \n    # Get updated refcount\n    ref = new.files[fn].refcnt()\n    \n    # If refcount reaches 0, clear the file slot\n    new.files[fn].type = util.If(ref == 0, dt.file_type.FD_NONE, new.files[fn].type)\n    new.files[fn].value = util.If(ref == 0, z3.BitVecVal(0, dt.uint64_t), new.files[fn].value)\n    new.files[fn].offset = util.If(ref == 0, z3.BitVecVal(0, dt.off_t), new.files[fn].offset)\n    new.files[fn].omode = util.If(ref == 0, z3.BitVecVal(0, dt.uint64_t), new.files[fn].omode)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "169": {
        "sys_dup": [
            "\ndef sys_dup(old, oldfd, pid, newfd):\n    cond = z3.And(\n        # pid must be valid\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # pid must be current or an embryo of current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # oldfd must be valid and exist\n        z3.And(oldfd >= 0, oldfd < dt.NOFILE),\n        z3.And(z3.UGT(old.procs[old.current].ofile(oldfd), 0), \n               z3.ULT(old.procs[old.current].ofile(oldfd), dt.NFILE)),\n\n        # newfd must be valid and not exist\n        z3.And(newfd >= 0, newfd < dt.NOFILE),\n        old.procs[pid].ofile(newfd) == 0,\n    )\n\n    new = old.copy()\n\n    # Get the file number from the old fd\n    fn = new.procs[old.current].ofile(oldfd)\n\n    # Set up the new file descriptor\n    new.procs[pid].ofile[newfd] = fn\n    new.procs[pid].nr_fds[newfd] += 1\n\n    # Increment the file's reference count\n    new.files[fn].refcnt[(pid, newfd)] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "170": {
        "sys_lseek": [
            "\ndef sys_lseek(old, fd, offset):\n    cond = z3.And(\n        # fd must be valid\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        \n        # file number must be valid\n        z3.And(z3.UGT(old.procs[old.current].ofile(fd), 0), \n               z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)),\n        \n        # file must be an inode\n        old.files[old.procs[old.current].ofile(fd)].type == dt.file_type.FD_INODE,\n        \n        # offset must be non-negative\n        offset >= 0\n    )\n\n    new = old.copy()\n    \n    # Update the file offset\n    fn = new.procs[new.current].ofile(fd)\n    new.files[fn].offset = offset\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "171": {
        "sys_map_pcipage": [
            "\ndef sys_map_pcipage(old, pt, index, pcipn, perm):\n    cond = z3.And(\n        # Check if pcipn is valid and the page is marked as valid\n        z3.ULT(pcipn, dt.NPCIPAGE),\n        old.pcipages[pcipn].valid,\n\n        # Check if current process owns the pci device\n        old.pcipages[pcipn].owner == old.pci[old.pcipages[pcipn].owner].owner,\n        old.pci[old.pcipages[pcipn].owner].owner == old.current,\n\n        # Validate pt is a valid page table owned by current\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Index is a valid page index\n        z3.ULT(index, 512),\n\n        # Check permissions are valid\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check the target entry is empty\n        old.pages[pt].data(index) & dt.PTE_P == 0\n    )\n\n    new = old.copy()\n\n    # Calculate PCI page physical frame number\n    pfn = z3.UDiv(dt.PCI_START, dt.PAGE_SIZE) + pcipn\n\n    # Update the page table entry with PCI page mapping\n    new.pages[pt].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[pt].pgtable_pn[index] = pcipn\n    new.pages[pt].pgtable_perm[index] = perm\n    new.pages[pt].pgtable_type[index] = dt.PGTYPE_PCIPAGE\n\n    # Invalidate TLB for the process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "172": {
        "sys_alloc_iommu_root": [
            "\ndef sys_alloc_iommu_root(old, devid, pn):\n    cond = z3.And(\n        # Device must not be in use\n        old.pci[devid].owner == 0,\n        \n        # Page must be free and valid\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].type == dt.page_type.PAGE_TYPE_FREE,\n    )\n\n    new = old.copy()\n\n    # Assign device to current process\n    new.pci[devid].owner = old.current\n    new.procs[old.current].nr_devs[devid] += 1\n\n    # Allocate and initialize the IOMMU root page\n    new.pages[pn].type = dt.page_type.PAGE_TYPE_IOMMU_PML4\n    new.pages[pn].owner = old.current\n    new.pages[pn].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[pn] += 1\n\n    # Set the device's page table root\n    new.pci[devid].page_table_root = pn\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "173": {
        "sys_alloc_iommu_pdpt": [
            "\ndef sys_alloc_iommu_pdpt(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Check page types\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PML4,\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n        \n        # Verify ownership\n        old.pages[frm].owner == old.current,\n        \n        # Validate index\n        z3.ULT(index, 512),\n        \n        # Check permissions - only allow read/write bits\n        perm & (dt.MAX_INT64 ^ (dt.DMAR_PTE_R | dt.DMAR_PTE_W)) == 0,\n        \n        # Verify target entry is empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Map the PDPT page in the PML4\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm | \\\n        z3.BitVecVal(dt.page_type.PAGE_TYPE_IOMMU_PDPT - dt.page_type.PAGE_TYPE_IOMMU_PML4 - 1, 64)\n\n    # Maintain shadow page table info\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Allocate and initialize the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PDPT\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "174": {
        "sys_alloc_iommu_pd": [
            "\ndef sys_alloc_iommu_pd(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Verify 'to' page is free\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n        \n        # Verify 'from' page type and ownership\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PDPT,\n        old.pages[frm].owner == old.current,\n        \n        # Validate index is within bounds\n        z3.ULT(index, 512),\n        \n        # Verify permissions only include read/write bits\n        perm & (dt.MAX_INT64 ^ (dt.PTE_P | dt.PTE_W)) == 0,\n        \n        # Verify the entry is empty\n        old.pages[frm].data(index) == 0\n    )\n    \n    new = old.copy()\n    \n    # Calculate physical address for the page\n    pa = z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to\n    \n    # Calculate next level type (PD is one level below PDPT)\n    next_level = dt.page_type.PAGE_TYPE_IOMMU_FRAME - 1 - dt.page_type.PAGE_TYPE_IOMMU_PDPT\n    \n    # Update the page table entry\n    new.pages[frm].data[index] = (pa << dt.DMAR_PTE_ADDR_SHIFT) | perm | (next_level << 10)\n    \n    # Update the \"shadow\" page table tracking\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n    \n    # Allocate the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PD\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n    \n    # Flush IOMMU TLB\n    new.flush_iotlb()\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "175": {
        "sys_alloc_iommu_pt": [
            "\ndef sys_alloc_iommu_pt(old, frm, index, to, perm):\n    # Validate inputs and check conditions\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Check page types\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PD,\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n        \n        # Verify ownership\n        old.pages[frm].owner == old.current,\n        \n        # Validate index\n        z3.ULT(index, 512),\n        \n        # Check permissions - only allow read/write bits\n        perm & ~(dt.DMAR_PTE_R | dt.DMAR_PTE_W) == 0,\n        \n        # Verify entry is empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Calculate next level type (PT is one level below PD)\n    next_level = dt.page_type.PAGE_TYPE_IOMMU_FRAME - 1 - dt.page_type.PAGE_TYPE_IOMMU_PD\n\n    # Map the page table entry\n    new.pages[frm].data[index] = ((new.pages_ptr_to_int + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm | next_level\n\n    # Maintain shadow page table info\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the PT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PT\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)  # Zero the page contents\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "176": {
        "sys_alloc_iommu_frame": [
            "\ndef sys_alloc_iommu_frame(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate the DMA page number is valid and free\n        z3.ULT(to, dt.NDMAPAGE),\n        old.dmapages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate the source page is valid IOMMU PT and owned by current\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions only include read/write bits\n        perm & (dt.MAX_INT64 ^ (dt.PTE_P | dt.PTE_W)) == 0,\n\n        # Entry must be empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Map the IOMMU page table entry\n    new.pages[frm].data[index] = ((new.dmapages_ptr_to_int + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Update shadow page table metadata\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_IOMMU_FRAME\n\n    # Allocate the DMA page as IOMMU frame\n    new.dmapages[to].type = dt.page_type.PAGE_TYPE_IOMMU_FRAME\n    new.dmapages[to].owner = old.current\n    new.procs[old.current].nr_dmapages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "177": {
        "sys_map_iommu_frame": [
            "\ndef sys_map_iommu_frame(old, pt, index, to, perm):\n    cond = z3.And(\n        # Validate the DMA page number is valid and has correct type/owner\n        z3.ULT(to, dt.NDMAPAGE),\n        old.dmapages[to].type == dt.page_type.PAGE_TYPE_IOMMU_FRAME,\n        old.dmapages[to].owner == old.current,\n\n        # Validate the page table page\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Index must be valid page table index\n        z3.ULT(index, 512),\n\n        # Entry must be empty (not present)\n        old.pages[pt].data(index) & dt.PTE_P == 0,\n\n        # Permission bits must be valid\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0\n    )\n\n    new = old.copy()\n\n    # Calculate physical frame number for DMA page\n    pfn = z3.UDiv(new.dmapages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to\n\n    # Update page table entry with physical frame number and permissions\n    new.pages[pt].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[pt].pgtable_pn[index] = to\n    new.pages[pt].pgtable_perm[index] = perm\n    new.pages[pt].pgtable_type[index] = dt.PGTYPE_IOMMU_FRAME\n\n    # Invalidate TLB for the process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "178": {
        "sys_reclaim_iommu_frame": [
            "\ndef sys_reclaim_iommu_frame(old, dmapn):\n    cond = z3.And(\n        # Validate DMA page number\n        z3.ULT(dmapn, dt.NDMAPAGE),\n        \n        # Check that page is NOT free (bug in original code had incorrect logic)\n        old.dmapages[dmapn].type != dt.page_type.PAGE_TYPE_FREE,\n        \n        # Get owner pid from page descriptor\n        z3.And(old.dmapages[dmapn].owner > 0, old.dmapages[dmapn].owner < dt.NPROC),\n        \n        # Check that owner process is in zombie state\n        old.procs[old.dmapages[dmapn].owner].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Check that process has no devices in use (bug in original code had incorrect logic)\n        old.procs[old.dmapages[dmapn].owner].nr_devs() == 0\n    )\n\n    new = old.copy()\n    \n    pid = old.dmapages[dmapn].owner\n\n    # Update the DMA page state\n    new.dmapages[dmapn].type = dt.page_type.PAGE_TYPE_FREE\n    new.dmapages[dmapn].owner = z3.BitVecVal(0, dt.pid_t)\n\n    # Decrement the process's DMA page count (bug in original code incremented instead)\n    new.procs[pid].nr_dmapages[dmapn] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "179": {
        "sys_reclaim_iommu_root": [
            "\ndef sys_reclaim_iommu_root(old, devid):\n    # Get the process that owns this device\n    pid = old.pci[devid].owner\n    \n    cond = z3.And(\n        # Process must be valid and in zombie state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Process must not have any interrupt remapping entries\n        old.procs[pid].nr_intremaps() == 0\n    )\n\n    new = old.copy()\n\n    # Decrement the device count for the process\n    new.procs[pid].nr_devs[devid] -= 1\n\n    # Clear the device ownership\n    new.pci[devid].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Clear the device's page table root\n    new.pci[devid].page_table_root = z3.BitVecVal(0, dt.pn_t)\n\n    # Flush the IOTLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "180": {
        "sys_alloc_vector": [
            "\ndef sys_alloc_vector(old, vector):\n    cond = z3.And(\n        # Check if vector is free (vector_table[vector] == 0)\n        old.vectors[vector].owner == 0\n    )\n\n    new = old.copy()\n\n    # Assign vector to current process\n    new.vectors[vector].owner = old.current\n    \n    # Increment the vector count for the current process\n    new.procs[old.current].nr_vectors[vector] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "181": {
        "sys_reclaim_vector": [
            "\ndef sys_reclaim_vector(old, vector):\n    pid = old.vectors[vector].owner\n    \n    cond = z3.And(\n        # Check that pid is valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Process must be in ZOMBIE state\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Process must not have any interrupt remappings\n        old.procs[pid].nr_intremaps == 0\n    )\n\n    new = old.copy()\n    \n    # Clear vector ownership\n    new.vectors[vector].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Decrement vector count for the process\n    new.procs[pid].nr_vectors[vector] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "182": {
        "sys_alloc_intremap": [
            "\ndef sys_alloc_intremap(old, index, devid, vector):\n    cond = z3.And(\n        # Check index is valid and entry is free\n        z3.ULT(index, dt.NINTREMAP),\n        old.intremaps[index].state == dt.intremap_state.IR_FREE,\n\n        # Check device and vector ownership\n        old.pci[devid].owner == old.current,\n        old.vectors[vector].owner == old.current\n    )\n\n    new = old.copy()\n\n    # Update intremap entry state\n    new.intremaps[index].state = dt.intremap_state.IR_ACTIVE\n    new.intremaps[index].devid = devid\n    new.intremaps[index].vector = vector\n\n    # Increment process's intremap count\n    new.procs[old.current].nr_intremaps[index] += 1\n\n    # Flush IOTLB since we modified IOMMU state\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "183": {
        "sys_reclaim_intremap": [
            "\ndef sys_reclaim_intremap(old, index):\n    # Conditions for valid execution\n    cond = z3.And(\n        # Check if index is valid\n        z3.ULT(index, dt.NINTREMAP),\n        \n        # Check if the entry is active\n        old.intremaps[index].state == dt.intremap_state.IR_ACTIVE,\n        \n        # Get the process ID from PCI table using the device ID\n        z3.And(old.pci[old.intremaps[index].devid].owner > 0,\n               old.pci[old.intremaps[index].devid].owner < dt.NPROC),\n        \n        # Check if the process is in zombie state\n        old.procs[old.pci[old.intremaps[index].devid].owner].state == dt.proc_state.PROC_ZOMBIE\n    )\n\n    new = old.copy()\n\n    # Update the interrupt remapping entry state\n    new.intremaps[index].state = dt.intremap_state.IR_FREE\n    new.intremaps[index].devid = z3.BitVecVal(0, dt.devid_t)\n    new.intremaps[index].vector = z3.BitVecVal(0, dt.uint8_t)\n\n    # Decrement the process's intremap count\n    new.procs[old.pci[old.intremaps[index].devid].owner].nr_intremaps[index] -= 1\n\n    # Flush the IOTLB to ensure hardware state is updated\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "184": {
        "sys_ack_intr": [
            "\ndef sys_ack_intr(old, v):\n    # No preconditions needed since this just operates on current process\n    # and the interrupt vector is a uint8_t which can't be invalid\n    \n    new = old.copy()\n    \n    # Calculate which word and bit position in the intr bitset\n    idx = z3.UDiv(z3.ZeroExt(64 - v.size(), v), 64)\n    mask = 1 << (z3.ZeroExt(64 - v.size(), v) % 64)\n    \n    # Clear the interrupt bit by AND-ing with inverse of the mask\n    new.procs[new.current].intr[idx] = new.procs[new.current].intr(idx) & ~mask\n    \n    # Always succeeds, so return True condition\n    return z3.BoolVal(True), new\n"
        ]
    },
    "185": {
        "sys_alloc_port": [
            "\ndef sys_alloc_port(old, port):\n    cond = z3.And(\n        # Port must be within valid range (16-bit)\n        z3.ULT(port, 0x10000),\n        \n        # Port must be free (owner is 0)\n        old.io[port].owner == 0,\n        \n        # Process must have io_bitmap permission\n        old.procs[old.current].use_io_bitmap,\n        \n        # IO bitmap pages must be valid\n        z3.ULT(old.procs[old.current].io_bitmap_a, dt.NPAGE),\n        z3.ULT(old.procs[old.current].io_bitmap_b, dt.NPAGE)\n    )\n\n    new = old.copy()\n\n    # Mark port as owned by current process\n    new.io[port].owner = old.current\n    \n    # Update process's port refcount\n    new.procs[old.current].nr_ports[port] += 1\n\n    # Calculate which bitmap page and bit to modify\n    page = util.If(z3.ULT(port, 0x8000),\n                  new.procs[new.current].io_bitmap_a,\n                  new.procs[new.current].io_bitmap_b)\n    \n    # Adjust port number for second bitmap\n    port_idx = z3.ZeroExt(64 - port.size(), \n                         util.If(z3.ULT(port, 0x8000),\n                                port,\n                                port - 0x8000))\n\n    # Calculate word and bit position\n    word_idx = z3.UDiv(port_idx, 64)\n    bit_mask = 1 << (port_idx % 64)\n\n    # Clear the bit in the appropriate bitmap\n    new.pages[page].data[word_idx] = new.pages[page].data(word_idx) & ~bit_mask\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "186": {
        "sys_reclaim_port": [
            "\ndef sys_reclaim_port(old, port):\n    # Get the owner of the port\n    pid = old.io[port].owner\n\n    # Check conditions:\n    # 1. pid must be valid (> 0 and < NPROC)\n    # 2. process must be in ZOMBIE state\n    cond = z3.And(\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE\n    )\n\n    new = old.copy()\n\n    # Clear the port ownership\n    new.io[port].owner = z3.BitVecVal(0, dt.pid_t)\n\n    # Decrement the process's port count\n    new.procs[pid].nr_ports[port] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "187": {
        "sys_alloc_pdpt": [
            "\ndef sys_alloc_pdpt(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PML4 owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check that target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page in the page table\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PDPT\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Initialize the \"shadow\" pgtable for the new page\n    new.pages[to].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_type = dt.PGTYPE_NONE\n\n    # Invalidate TLB after page table modification\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "188": {
        "sys_free_pdpt": [
            "\ndef sys_free_pdpt(old, frm, index, to):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Validate page types\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        \n        # Validate ownership\n        old.pages[frm].owner == old.current,\n        old.pages[to].owner == old.current,\n        \n        # Validate index\n        z3.ULT(index, 512),\n        \n        # Validate entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify physical address matches\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n    \n    new = old.copy()\n    \n    # Free the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    \n    # Update process page count\n    new.procs[old.current].nr_pages[to] -= 1\n    \n    # Clear the PML4 entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n    \n    # Invalidate TLB\n    new.flush_tlb(old.current)\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "189": {
        "clone_proc": [
            "\ndef clone_proc(old, pid, pml4, stack, hvm):\n    # Validation conditions\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_UNUSED,\n\n        # Validate pages are valid and free\n        z3.ULT(pml4, dt.NPAGE),\n        old.pages[pml4].type == dt.page_type.PAGE_TYPE_FREE,\n\n        z3.ULT(stack, dt.NPAGE),\n        old.pages[stack].type == dt.page_type.PAGE_TYPE_FREE,\n\n        z3.ULT(hvm, dt.NPAGE),\n        old.pages[hvm].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Ensure pages are distinct\n        z3.Distinct(pml4, stack, hvm)\n    )\n\n    new = old.copy()\n\n    # Initialize process state\n    new.procs[pid].ppid = new.current\n    new.procs[pid].state = dt.proc_state.PROC_EMBRYO\n    new.procs[pid].killed = z3.BoolVal(False)\n    new.procs[pid].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.procs[pid].ipc_val = z3.BitVecVal(0, dt.uint64_t)\n    new.procs[pid].ipc_page = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].ipc_size = z3.BitVecVal(0, dt.size_t)\n    new.procs[pid].ipc_fd = z3.BitVecVal(0, dt.fd_t)\n    new.procs[pid].use_io_bitmap = z3.BoolVal(False)\n    new.procs[pid].io_bitmap_a = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].io_bitmap_b = z3.BitVecVal(0, dt.pn_t)\n\n    # Initialize file descriptors and interrupts\n    new.procs[pid].ofile = z3.BitVecVal(0, dt.fn_t)\n    new.procs[pid].intr = z3.BitVecVal(0, 64)\n\n    # Allocate and initialize PML4 page\n    new.pages[pml4].type = dt.page_type.PAGE_TYPE_X86_PML4\n    new.pages[pml4].owner = pid\n    new.pages[pml4].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[pml4] += 1\n    new.procs[pid].page_table_root = pml4\n\n    # Initialize page table metadata\n    new.pages[pml4].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[pml4].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[pml4].pgtable_type = dt.PGTYPE_NONE\n\n    # Allocate and initialize stack page\n    new.pages[stack].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[stack].owner = pid\n    new.pages[stack].data = old.pages[old.procs[old.current].stack].data\n    new.procs[pid].nr_pages[stack] += 1\n    new.procs[pid].stack = stack\n\n    # Allocate and initialize HVM page\n    new.pages[hvm].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[hvm].owner = pid\n    new.pages[hvm].data = old.pages[old.procs[old.current].hvm].data\n    new.procs[pid].nr_pages[hvm] += 1\n    new.procs[pid].hvm = hvm\n\n    # Update parent's child count\n    new.procs[new.current].nr_children[pid] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "190": {
        "send_proc": [
            "\ndef send_proc(old, pid, val, pn, size, fd):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        \n        # Validate page number and ownership\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].owner == old.current,\n        \n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n        \n        # Validate file descriptor if provided\n        z3.Implies(\n            z3.And(fd >= 0, fd < dt.NOFILE),\n            z3.And(\n                z3.UGT(old.procs[old.current].ofile(fd), 0),\n                z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)\n            )\n        ),\n        \n        # Ensure pid is not current\n        pid != old.current\n    )\n\n    new = old.copy()\n\n    # Update receiver's IPC state\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n\n    # Copy data from sender's page to receiver's IPC page\n    new.pages[new.procs[pid].ipc_page].data = lambda idx, oldfn: \\\n        util.If(z3.ULT(idx, z3.UDiv(size, 8)),\n                old.pages[pn].data(idx),\n                oldfn(idx))\n\n    # Handle file descriptor transfer if both FDs are valid\n    cond_fd = z3.And(\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        z3.And(old.procs[pid].ipc_fd >= 0, old.procs[pid].ipc_fd < dt.NOFILE),\n        old.procs[pid].ofile(old.procs[pid].ipc_fd) == 0\n    )\n\n    # If FDs are valid, transfer the file descriptor\n    fn = old.procs[old.current].ofile(fd)\n    new.procs[pid].ofile[old.procs[pid].ipc_fd] = util.If(cond_fd, fn, old.procs[pid].ofile(old.procs[pid].ipc_fd))\n    new.procs[pid].nr_fds[old.procs[pid].ipc_fd] = util.If(cond_fd, \n        new.procs[pid].nr_fds(old.procs[pid].ipc_fd) + 1,\n        new.procs[pid].nr_fds(old.procs[pid].ipc_fd))\n    new.files[fn].refcnt[(pid, old.procs[pid].ipc_fd)] = util.If(cond_fd,\n        new.files[fn].refcnt((pid, old.procs[pid].ipc_fd)) + 1,\n        new.files[fn].refcnt((pid, old.procs[pid].ipc_fd)))\n\n    # Update process states\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "191": {
        "reply_wait_proc": [
            "\ndef reply_wait_proc(old, pid, val, inpn, size, infd, outpn):\n    # Validate conditions for the operation\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n\n        # Validate input page\n        z3.ULT(inpn, dt.NPAGE),\n        old.pages[inpn].owner == old.current,\n        \n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n\n        # Validate input fd if valid\n        z3.Implies(z3.And(infd >= 0, infd < dt.NOFILE),\n                  z3.And(z3.UGT(old.procs[old.current].ofile(infd), 0),\n                        z3.ULT(old.procs[old.current].ofile(infd), dt.NFILE))),\n\n        # Validate output page\n        z3.ULT(outpn, dt.NPAGE),\n        old.pages[outpn].owner == old.current,\n        old.pages[outpn].type == dt.page_type.PAGE_TYPE_FRAME,\n\n        # Ensure pid != current\n        pid != old.current,\n\n        # Check if receiver accepts sender\n        z3.Or(old.procs[pid].ipc_from == 0,\n              old.procs[pid].ipc_from == old.current)\n    )\n\n    new = old.copy()\n\n    # Set up sender (current process)\n    new.procs[old.current].ipc_page = outpn\n    new.procs[old.current].ipc_fd = z3.BitVecVal(-1, dt.fd_t)\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n\n    # Set up receiver\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Copy data from input page to receiver's page\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == new.procs[pid].ipc_page,\n               old.pages[inpn].data(idx),\n               oldfn(pn, idx))\n\n    # Handle fd transfer if both fds are valid\n    cond_fd = z3.And(\n        z3.And(infd >= 0, infd < dt.NOFILE),\n        z3.And(old.procs[pid].ipc_fd >= 0, old.procs[pid].ipc_fd < dt.NOFILE)\n    )\n\n    # If fd transfer conditions met, update receiver's fd table\n    new.procs[pid].ofile = lambda fd, oldfn: \\\n        util.If(z3.And(cond_fd, fd == old.procs[pid].ipc_fd),\n               old.procs[old.current].ofile(infd),\n               oldfn(fd))\n\n    # Update fd counts and file refcounts if fd transfer occurs\n    new.procs[pid].nr_fds = lambda oldfn: \\\n        util.If(cond_fd,\n               oldfn + 1,\n               oldfn)\n\n    new.files[old.procs[old.current].ofile(infd)].refcnt = lambda oldfn: \\\n        util.If(cond_fd,\n               oldfn + 1,\n               oldfn)\n\n    # Accept any IPC and switch current process\n    new.procs[old.current].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "192": {
        "sys_dup2": [
            "\ndef sys_dup2(old, oldfd, pid, newfd):\n    # Validation conditions - note these are the correct logical conditions\n    # (opposite of the buggy implementation)\n    cond = z3.And(\n        # Validate pid is in valid range\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # Verify pid is either current process or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate oldfd and newfd are in valid range\n        z3.And(oldfd >= 0, oldfd < dt.NOFILE),\n        z3.And(newfd >= 0, newfd < dt.NOFILE),\n\n        # Verify oldfd exists in current process\n        z3.And(z3.UGT(old.procs[old.current].ofile(oldfd), 0), \n               z3.ULT(old.procs[old.current].ofile(oldfd), dt.NFILE))\n    )\n\n    new = old.copy()\n\n    # POSIX: if fds are the same in same process, do nothing\n    same_fd = z3.And(old.current == pid, oldfd == newfd)\n    \n    # Handle the case where newfd needs to be closed first\n    newfn = new.procs[pid].ofile(newfd)\n    has_newfd = z3.And(z3.UGT(newfn, 0), z3.ULT(newfn, dt.NFILE))\n\n    # Clear existing newfd if it exists\n    new.procs[pid].ofile[newfd] = util.If(has_newfd,\n        z3.BitVecVal(0, dt.fn_t),\n        new.procs[pid].ofile(newfd))\n    \n    new.procs[pid].nr_fds[newfd] = util.If(has_newfd,\n        new.procs[pid].nr_fds(newfd) - 1,\n        new.procs[pid].nr_fds(newfd))\n\n    # Update file reference counts\n    new.files[newfn].refcnt[(pid, newfd)] = util.If(has_newfd,\n        new.files[newfn].refcnt() - 1,\n        new.files[newfn].refcnt())\n\n    ref = new.files[newfn].refcnt()\n\n    # Clear file if refcount reaches 0\n    new.files[newfn].type = util.If(z3.And(has_newfd, ref == 0),\n        dt.file_type.FD_NONE,\n        new.files[newfn].type)\n    new.files[newfn].value = util.If(z3.And(has_newfd, ref == 0),\n        z3.BitVecVal(0, dt.uint64_t),\n        new.files[newfn].value)\n    new.files[newfn].offset = util.If(z3.And(has_newfd, ref == 0),\n        z3.BitVecVal(0, dt.off_t),\n        new.files[newfn].offset)\n    new.files[newfn].omode = util.If(z3.And(has_newfd, ref == 0),\n        z3.BitVecVal(0, dt.uint64_t),\n        new.files[newfn].omode)\n\n    # Duplicate the file descriptor\n    fn = new.procs[old.current].ofile(oldfd)\n    \n    new.procs[pid].ofile[newfd] = util.If(same_fd,\n        new.procs[pid].ofile(newfd),\n        fn)\n    \n    new.procs[pid].nr_fds[newfd] = util.If(same_fd,\n        new.procs[pid].nr_fds(newfd),\n        new.procs[pid].nr_fds(newfd) + 1)\n    \n    new.files[fn].refcnt[(pid, newfd)] = util.If(same_fd,\n        new.files[fn].refcnt(),\n        new.files[fn].refcnt() + 1)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "193": {
        "sys_alloc_io_bitmap": [
            "\ndef sys_alloc_io_bitmap(old, pn1, pn2, pn3):\n    cond = z3.And(\n        # Pages must be consecutive\n        pn2 == pn1 + 1,\n        pn3 == pn2 + 1,\n\n        # Process must not already have an IO bitmap\n        z3.Not(old.procs[old.current].use_io_bitmap),\n\n        # All pages must be valid and free\n        z3.ULT(pn1, dt.NPAGE),\n        z3.ULT(pn2, dt.NPAGE),\n        z3.ULT(pn3, dt.NPAGE),\n        old.pages[pn1].type == dt.page_type.PAGE_TYPE_FREE,\n        old.pages[pn2].type == dt.page_type.PAGE_TYPE_FREE,\n        old.pages[pn3].type == dt.page_type.PAGE_TYPE_FREE\n    )\n\n    new = old.copy()\n\n    # Allocate the pages and mark them as process data\n    new.pages[pn1].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn1].owner = new.current\n    new.procs[new.current].nr_pages[pn1] += 1\n\n    new.pages[pn2].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn2].owner = new.current\n    new.procs[new.current].nr_pages[pn2] += 1\n\n    new.pages[pn3].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn3].owner = new.current\n    new.procs[new.current].nr_pages[pn3] += 1\n\n    # Set all bits to 1s in all three pages\n    new.pages[pn1].data = lambda idx, oldfn: dt.MAX_INT64\n    new.pages[pn2].data = lambda idx, oldfn: dt.MAX_INT64\n    new.pages[pn3].data = lambda idx, oldfn: dt.MAX_INT64\n\n    # Update process IO bitmap state\n    new.procs[new.current].io_bitmap_a = pn1\n    new.procs[new.current].io_bitmap_b = pn2\n    new.procs[new.current].use_io_bitmap = z3.BoolVal(True)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "194": {
        "extintr": [
            "\ndef extintr(old, v):\n    # Get the process ID from the vector table\n    pid = old.vectors[v].owner\n\n    # Validate the process ID\n    cond = z3.And(\n        z3.And(pid > 0, pid < dt.NPROC),\n    )\n\n    new = old.copy()\n\n    # Set the interrupt bit in the process's interrupt mask\n    # Calculate word index and bit mask for the interrupt vector\n    word_idx = z3.UDiv(z3.ZeroExt(64 - v.size(), v), 64)\n    bit_mask = 1 << (v % 64)\n    \n    # Update the interrupt bit\n    new.procs[pid].intr[word_idx] = new.procs[pid].intr(word_idx) | bit_mask\n\n    # If process is sleeping, wake it up and set IPC values\n    new.procs[pid].state = util.If(\n        new.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        dt.proc_state.PROC_RUNNABLE,\n        new.procs[pid].state\n    )\n\n    # Set IPC values when process is sleeping\n    new.procs[pid].ipc_from = util.If(\n        new.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.BitVecVal(0, dt.pid_t),\n        new.procs[pid].ipc_from\n    )\n\n    new.procs[pid].ipc_val = util.If(\n        new.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.ZeroExt(64 - v.size(), v),\n        new.procs[pid].ipc_val\n    )\n\n    new.procs[pid].ipc_size = util.If(\n        new.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.BitVecVal(0, dt.size_t),\n        new.procs[pid].ipc_size\n    )\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "195": {
        "sys_map_pml4": [
            "\ndef sys_map_pml4(old, pid, index, perm):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # The pid is either current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Get the page table root\n        z3.ULT(old.procs[pid].page_table_root, dt.NPAGE),\n        old.pages[old.procs[pid].page_table_root].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[old.procs[pid].page_table_root].owner == pid,\n\n        # Index is a valid page index\n        z3.ULT(index, 512),\n\n        # No write permission allowed\n        perm & dt.PTE_W == 0,\n\n        # No unsafe bits in perm is set\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n\n        # P bit is set in perm\n        perm & dt.PTE_P != 0,\n\n        # Entry must be empty\n        old.pages[old.procs[pid].page_table_root].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the PML4 to itself at the specified index\n    new.pages[new.procs[pid].page_table_root].data[index] = (\n        (z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + \n         new.procs[pid].page_table_root) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[new.procs[pid].page_table_root].pgtable_pn[index] = new.procs[pid].page_table_root\n    new.pages[new.procs[pid].page_table_root].pgtable_perm[index] = perm\n    new.pages[new.procs[pid].page_table_root].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "196": {
        "sys_map_page_desc": [
            "\ndef sys_map_page_desc(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate number of pages doesn't exceed page descriptor table size\n        z3.ULT(n, dt.NPAGES_PAGE_DESC_TABLE),\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions - must NOT be writable\n        perm & dt.PTE_W == 0,\n        \n        # Check for unsafe bits in permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        \n        # Ensure permissions are valid (present bit set)\n        perm & dt.PTE_P != 0,\n\n        # Check that target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Update the page table entry to map to page descriptor table\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.page_desc_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable metadata\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "197": {
        "sys_map_proc": [
            "\ndef sys_map_proc(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        z3.ULT(n, dt.NPAGES_PROC_TABLE),\n\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # the pid is either current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # frm is a valid pn of type PT whose owner is pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Index is a valid page index\n        z3.ULT(index, 512),\n\n        # perm has no unsafe bits on it and it is present and non-writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # index does not have the P bit in the from page\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.proc_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PROC\n\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "198": {
        "sys_map_dev": [
            "\ndef sys_map_dev(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        z3.ULT(n, dt.NPAGES_DEVICES),\n\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # the pid is either current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # frm is a valid pn of type PT whose owner is pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Index is a valid page index\n        z3.ULT(index, 512),\n\n        # perm has no unsafe bits on it and it is present and non-writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # index does not have the P bit in the from page\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.devices_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_DEVICES\n\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "199": {
        "sys_map_file": [
            "\ndef sys_map_file(old, pid, frm, index, n, perm):\n    cond = z3.And(\n        # Validate pid and process relationship\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate number of pages\n        z3.ULT(n, dt.NPAGES_FILE_TABLE),\n\n        # Validate permissions - must be present and non-writable\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n        perm & dt.PTE_W == 0,\n\n        # Ensure target entry is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Update page table entry to map the file table\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.file_table_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + n) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable state\n    new.pages[frm].pgtable_pn[index] = n\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_FILE_TABLE\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "200": {
        "sys_alloc_pd": [
            "\ndef sys_alloc_pd(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (from) is a valid PDPT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check that target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page in the PDPT\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PD\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "201": {
        "sys_alloc_pt": [
            "\ndef sys_alloc_pt(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or its embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PD owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check that target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page table entry\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the new PT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PT\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Initialize shadow state for new PT\n    new.pages[to].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_perm = z3.BitVecVal(0, 64) \n    new.pages[to].pgtable_type = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "202": {
        "sys_alloc_frame": [
            "\ndef sys_alloc_frame(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and permissions\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if pid is current or embryo\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PT owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Check that target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page in the page table\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n        z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the frame\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FRAME\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Invalidate TLB\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "203": {
        "sys_copy_frame": [
            "\ndef sys_copy_frame(old, frm, pid, to):\n    cond = z3.And(\n        # from page must be valid and a frame owned by current\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[frm].owner == old.current,\n\n        # pid must be valid and either current or its embryo\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # to page must be valid and a frame owned by pid\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[to].owner == pid,\n    )\n\n    new = old.copy()\n\n    # Copy all data from source frame to target frame\n    new.pages[to].data = lambda idx, oldfn: old.pages[frm].data(idx)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "204": {
        "sys_protect_frame": [
            "\ndef sys_protect_frame(old, pt, index, frame, perm):\n    cond = z3.And(\n        # Validate pt is a valid page table page owned by current process\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate frame is a valid frame page owned by current process\n        z3.ULT(frame, dt.NPAGE), \n        old.pages[frame].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[frame].owner == old.current,\n\n        # Validate the page table entry exists and is present\n        old.pages[pt].data(index) & dt.PTE_P != 0,\n\n        # Validate the entry matches the expected frame\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) == z3.Extract(51, 12, old.pages[pt].data(index)),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0\n    )\n\n    new = old.copy()\n\n    # Update the page table entry with new permissions while preserving frame number\n    new.pages[pt].data[index] = (\n        (z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + frame) << dt.PTE_PFN_SHIFT) | perm\n\n    # Update shadow pgtable permission tracking\n    new.pages[pt].pgtable_perm[index] = perm\n\n    # Invalidate TLB for the current process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "205": {
        "sys_free_pd": [
            "\ndef sys_free_pd(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm page is valid PDPT owned by current process\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to page is valid PD owned by current process\n        z3.ULT(to, dt.NPAGE), \n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[to].owner == old.current,\n\n        # Entry must be present\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n\n        # Entry must point to the specified PD page\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the PDPT entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "206": {
        "sys_free_pt": [
            "\ndef sys_free_pt(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm page is valid and of correct type\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PD,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to page is valid and of correct type\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[to].owner == old.current,\n\n        # Verify entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify physical address matches\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == \n            z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the target page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    \n    # Update process page count\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the page directory entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "207": {
        "sys_free_frame": [
            "\ndef sys_free_frame(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm is a valid page table of type PT owned by current\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to is a valid frame owned by current\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FRAME,\n        old.pages[to].owner == old.current,\n\n        # Verify the page table entry is present\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n\n        # Verify the page table entry points to the correct frame\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the frame by resetting its type and owner\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n\n    # Update process's page count\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the page table entry\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n\n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "208": {
        "sys_reclaim_page": [
            "\ndef sys_reclaim_page(old, pn):\n    # Validate conditions for reclaiming the page\n    cond = z3.And(\n        # Page number must be valid\n        z3.ULT(pn, dt.NPAGE),\n        \n        # Page must not already be free\n        old.pages[pn].type != dt.page_type.PAGE_TYPE_FREE,\n        \n        # Owner process must be valid and in zombie state\n        z3.And(\n            z3.UGT(old.pages[pn].owner, 0),\n            z3.ULT(old.pages[pn].owner, dt.NPROC),\n            old.procs[old.pages[pn].owner].state == dt.proc_state.PROC_ZOMBIE\n        ),\n        \n        # Process must not have any devices\n        old.procs[old.pages[pn].owner].nr_devs == 0\n    )\n\n    new = old.copy()\n\n    # Update page metadata\n    new.pages[pn].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[pn].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[pn].data = z3.BitVecVal(0, 64)\n\n    # Update process page count\n    pid = old.pages[pn].owner\n    new.procs[pid].nr_pages[pn] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "209": {
        "sys_set_runnable": [
            "\ndef sys_set_runnable(old, pid):\n    cond = z3.And(\n        # Check pid validity (fixing the bug in the code)\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check if current process is the parent\n        old.procs[pid].ppid == old.current,\n        \n        # Check if process is in embryo state\n        old.procs[pid].state == dt.proc_state.PROC_EMBRYO\n    )\n\n    new = old.copy()\n\n    # Update process state to runnable\n    new.procs[pid].state = dt.proc_state.PROC_RUNNABLE\n\n    # Add to ready list by updating the ready queue links\n    # Insert before current process\n    new.procs[pid].ready.next = old.current\n    new.procs[pid].ready.prev = old.procs[old.current].ready.prev\n    new.procs[old.procs[old.current].ready.prev].ready.next = pid\n    new.procs[old.current].ready.prev = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "210": {
        "switch_proc": [
            "\ndef switch_proc(old, pid):\n    cond = z3.And(\n        # Validate pid is valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Check target process is runnable\n        old.procs[pid].state == dt.proc_state.PROC_RUNNABLE\n    )\n\n    new = old.copy()\n\n    # Only perform state changes if switching to a different process\n    new.procs[old.current].state = util.If(\n        z3.And(old.current != pid, \n               old.procs[old.current].state == dt.proc_state.PROC_RUNNING),\n        util.If(old.procs[old.current].killed,\n                dt.proc_state.PROC_ZOMBIE,\n                dt.proc_state.PROC_RUNNABLE),\n        old.procs[old.current].state)\n\n    # Update ready queue links if process is killed\n    new.procs[old.current].ready.prev = util.If(\n        z3.And(old.current != pid,\n               old.procs[old.current].state == dt.proc_state.PROC_RUNNING,\n               old.procs[old.current].killed),\n        z3.BitVecVal(0, dt.pid_t),\n        old.procs[old.current].ready.prev)\n\n    new.procs[old.current].ready.next = util.If(\n        z3.And(old.current != pid,\n               old.procs[old.current].state == dt.proc_state.PROC_RUNNING,\n               old.procs[old.current].killed),\n        z3.BitVecVal(0, dt.pid_t),\n        old.procs[old.current].ready.next)\n\n    # Set new process state to running\n    new.procs[pid].state = util.If(\n        old.current != pid,\n        dt.proc_state.PROC_RUNNING,\n        old.procs[pid].state)\n\n    # Update current process\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "211": {
        "sys_kill": [
            "\ndef sys_kill(old, pid):\n    cond = z3.And(\n        # Validate pid is in valid range\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Process must not be unused or zombie\n        z3.Not(z3.Or(\n            old.procs[pid].state == dt.proc_state.PROC_UNUSED,\n            old.procs[pid].state == dt.proc_state.PROC_ZOMBIE\n        ))\n    )\n\n    new = old.copy()\n\n    # Mark process as killed\n    new.procs[pid].killed = z3.BoolVal(True)\n\n    # If process is not running, transition to zombie state and remove from ready queue\n    new.procs[pid].state = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        dt.proc_state.PROC_ZOMBIE,\n        old.procs[pid].state\n    )\n\n    # Update ready queue links only if process is not running\n    new.procs[new.procs[pid].ready.next].ready.prev = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        new.procs[pid].ready.prev,\n        new.procs[new.procs[pid].ready.next].ready.prev\n    )\n\n    new.procs[new.procs[pid].ready.prev].ready.next = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        new.procs[pid].ready.next,\n        new.procs[new.procs[pid].ready.prev].ready.next\n    )\n\n    new.procs[pid].ready.next = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        z3.BitVecVal(0, dt.pid_t),\n        new.procs[pid].ready.next\n    )\n\n    new.procs[pid].ready.prev = util.If(\n        old.procs[pid].state != dt.proc_state.PROC_RUNNING,\n        z3.BitVecVal(0, dt.pid_t),\n        new.procs[pid].ready.prev\n    )\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "212": {
        "sys_reap": [
            "\ndef sys_reap(old, pid):\n    # Validate conditions for reaping\n    cond = z3.And(\n        # Valid pid range\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Must be child of current process\n        old.procs[pid].ppid == old.current,\n        \n        # Must be in zombie state\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Must have no resources\n        old.procs[pid].nr_devs() == 0,\n        old.procs[pid].nr_children() == 0,\n        old.procs[pid].nr_fds() == 0,\n        old.procs[pid].nr_pages() == 0,\n        old.procs[pid].nr_dmapages() == 0,\n        old.procs[pid].nr_ports() == 0,\n        old.procs[pid].nr_vectors() == 0,\n        old.procs[pid].nr_intremaps() == 0\n    )\n\n    new = old.copy()\n\n    # Decrement parent's child count\n    new.procs[old.current].nr_children[pid] -= 1\n\n    # Reset process state and attributes\n    new.procs[pid].state = dt.proc_state.PROC_UNUSED\n    new.procs[pid].ppid = z3.BitVecVal(0, dt.pid_t)\n    new.procs[pid].page_table_root = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].stack = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].hvm = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].launched = z3.BoolVal(False)\n    new.procs[pid].killed = z3.BoolVal(False)\n    new.procs[pid].use_io_bitmap = z3.BoolVal(False)\n    new.procs[pid].io_bitmap_a = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].io_bitmap_b = z3.BitVecVal(0, dt.pn_t)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "213": {
        "sys_reparent": [
            "\ndef sys_reparent(old, pid):\n    cond = z3.And(\n        # Validate pid is valid\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Parent process must be in zombie state\n        old.procs[old.procs[pid].ppid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Init process must be runnable or running\n        z3.Or(\n            old.procs[dt.INITPID].state == dt.proc_state.PROC_RUNNABLE,\n            old.procs[dt.INITPID].state == dt.proc_state.PROC_RUNNING\n        )\n    )\n\n    new = old.copy()\n\n    old_parent = new.procs[pid].ppid\n\n    # Update parent process ID to INITPID\n    new.procs[pid].ppid = dt.INITPID\n\n    # Decrement child count of old parent\n    new.procs[old_parent].nr_children[pid] -= 1\n\n    # Increment child count of init process\n    new.procs[dt.INITPID].nr_children[pid] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "214": {
        "recv_proc": [
            "\ndef recv_proc(old, pid, pn, fd):\n    cond = z3.And(\n        # Validate pid is valid and process is runnable\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_RUNNABLE,\n        \n        # Validate page number, ownership and type\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].owner == old.current,\n        old.pages[pn].type == dt.page_type.PAGE_TYPE_FRAME,\n        \n        # Validate file descriptor\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        z3.Not(z3.And(\n            z3.UGT(old.procs[old.current].ofile(fd), 0),\n            z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)\n        )),\n        \n        # Current process must be different from pid\n        old.current != pid\n    )\n\n    new = old.copy()\n\n    # Update current process (server) IPC state\n    new.procs[old.current].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.procs[old.current].ipc_page = pn\n    new.procs[old.current].ipc_size = z3.BitVecVal(0, dt.size_t)\n    new.procs[old.current].ipc_fd = fd\n\n    # Update process states\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Update current process\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "215": {
        "call_proc": [
            "\ndef call_proc(old, pid, val, inpn, size, outpn, outfd):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        \n        # Validate input page\n        z3.ULT(inpn, dt.NPAGE),\n        old.pages[inpn].owner == old.current,\n        \n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n        \n        # Validate output page\n        z3.ULT(outpn, dt.NPAGE),\n        old.pages[outpn].owner == old.current,\n        old.pages[outpn].type == dt.page_type.PAGE_TYPE_FRAME,\n        \n        # Validate output fd\n        z3.Or(\n            z3.Not(z3.And(outfd >= 0, outfd < dt.NOFILE)),\n            z3.And(outfd >= 0, outfd < dt.NOFILE,\n                  z3.Or(old.procs[old.current].ofile(outfd) == 0,\n                        z3.Not(z3.And(z3.UGT(old.procs[old.current].ofile(outfd), 0),\n                                    z3.ULT(old.procs[old.current].ofile(outfd), dt.NFILE))))),\n        ),\n        \n        # Ensure receiver accepts sender\n        z3.Or(old.procs[pid].ipc_from == 0,\n              old.procs[pid].ipc_from == old.current),\n        \n        # Ensure pid != current\n        pid != old.current\n    )\n\n    new = old.copy()\n\n    # Set up sender's IPC state\n    new.procs[old.current].ipc_page = outpn\n    new.procs[old.current].ipc_fd = outfd\n\n    # Set up receiver's IPC state\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n\n    # Copy data from input page to receiver's IPC page\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(pn == new.procs[pid].ipc_page,\n               old.pages[inpn].data(idx),\n               oldfn(pn, idx))\n\n    # Update process states\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Update ready queue\n    # Remove current from ready queue by setting its prev/next to 0\n    new.procs[old.current].ready.prev = z3.BitVecVal(0, dt.pid_t)\n    new.procs[old.current].ready.next = z3.BitVecVal(0, dt.pid_t)\n\n    # Add receiver to ready queue by linking it before current\n    new.procs[pid].ready.next = old.current\n    new.procs[pid].ready.prev = old.procs[old.current].ready.prev\n    \n    # Update neighbors in ready queue\n    new.procs[new.procs[pid].ready.prev].ready.next = pid\n    new.procs[old.current].ready.prev = pid\n\n    # Set current process to pid\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "216": {
        "sys_create": [
            "\ndef sys_create(old, fd, fn, type, value, omode):\n    cond = z3.And(\n        # type must not be FD_NONE\n        type != dt.file_type.FD_NONE,\n\n        # fd must be valid\n        z3.And(fd >= 0, fd < dt.NOFILE),\n\n        # fd must be empty in current process\n        old.procs[old.current].ofile(fd) == 0,\n\n        # fn must be valid\n        z3.And(z3.UGT(fn, 0), z3.ULT(fn, dt.NFILE)),\n\n        # fn must be unused (refcount == 0)\n        old.files[fn].refcnt() == 0\n    )\n\n    new = old.copy()\n\n    # Initialize the file\n    new.files[fn].type = type\n    new.files[fn].value = value\n    new.files[fn].omode = omode\n    new.files[fn].offset = z3.BitVecVal(0, dt.off_t)\n\n    # Set the file descriptor\n    new.procs[old.current].ofile[fd] = fn\n    new.procs[old.current].nr_fds[fd] += 1\n    new.files[fn].refcnt[(old.current, fd)] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "217": {
        "sys_close": [
            "\ndef sys_close(old, pid, fd):\n    # Validation conditions\n    cond = z3.And(\n        # Validate pid is in valid range\n        z3.And(pid > 0, pid < dt.NPROC),\n        \n        # Validate fd is in valid range\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        \n        # Permission check: either current process or zombie process\n        z3.Or(\n            pid == old.current,\n            old.procs[pid].state == dt.proc_state.PROC_ZOMBIE\n        ),\n        \n        # Check if fd exists and is valid\n        z3.And(\n            z3.UGT(old.procs[pid].ofile(fd), 0),\n            z3.ULT(old.procs[pid].ofile(fd), dt.NFILE)\n        )\n    )\n\n    new = old.copy()\n    \n    # Get the file number associated with this fd\n    fn = old.procs[pid].ofile(fd)\n    \n    # Clear the fd entry in process's ofile array\n    new.procs[pid].ofile[fd] = z3.BitVecVal(0, dt.fn_t)\n    \n    # Decrement the process's fd count\n    new.procs[pid].nr_fds[fd] -= 1\n    \n    # Decrement file's reference count\n    new.files[fn].refcnt[(pid, fd)] -= 1\n    \n    # Get the new reference count\n    ref = new.files[fn].refcnt()\n    \n    # If refcount reaches 0, reset the file's attributes\n    new.files[fn].type = util.If(ref == 0, \n                                dt.file_type.FD_NONE, \n                                new.files[fn].type)\n    new.files[fn].value = util.If(ref == 0,\n                                 z3.BitVecVal(0, dt.uint64_t),\n                                 new.files[fn].value)\n    new.files[fn].offset = util.If(ref == 0,\n                                  z3.BitVecVal(0, dt.off_t),\n                                  new.files[fn].offset)\n    new.files[fn].omode = util.If(ref == 0,\n                                 z3.BitVecVal(0, dt.uint64_t),\n                                 new.files[fn].omode)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "218": {
        "sys_dup": [
            "\ndef sys_dup(old, oldfd, pid, newfd):\n    cond = z3.And(\n        # Validate pid is valid and has proper permissions\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate oldfd is valid and exists\n        z3.And(oldfd >= 0, oldfd < dt.NOFILE),\n        z3.And(z3.UGT(old.procs[old.current].ofile(oldfd), 0), \n               z3.ULT(old.procs[old.current].ofile(oldfd), dt.NFILE)),\n\n        # Validate newfd is valid and doesn't exist\n        z3.And(newfd >= 0, newfd < dt.NOFILE),\n        old.procs[pid].ofile(newfd) == 0\n    )\n\n    new = old.copy()\n\n    # Get the file number from the old fd\n    fn = new.procs[old.current].ofile(oldfd)\n\n    # Update the process's file descriptor table\n    new.procs[pid].ofile[newfd] = fn\n\n    # Increment the process's fd count\n    new.procs[pid].nr_fds[newfd] += 1\n\n    # Increment the file's reference count\n    new.files[fn].refcnt[(pid, newfd)] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "219": {
        "sys_lseek": [
            "\ndef sys_lseek(old, fd, offset):\n    # Validate fd, file number, and check conditions\n    cond = z3.And(\n        # fd must be valid (0 <= fd < NOFILE)\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        \n        # Get file number and validate it (0 < fn < NFILE)\n        z3.And(\n            z3.UGT(old.procs[old.current].ofile(fd), 0),\n            z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)\n        ),\n        \n        # File must be of type FD_INODE\n        old.files[old.procs[old.current].ofile(fd)].type == dt.file_type.FD_INODE,\n        \n        # Offset must be non-negative\n        offset >= 0\n    )\n\n    new = old.copy()\n    \n    # Get the file number from the process's file descriptor table\n    fn = new.procs[new.current].ofile(fd)\n    \n    # Update the file offset\n    new.files[fn].offset = offset\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "220": {
        "sys_map_pcipage": [
            "\ndef sys_map_pcipage(old, pt, index, pcipn, perm):\n    cond = z3.And(\n        # Validate PCI page number\n        z3.ULT(pcipn, dt.NPCIPAGE),\n        old.pcipages[pcipn].valid,\n\n        # Verify current process owns the PCI page\n        old.pcipages[pcipn].owner == old.pci[old.pcipages[pcipn].owner].owner,\n        old.pci[old.pcipages[pcipn].owner].owner == old.current,\n\n        # Validate page table page\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Validate index\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Verify target entry is empty\n        old.pages[pt].data(index) & dt.PTE_P == 0\n    )\n\n    new = old.copy()\n\n    # Calculate PCI page physical frame number\n    pfn = z3.UDiv(dt.PCI_START, z3.BitVecVal(dt.PAGE_SIZE, 64)) + pcipn\n\n    # Update page table entry with PCI page mapping\n    new.pages[pt].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain shadow page table state\n    new.pages[pt].pgtable_pn[index] = pcipn\n    new.pages[pt].pgtable_perm[index] = perm\n    new.pages[pt].pgtable_type[index] = dt.PGTYPE_PCIPAGE\n\n    # Invalidate TLB for the process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "221": {
        "sys_alloc_iommu_root": [
            "\ndef sys_alloc_iommu_root(old, devid, pn):\n    # Validation conditions\n    cond = z3.And(\n        # Device must not be already allocated\n        old.pci[devid].owner == 0,\n        \n        # Page must be valid and free\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].type == dt.page_type.PAGE_TYPE_FREE\n    )\n\n    new = old.copy()\n\n    # Assign device ownership to current process\n    new.pci[devid].owner = old.current\n    \n    # Update page type and ownership\n    new.pages[pn].type = dt.page_type.PAGE_TYPE_IOMMU_PML4\n    new.pages[pn].owner = old.current\n    new.pages[pn].data = z3.BitVecVal(0, 64)  # Zero the page contents\n    \n    # Update process page count\n    new.procs[old.current].nr_pages[pn] += 1\n    \n    # Update process device count\n    new.procs[old.current].nr_devs[devid] += 1\n    \n    # Set the IOMMU root page for this device\n    new.pci[devid].page_table_root = pn\n    \n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "222": {
        "sys_alloc_iommu_pdpt": [
            "\ndef sys_alloc_iommu_pdpt(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate that target page is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate source page type and ownership\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PML4,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions (only R/W bits allowed)\n        perm & ~(dt.PTE_P | dt.PTE_W) == 0,\n\n        # Verify entry is empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Map the PDPT page into the PML4\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n                                          z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Maintain shadow page table info\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Allocate and initialize the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PDPT\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "223": {
        "sys_alloc_iommu_pd": [
            "\ndef sys_alloc_iommu_pd(old, frm, index, to, perm):\n    # Preconditions for the operation\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Check source page type and ownership\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PDPT,\n        old.pages[frm].owner == old.current,\n        \n        # Verify target page is free\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n        \n        # Validate index is within bounds\n        z3.ULT(index, 512),\n        \n        # Check permissions - only PTE_P and PTE_W allowed\n        perm & ~(dt.PTE_P | dt.PTE_W) == 0,\n        \n        # Verify the entry is empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Calculate physical address for the page\n    pa = z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to\n\n    # Update the IOMMU page table entry\n    next_level = dt.page_type.PAGE_TYPE_IOMMU_FRAME - 1 - dt.page_type.PAGE_TYPE_IOMMU_PDPT\n    new.pages[frm].data[index] = (pa << dt.DMAR_PTE_ADDR_SHIFT) | perm | next_level\n\n    # Maintain shadow page table info\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Allocate the new PD page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PD\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "224": {
        "sys_alloc_iommu_pt": [
            "\ndef sys_alloc_iommu_pt(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate page numbers\n        z3.ULT(frm, dt.NPAGE),\n        z3.ULT(to, dt.NPAGE),\n        \n        # Check that 'to' page is free\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n        \n        # Check that 'frm' page is of correct type and owned by current process\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PD,\n        old.pages[frm].owner == old.current,\n        \n        # Validate index is within bounds\n        z3.ULT(index, 512),\n        \n        # Validate permissions (only R/W bits allowed)\n        perm & (dt.MAX_INT64 ^ (dt.DMAR_PTE_R | dt.DMAR_PTE_W)) == 0,\n        \n        # Check that target entry is empty\n        old.pages[frm].data(index) == 0\n    )\n    \n    new = old.copy()\n    \n    # Calculate next level type (PT is one level below PD)\n    next_level = dt.page_type.PAGE_TYPE_IOMMU_FRAME - 1 - dt.page_type.PAGE_TYPE_IOMMU_PD\n    \n    # Map the page table entry\n    new.pages[frm].data[index] = ((z3.UDiv(new.pages_ptr_to_int, \n                                          z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << \n                                 dt.DMAR_PTE_ADDR_SHIFT) | perm | next_level\n    \n    # Maintain shadow page table info\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n    \n    # Allocate the target page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_IOMMU_PT\n    new.pages[to].owner = old.current\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] += 1\n    \n    # Flush IOMMU TLB\n    new.flush_iotlb()\n    \n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "225": {
        "sys_alloc_iommu_frame": [
            "\ndef sys_alloc_iommu_frame(old, frm, index, to, perm):\n    cond = z3.And(\n        # Validate DMA page number and ensure it's free\n        z3.ULT(to, dt.NDMAPAGE),\n        old.dmapages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate source page is valid IOMMU PT and owned by current process\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_IOMMU_PT,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions (only PTE_P and PTE_W allowed)\n        perm & (dt.MAX_INT64 ^ (dt.PTE_P | dt.PTE_W)) == 0,\n\n        # Entry must be empty\n        old.pages[frm].data(index) == 0\n    )\n\n    new = old.copy()\n\n    # Map the IOMMU page table entry\n    new.pages[frm].data[index] = ((new.dmapages_ptr_to_int + to) << dt.DMAR_PTE_ADDR_SHIFT) | perm\n\n    # Update the \"shadow\" pgtable metadata\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_IOMMU_FRAME\n\n    # Allocate the DMA page as IOMMU frame\n    new.dmapages[to].type = dt.page_type.PAGE_TYPE_IOMMU_FRAME\n    new.dmapages[to].owner = old.current\n    new.procs[old.current].nr_dmapages[to] += 1\n\n    # Flush IOMMU TLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "226": {
        "sys_map_iommu_frame": [
            "\ndef sys_map_iommu_frame(old, pt, index, to, perm):\n    cond = z3.And(\n        # Validate that 'to' is a valid IOMMU frame owned by current\n        z3.ULT(to, dt.NDMAPAGE),\n        old.dmapages[to].type == dt.page_type.PAGE_TYPE_IOMMU_FRAME,\n        old.dmapages[to].owner == old.current,\n\n        # Validate pt is a valid page table owned by current\n        z3.ULT(pt, dt.NPAGE),\n        old.pages[pt].type == dt.page_type.PAGE_TYPE_X86_PT,\n        old.pages[pt].owner == old.current,\n\n        # Index is a valid page index\n        z3.ULT(index, 512),\n\n        # Check permissions are valid\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Entry must be empty (not present)\n        old.pages[pt].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Calculate physical frame number for the IOMMU frame\n    pfn = z3.UDiv(new.dmapages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to\n\n    # Update the page table entry with the new mapping\n    new.pages[pt].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable state\n    new.pages[pt].pgtable_pn[index] = to\n    new.pages[pt].pgtable_perm[index] = perm\n    new.pages[pt].pgtable_type[index] = dt.PGTYPE_IOMMU_FRAME\n\n    # Invalidate TLB for the process\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "227": {
        "sys_reclaim_iommu_frame": [
            "\ndef sys_reclaim_iommu_frame(old, dmapn):\n    cond = z3.And(\n        # Validate DMA page number\n        z3.ULT(dmapn, dt.NDMAPAGE),\n        \n        # Page must not be free\n        old.dmapages[dmapn].type != dt.page_type.PAGE_TYPE_FREE,\n        \n        # Get owner pid and verify it's a zombie process\n        z3.And(\n            z3.UGT(old.dmapages[dmapn].owner, 0),\n            z3.ULT(old.dmapages[dmapn].owner, dt.NPROC),\n            old.procs[old.dmapages[dmapn].owner].state == dt.proc_state.PROC_ZOMBIE\n        ),\n        \n        # Process must not have any active devices\n        old.procs[old.dmapages[dmapn].owner].nr_devs() == 0\n    )\n\n    new = old.copy()\n    \n    pid = old.dmapages[dmapn].owner\n\n    # Mark the page as free\n    new.dmapages[dmapn].type = dt.page_type.PAGE_TYPE_FREE\n    new.dmapages[dmapn].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Decrement the process's DMA page count\n    new.procs[pid].nr_dmapages[dmapn] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "228": {
        "sys_reclaim_iommu_root": [
            "\ndef sys_reclaim_iommu_root(old, devid):\n    # Get the process ID that owns the device\n    pid = old.pci[devid].owner\n\n    cond = z3.And(\n        # Process must be valid and in zombie state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        \n        # Process must not have any active interrupt remapping entries\n        old.procs[pid].nr_intremaps() == 0\n    )\n\n    new = old.copy()\n\n    # Decrement the device count for the process\n    new.procs[pid].nr_devs[devid] -= 1\n\n    # Clear the device ownership\n    new.pci[devid].owner = z3.BitVecVal(0, dt.pid_t)\n\n    # Reset the device's root page table\n    new.pci[devid].page_table_root = z3.BitVecVal(0, dt.pn_t)\n\n    # Flush the IOTLB\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "229": {
        "sys_alloc_vector": [
            "\ndef sys_alloc_vector(old, vector):\n    cond = z3.And(\n        # Check that the vector is not already allocated\n        old.vectors[vector].owner == 0,\n    )\n\n    new = old.copy()\n\n    # Assign the vector to the current process\n    new.vectors[vector].owner = old.current\n    \n    # Increment the vector count for the current process\n    new.procs[old.current].nr_vectors[vector] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "230": {
        "sys_reclaim_vector": [
            "\ndef sys_reclaim_vector(old, vector):\n    # Get the process ID that owns this vector\n    pid = old.vectors[vector].owner\n\n    # Conditions that must be satisfied:\n    # 1. The process must be valid and in ZOMBIE state\n    # 2. The process must have no active interrupt remappings\n    cond = z3.And(\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE,\n        old.procs[pid].nr_intremaps == 0\n    )\n\n    new = old.copy()\n\n    # Clear the vector ownership\n    new.vectors[vector].owner = z3.BitVecVal(0, dt.pid_t)\n\n    # Decrement the process's vector count\n    new.procs[pid].nr_vectors[vector] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "231": {
        "sys_alloc_intremap": [
            "\ndef sys_alloc_intremap(old, index, devid, vector):\n    cond = z3.And(\n        # Check if index is valid and free\n        z3.ULT(index, dt.NINTREMAP),\n        old.intremaps[index].state == dt.intremap_state.IR_FREE,\n\n        # Check if device is owned by current process\n        old.pci[devid].owner == old.current,\n\n        # Check if vector is owned by current process\n        old.vectors[vector].owner == old.current\n    )\n\n    new = old.copy()\n\n    # Update intremap state\n    new.intremaps[index].state = dt.intremap_state.IR_ACTIVE\n    new.intremaps[index].devid = devid\n    new.intremaps[index].vector = vector\n\n    # Update process intremap count\n    new.procs[new.current].nr_intremaps[index] += 1\n\n    # Flush IOTLB to ensure changes take effect\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "232": {
        "sys_reclaim_intremap": [
            "\ndef sys_reclaim_intremap(old, index):\n    # Validation conditions\n    cond = z3.And(\n        # Check if index is valid and entry is active\n        z3.ULT(index, dt.NINTREMAP),\n        old.intremaps[index].state == dt.intremap_state.IR_ACTIVE,\n\n        # Get the process ID from PCI table using the device ID\n        # and verify it's in zombie state\n        z3.And(old.procs[old.pci[old.intremaps[index].devid].owner].state == dt.proc_state.PROC_ZOMBIE,\n               old.pci[old.intremaps[index].devid].owner > 0,\n               old.pci[old.intremaps[index].devid].owner < dt.NPROC)\n    )\n\n    new = old.copy()\n\n    # Get the process ID that owns this interrupt remapping entry\n    pid = new.pci[old.intremaps[index].devid].owner\n\n    # Update the interrupt remapping entry state\n    new.intremaps[index].state = dt.intremap_state.IR_FREE\n    new.intremaps[index].devid = z3.BitVecVal(0, dt.devid_t)\n    new.intremaps[index].vector = z3.BitVecVal(0, dt.uint8_t)\n\n    # Decrement the process's interrupt remapping count\n    new.procs[pid].nr_intremaps[index] -= 1\n\n    # Flush the IOTLB to ensure hardware state is updated\n    new.flush_iotlb()\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "233": {
        "sys_ack_intr": [
            "\ndef sys_ack_intr(old, v):\n    # The condition should verify that v is a valid interrupt vector (0-255)\n    cond = z3.ULT(v, 256)\n\n    new = old.copy()\n\n    # Calculate the word index and bit mask for the interrupt vector\n    idx = z3.UDiv(z3.ZeroExt(64 - v.size(), v), 64)\n    mask = 1 << (v % 64)\n\n    # Clear the interrupt bit in the process's interrupt bitset\n    new.procs[new.current].intr[idx] = new.procs[new.current].intr(idx) & ~mask\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "234": {
        "sys_alloc_port": [
            "\ndef sys_alloc_port(old, port):\n    # Conditions for successful port allocation:\n    # 1. Port must be free (owner is 0)\n    # 2. Current process must have io_bitmap permission\n    cond = z3.And(\n        old.io[port].owner == 0,\n        old.procs[old.current].use_io_bitmap,\n    )\n\n    new = old.copy()\n\n    # Assign port ownership to current process\n    new.io[port].owner = old.current\n    \n    # Increment the port count for the current process\n    new.procs[old.current].nr_ports[port] += 1\n\n    # Calculate which bitmap page to use and the offset within it\n    page = util.If(z3.ULT(port, 0x8000),\n            new.procs[new.current].io_bitmap_a,\n            new.procs[new.current].io_bitmap_b)\n\n    # Adjust port number for bitmap_b\n    port = z3.ZeroExt(64 - port.size(), util.If(z3.ULT(port, 0x8000), port, port - 0x8000))\n\n    # Calculate word index and bit mask within the bitmap\n    idx = z3.UDiv(port, 64)\n    mask = 1 << (port % 64)\n\n    # Clear the bit in the appropriate bitmap\n    new.pages[page].data[idx] = new.pages[page].data(idx) & ~mask\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "235": {
        "sys_reclaim_port": [
            "\ndef sys_reclaim_port(old, port):\n    # Get the owner pid of the port\n    pid = old.io[port].owner\n    \n    # Check conditions:\n    # 1. The pid must be valid (> 0 and < NPROC)\n    # 2. The process must be in ZOMBIE state\n    cond = z3.And(\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_ZOMBIE\n    )\n\n    new = old.copy()\n\n    # Clear the port ownership\n    new.io[port].owner = z3.BitVecVal(0, dt.pid_t)\n    \n    # Decrement the number of ports owned by the process\n    new.procs[pid].nr_ports[port] -= 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "236": {
        "sys_alloc_pdpt": [
            "\ndef sys_alloc_pdpt(old, pid, frm, index, to, perm):\n    cond = z3.And(\n        # Validate pid and process relationship\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate source page (frm) is a valid PML4 owned by pid\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[frm].owner == pid,\n\n        # Validate target page (to) is free\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n        perm & dt.PTE_P != 0,\n\n        # Ensure target slot is empty\n        old.pages[frm].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Map the page in the page table\n    new.pages[frm].data[index] = ((z3.UDiv(\n        new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[frm].pgtable_pn[index] = to\n    new.pages[frm].pgtable_perm[index] = perm\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_PAGE\n\n    # Allocate the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_X86_PDPT\n    new.pages[to].owner = pid\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[to] += 1\n\n    # Initialize the \"shadow\" pgtable for the new PDPT\n    new.pages[to].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[to].pgtable_type = dt.PGTYPE_NONE\n\n    # Invalidate TLB after page table modification\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "237": {
        "sys_free_pdpt": [
            "\ndef sys_free_pdpt(old, frm, index, to):\n    cond = z3.And(\n        # Validate frm is a valid PML4 page owned by current process\n        z3.ULT(frm, dt.NPAGE),\n        old.pages[frm].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[frm].owner == old.current,\n\n        # Validate index is within bounds\n        z3.ULT(index, 512),\n\n        # Validate to is a valid PDPT page owned by current process\n        z3.ULT(to, dt.NPAGE),\n        old.pages[to].type == dt.page_type.PAGE_TYPE_X86_PDPT,\n        old.pages[to].owner == old.current,\n\n        # Check if entry exists and matches\n        old.pages[frm].data(index) & dt.PTE_P != 0,\n        \n        # Verify the physical address in the entry matches the target page\n        z3.Extract(63, 40, z3.UDiv(old.pages_ptr_to_int, \n                                  z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.BitVecVal(0, 24),\n        z3.Extract(39, 0, z3.UDiv(old.pages_ptr_to_int, \n                                 z3.BitVecVal(dt.PAGE_SIZE, 64)) + to) == z3.Extract(51, 12, old.pages[frm].data(index))\n    )\n\n    new = old.copy()\n\n    # Free the PDPT page\n    new.pages[to].type = dt.page_type.PAGE_TYPE_FREE\n    new.pages[to].owner = z3.BitVecVal(0, dt.pid_t)\n    new.pages[to].data = z3.BitVecVal(0, 64)\n    new.procs[old.current].nr_pages[to] -= 1\n\n    # Clear the entry in PML4\n    new.pages[frm].data[index] = z3.BitVecVal(0, 64)\n    \n    # Clear the shadow page table entries\n    new.pages[frm].pgtable_pn[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_perm[index] = z3.BitVecVal(0, 64)\n    new.pages[frm].pgtable_type[index] = dt.PGTYPE_NONE\n\n    # Invalidate TLB\n    new.flush_tlb(old.current)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "238": {
        "clone_proc": [
            "\ndef clone_proc(old, pid, pml4, stack, hvm):\n    # Validation conditions\n    cond = z3.And(\n        # Validate pid is valid and process is unused\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_UNUSED,\n\n        # Validate all pages are valid and free\n        z3.ULT(pml4, dt.NPAGE),\n        old.pages[pml4].type == dt.page_type.PAGE_TYPE_FREE,\n\n        z3.ULT(stack, dt.NPAGE),\n        old.pages[stack].type == dt.page_type.PAGE_TYPE_FREE,\n\n        z3.ULT(hvm, dt.NPAGE),\n        old.pages[hvm].type == dt.page_type.PAGE_TYPE_FREE,\n\n        # Ensure pages are distinct\n        z3.Distinct(pml4, stack, hvm)\n    )\n\n    new = old.copy()\n\n    # Initialize the new process\n    new.procs[pid].ppid = new.current\n    new.procs[pid].state = dt.proc_state.PROC_EMBRYO\n    new.procs[pid].killed = z3.BoolVal(False)\n    new.procs[pid].ipc_from = z3.BitVecVal(0, dt.pid_t)\n    new.procs[pid].ipc_val = z3.BitVecVal(0, dt.uint64_t)\n    new.procs[pid].ipc_page = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].ipc_size = z3.BitVecVal(0, dt.size_t)\n    new.procs[pid].ipc_fd = z3.BitVecVal(0, dt.fd_t)\n    new.procs[pid].use_io_bitmap = z3.BoolVal(False)\n    new.procs[pid].io_bitmap_a = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].io_bitmap_b = z3.BitVecVal(0, dt.pn_t)\n    new.procs[pid].ofile = z3.BitVecVal(0, dt.fn_t)\n    new.procs[pid].intr = z3.BitVecVal(0, 64)\n\n    # Initialize page table root\n    new.pages[pml4].type = dt.page_type.PAGE_TYPE_X86_PML4\n    new.pages[pml4].owner = pid\n    new.pages[pml4].data = z3.BitVecVal(0, 64)\n    new.procs[pid].nr_pages[pml4] += 1\n    new.pages[pml4].pgtable_pn = z3.BitVecVal(0, 64)\n    new.pages[pml4].pgtable_perm = z3.BitVecVal(0, 64)\n    new.pages[pml4].pgtable_type = dt.PGTYPE_NONE\n\n    # Initialize stack page\n    new.pages[stack].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[stack].owner = pid\n    new.pages[stack].data = old.pages[old.procs[old.current].stack].data\n    new.procs[pid].nr_pages[stack] += 1\n\n    # Initialize HVM page\n    new.pages[hvm].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[hvm].owner = pid\n    new.pages[hvm].data = old.pages[old.procs[old.current].hvm].data\n    new.procs[pid].nr_pages[hvm] += 1\n\n    # Set process page references\n    new.procs[pid].page_table_root = pml4\n    new.procs[pid].stack = stack\n    new.procs[pid].hvm = hvm\n\n    # Update parent's child count\n    new.procs[new.current].nr_children[pid] += 1\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "239": {
        "send_proc": [
            "\ndef send_proc(old, pid, val, pn, size, fd):\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        pid != old.current,\n\n        # Validate page number and ownership\n        z3.ULT(pn, dt.NPAGE),\n        old.pages[pn].owner == old.current,\n        \n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n\n        # Validate fd conditions\n        z3.Or(\n            # Either fd is invalid\n            z3.Not(z3.And(fd >= 0, fd < dt.NOFILE)),\n            # Or fd points to a valid file\n            z3.And(\n                z3.And(fd >= 0, fd < dt.NOFILE),\n                z3.And(\n                    z3.UGT(old.procs[old.current].ofile(fd), 0),\n                    z3.ULT(old.procs[old.current].ofile(fd), dt.NFILE)\n                )\n            )\n        )\n    )\n\n    new = old.copy()\n\n    # Update receiver's IPC state\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].ipc_size = size\n\n    # Copy data from sender's page to receiver's ipc_page\n    new.pages[new.procs[pid].ipc_page].data = lambda idx, oldfn: \\\n        util.If(z3.ULT(idx, z3.UDiv(size, 8)),\n                old.pages[pn].data(idx),\n                oldfn(idx))\n\n    # Handle file descriptor transfer if both fds are valid\n    fd_cond = z3.And(\n        z3.And(fd >= 0, fd < dt.NOFILE),\n        z3.And(new.procs[pid].ipc_fd >= 0, new.procs[pid].ipc_fd < dt.NOFILE)\n    )\n\n    # If fd transfer conditions met, update file descriptors\n    fn = old.procs[old.current].ofile(fd)\n    new.procs[pid].ofile = lambda fd_idx, oldfn: \\\n        util.If(z3.And(fd_cond, fd_idx == new.procs[pid].ipc_fd),\n                fn,\n                oldfn(fd_idx))\n\n    # Update file reference counts\n    new.procs[pid].nr_fds = lambda fd_idx, oldfn: \\\n        util.If(z3.And(fd_cond, fd_idx == new.procs[pid].ipc_fd),\n                oldfn(fd_idx) + 1,\n                oldfn(fd_idx))\n\n    new.files[fn].refcnt = lambda pid_fd, oldfn: \\\n        util.If(z3.And(fd_cond,\n                      pid_fd[0] == pid,\n                      pid_fd[1] == new.procs[pid].ipc_fd),\n                oldfn(pid_fd) + 1,\n                oldfn(pid_fd))\n\n    # Update process states\n    new.procs[old.current].state = dt.proc_state.PROC_RUNNABLE\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Update current process\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "240": {
        "reply_wait_proc": [
            "\ndef reply_wait_proc(old, pid, val, inpn, size, infd, outpn):\n    # Validate conditions for the operation\n    cond = z3.And(\n        # Validate pid and process state\n        z3.And(pid > 0, pid < dt.NPROC),\n        old.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n\n        # Validate input page\n        z3.ULT(inpn, dt.NPAGE),\n        old.pages[inpn].owner == old.current,\n\n        # Validate size\n        z3.ULE(size, dt.PAGE_SIZE),\n\n        # Validate input fd if valid\n        z3.Implies(z3.And(infd >= 0, infd < dt.NOFILE),\n                  z3.And(z3.UGT(old.procs[old.current].ofile(infd), 0),\n                        z3.ULT(old.procs[old.current].ofile(infd), dt.NFILE))),\n\n        # Validate output page\n        z3.ULT(outpn, dt.NPAGE),\n        old.pages[outpn].owner == old.current,\n        old.pages[outpn].type == dt.page_type.PAGE_TYPE_FRAME,\n\n        # Ensure pid != current (one sleeping, one running)\n        pid != old.current,\n\n        # Check if receiver accepts sender\n        z3.Or(old.procs[pid].ipc_from == 0,\n              old.procs[pid].ipc_from == old.current)\n    )\n\n    new = old.copy()\n\n    # Set up sender (current process) for waiting\n    new.procs[old.current].ipc_page = outpn\n    new.procs[old.current].ipc_fd = -1  # outfd is always -1 in reply_wait\n    new.procs[old.current].state = dt.proc_state.PROC_SLEEPING\n\n    # Set up receiver with data\n    new.procs[pid].ipc_from = old.current\n    new.procs[pid].ipc_val = val\n    new.procs[pid].state = dt.proc_state.PROC_RUNNING\n\n    # Copy data from input page to receiver's page\n    new.pages.data = lambda pn, idx, oldfn: \\\n        util.If(z3.And(pn == new.procs[pid].ipc_page,\n                      z3.ULT(idx, z3.UDiv(size + 7, 8))),  # size in bytes to uint64_t\n                old.pages[inpn].data(idx),\n                oldfn(pn, idx))\n\n    new.procs[pid].ipc_size = size\n\n    # Transfer fd if both infd and receiver's ipc_fd are valid\n    cond_fd = z3.And(\n        z3.And(infd >= 0, infd < dt.NOFILE),\n        z3.And(old.procs[pid].ipc_fd >= 0, old.procs[pid].ipc_fd < dt.NOFILE),\n        old.procs[pid].ofile(old.procs[pid].ipc_fd) == 0\n    )\n\n    # If fd transfer conditions met, update file descriptors\n    new.procs[pid].ofile = lambda fd, oldfn: \\\n        util.If(z3.And(cond_fd, fd == old.procs[pid].ipc_fd),\n               old.procs[old.current].ofile(infd),\n               oldfn(fd))\n\n    new.procs[pid].nr_fds = lambda fd, oldfn: \\\n        util.If(z3.And(cond_fd, fd == old.procs[pid].ipc_fd),\n               oldfn(fd) + 1,\n               oldfn(fd))\n\n    # Update file refcount if fd transfer occurs\n    fn = old.procs[old.current].ofile(infd)\n    new.files[fn].refcnt = lambda pid_fd, oldfn: \\\n        util.If(z3.And(cond_fd,\n                      pid_fd == (pid, old.procs[pid].ipc_fd)),\n               oldfn(pid_fd) + 1,\n               oldfn(pid_fd))\n\n    # Accept any IPC and switch current process\n    new.procs[old.current].ipc_from = 0\n    new.current = pid\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "241": {
        "sys_dup2": [
            "\ndef sys_dup2(old, oldfd, pid, newfd):\n    cond = z3.And(\n        # Validate pid is valid and has proper permissions\n        z3.And(pid > 0, pid < dt.NPROC),\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Validate file descriptors\n        z3.And(oldfd >= 0, oldfd < dt.NOFILE),\n        z3.And(newfd >= 0, newfd < dt.NOFILE),\n        \n        # Verify oldfd exists and points to valid file\n        z3.And(z3.UGT(old.procs[old.current].ofile(oldfd), 0), \n               z3.ULT(old.procs[old.current].ofile(oldfd), dt.NFILE))\n    )\n\n    new = old.copy()\n\n    # POSIX: If fds are the same in same process, do nothing\n    same_fd = z3.And(old.current == pid, oldfd == newfd)\n    \n    # Handle existing newfd case\n    existing_fd = z3.And(z3.UGT(old.procs[pid].ofile(newfd), 0),\n                        z3.ULT(old.procs[pid].ofile(newfd), dt.NFILE))\n    \n    # If newfd exists, clear it first\n    if_exists = new.copy()\n    old_fn = if_exists.procs[pid].ofile(newfd)\n    \n    # Clear the old fd\n    if_exists.procs[pid].ofile[newfd] = z3.BitVecVal(0, dt.fn_t)\n    if_exists.procs[pid].nr_fds[newfd] -= 1\n    if_exists.files[old_fn].refcnt[(pid, newfd)] -= 1\n    \n    # If refcount reaches 0, clear file metadata\n    ref = if_exists.files[old_fn].refcnt()\n    if_exists.files[old_fn].type = util.If(ref == 0, \n                                          dt.file_type.FD_NONE, \n                                          if_exists.files[old_fn].type)\n    if_exists.files[old_fn].value = util.If(ref == 0,\n                                           z3.BitVecVal(0, dt.uint64_t),\n                                           if_exists.files[old_fn].value)\n    if_exists.files[old_fn].offset = util.If(ref == 0,\n                                            z3.BitVecVal(0, dt.size_t),\n                                            if_exists.files[old_fn].offset)\n    if_exists.files[old_fn].omode = util.If(ref == 0,\n                                           z3.BitVecVal(0, dt.uint64_t),\n                                           if_exists.files[old_fn].omode)\n\n    # Set up new fd\n    fn = new.procs[old.current].ofile(oldfd)\n    new.procs[pid].ofile[newfd] = fn\n    new.procs[pid].nr_fds[newfd] += 1\n    new.files[fn].refcnt[(pid, newfd)] += 1\n\n    # Combine all conditions\n    result = util.If(same_fd,\n                    old,\n                    util.If(existing_fd,\n                           if_exists,\n                           new))\n\n    return cond, util.If(cond, result, old)\n"
        ]
    },
    "242": {
        "sys_alloc_io_bitmap": [
            "\ndef sys_alloc_io_bitmap(old, pn1, pn2, pn3):\n    # Validation conditions\n    cond = z3.And(\n        # Pages must be consecutive\n        pn1 + 1 == pn2,\n        pn2 + 1 == pn3,\n\n        # Pages must be valid\n        z3.ULT(pn1, dt.NPAGE),\n        z3.ULT(pn2, dt.NPAGE),\n        z3.ULT(pn3, dt.NPAGE),\n\n        # Process must not already have an I/O bitmap\n        z3.Not(old.procs[old.current].use_io_bitmap),\n\n        # All pages must be free\n        old.pages[pn1].type == dt.page_type.PAGE_TYPE_FREE,\n        old.pages[pn2].type == dt.page_type.PAGE_TYPE_FREE,\n        old.pages[pn3].type == dt.page_type.PAGE_TYPE_FREE\n    )\n\n    new = old.copy()\n\n    # Allocate first two pages for I/O bitmap\n    new.pages[pn1].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn1].owner = old.current\n    new.pages[pn1].data = z3.BitVecVal(-1, 64)  # All bits set to 1\n    new.procs[old.current].nr_pages[pn1] += 1\n\n    new.pages[pn2].type = dt.page_type.PAGE_TYPE_PROC_DATA\n    new.pages[pn2].owner = old.current\n    new.pages[pn2].data = z3.BitVecVal(-1, 64)  # All bits set to 1\n    new.procs[old.current].nr_pages[pn2] += 1\n\n    # Third page remains free but is initialized to all 1s\n    new.pages[pn3].data = z3.BitVecVal(-1, 64)  # All bits set to 1\n\n    # Update process I/O bitmap metadata\n    new.procs[old.current].io_bitmap_a = pn1\n    new.procs[old.current].io_bitmap_b = pn2\n    new.procs[old.current].use_io_bitmap = z3.BoolVal(True)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "243": {
        "extintr": [
            "\ndef extintr(old, v):\n    # Get the process ID from the vector table\n    pid = old.vectors[v].owner\n\n    # Check if the pid is valid\n    cond = z3.And(\n        z3.And(pid > 0, pid < dt.NPROC)\n    )\n\n    new = old.copy()\n\n    # Set the interrupt bit in the process's intr field\n    # Calculate word index and bit mask for the interrupt vector\n    word_idx = z3.UDiv(z3.ZeroExt(64 - v.size(), v), 64)\n    bit_mask = 1 << (v % 64)\n    \n    # Update the interrupt bit\n    new.procs[pid].intr[word_idx] = new.procs[pid].intr(word_idx) | bit_mask\n\n    # If process is sleeping, wake it up and set IPC values\n    new.procs[pid].state = util.If(\n        new.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        dt.proc_state.PROC_RUNNABLE,\n        new.procs[pid].state\n    )\n\n    # Set IPC values when waking up\n    new.procs[pid].ipc_from = util.If(\n        new.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.BitVecVal(0, dt.pid_t),\n        new.procs[pid].ipc_from\n    )\n\n    new.procs[pid].ipc_val = util.If(\n        new.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.ZeroExt(64 - v.size(), v),\n        new.procs[pid].ipc_val\n    )\n\n    new.procs[pid].ipc_size = util.If(\n        new.procs[pid].state == dt.proc_state.PROC_SLEEPING,\n        z3.BitVecVal(0, dt.size_t),\n        new.procs[pid].ipc_size\n    )\n\n    return cond, util.If(cond, new, old)\n"
        ]
    },
    "244": {
        "sys_map_pml4": [
            "\ndef sys_map_pml4(old, pid, index, perm):\n    cond = z3.And(\n        # Validate pid is valid (fixing the bug in the code where the check was negated)\n        z3.And(pid > 0, pid < dt.NPROC),\n\n        # Check if pid is current or an embryo belonging to current\n        z3.Or(pid == old.current,\n              z3.And(\n                  old.procs[pid].ppid == old.current,\n                  old.procs[pid].state == dt.proc_state.PROC_EMBRYO)),\n\n        # Get the page table root and validate it\n        z3.ULT(old.procs[pid].page_table_root, dt.NPAGE),\n        old.pages[old.procs[pid].page_table_root].type == dt.page_type.PAGE_TYPE_X86_PML4,\n        old.pages[old.procs[pid].page_table_root].owner == pid,\n\n        # Index is a valid page index\n        z3.ULT(index, 512),\n\n        # Check permissions - must not be writable and must be valid\n        perm & dt.PTE_W == 0,\n        perm & dt.PTE_P != 0,\n        \n        # No unsafe bits in permissions\n        perm & (dt.MAX_INT64 ^ dt.PTE_PERM_MASK) == 0,\n\n        # Entry must be empty (not present)\n        old.pages[old.procs[pid].page_table_root].data(index) & dt.PTE_P == 0,\n    )\n\n    new = old.copy()\n\n    # Calculate physical frame number for the PML4\n    pfn = z3.UDiv(new.pages_ptr_to_int, z3.BitVecVal(dt.PAGE_SIZE, 64)) + old.procs[pid].page_table_root\n\n    # Update the page table entry with the self-referential mapping\n    new.pages[old.procs[pid].page_table_root].data[index] = (pfn << dt.PTE_PFN_SHIFT) | perm\n\n    # Maintain the \"shadow\" pgtable\n    new.pages[old.procs[pid].page_table_root].pgtable_pn[index] = old.procs[pid].page_table_root\n    new.pages[old.procs[pid].page_table_root].pgtable_perm[index] = perm\n    new.pages[old.procs[pid].page_table_root].pgtable_type[index] = dt.PGTYPE_PAGE_DESC\n\n    # Invalidate TLB for the process\n    new.flush_tlb(pid)\n\n    return cond, util.If(cond, new, old)\n"
        ]
    }
}